<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hexo + NexT 搭建个人博客</title>
    <url>/2022/63969/</url>
    <content><![CDATA[<h1 id="1-主要安装步骤"><a href="#1-主要安装步骤" class="headerlink" title="1 主要安装步骤"></a>1 主要安装步骤</h1><h2 id="1-1-创建github仓库"><a href="#1-1-创建github仓库" class="headerlink" title="1.1 创建github仓库"></a>1.1 创建github仓库</h2><p>仓库命名：[username].github.io</p>
<h2 id="1-2-安装博客框架Hexo"><a href="#1-2-安装博客框架Hexo" class="headerlink" title="1.2 安装博客框架Hexo"></a>1.2 安装博客框架Hexo</h2><p><a href="https://hexo.io/zh-cn/docs/">Hexo安装文档</a>。在站点配置文件中，deploy字段修改为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: git@github.com:[username]/[username].github.io.git</span><br><span class="line">  branch: main</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>url字段修改为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://[username].github.io</span><br></pre></td></tr></table></figure>

<p>根据需要修改博客信息：author，title，subtitle等字段。</p>
<h2 id="1-3-下载博客主题NexT"><a href="#1-3-下载博客主题NexT" class="headerlink" title="1.3 下载博客主题NexT"></a>1.3 下载博客主题NexT</h2><p><a href="https://github.com/theme-next/hexo-theme-next">NexT安装</a><br>下载完成后，打开站点配置文件，找到theme字段，并将其值更改为next。在官方文档里有对使用NexT的教程，虽然这个教程似乎很久没更新过，但是基本步骤还是差不多的。</p>
<p>完成以上步骤后，hexo cl &amp;&amp; hexo g &amp;&amp; hexo s三连生成页面并在本地预览，hexo d将页面发布到[username].github.io.</p>
<h1 id="2-功能配置"><a href="#2-功能配置" class="headerlink" title="2 功能配置"></a>2 功能配置</h1><p>以下为可选功能，不是必须。</p>
<h2 id="2-1-评论功能"><a href="#2-1-评论功能" class="headerlink" title="2.1 评论功能"></a>2.1 评论功能</h2><p>gitment似乎不能用了，但是好在NexT已经支持gitalk，问题不大。教程详见gitalk评论系统。</p>
<h2 id="2-2-站内搜索功能"><a href="#2-2-站内搜索功能" class="headerlink" title="2.2 站内搜索功能"></a>2.2 站内搜索功能</h2><p>详见<a href="https://theme-next.iissnan.com/third-party-services.html#search-system">第三方服务集成</a>中Local Search部分。</p>
<h2 id="2-3-数学公式"><a href="#2-3-数学公式" class="headerlink" title="2.3 数学公式"></a>2.3 数学公式</h2><p><a href="https://blog.csdn.net/ssjdoudou/article/details/103318019">Hexo-next主题支持数学公式</a></p>
<h2 id="2-4-版权信息"><a href="#2-4-版权信息" class="headerlink" title="2.4 版权信息"></a>2.4 版权信息</h2><p>在<code>主题配置文件</code>中修改：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">creative_commons:</span><br><span class="line">  license: by-nc-sa</span><br><span class="line">  sidebar: false</span><br><span class="line">  post: true</span><br></pre></td></tr></table></figure>

<h2 id="2-5-永久链接"><a href="#2-5-永久链接" class="headerlink" title="2.5 永久链接"></a>2.5 永久链接</h2><p><a href="https://www.jianshu.com/p/c7de2ae59975">Hexo-abbrlink生成唯一永久文章链接</a>。但是按照这个教程修改站点配置文件的permalink字段好像没用，我按下面修改是有用的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">permalink: :year/:abbrlink/</span><br></pre></td></tr></table></figure>

<h2 id="2-6-统计信息"><a href="#2-6-统计信息" class="headerlink" title="2.6 统计信息"></a>2.6 统计信息</h2><p>我用的是不蒜子，优势是不需要注册，提供博客阅读量和访问人数数据。在主题配置文件里找到busuanzi字段，直接修改即可。</p>
<h2 id="2-7-搜索引擎抓取"><a href="#2-7-搜索引擎抓取" class="headerlink" title="2.7 搜索引擎抓取"></a>2.7 搜索引擎抓取</h2><p>可以参考这篇<a href="https://blog.csdn.net/fzhhsa/article/details/89839885">hexo个人博客收录谷歌</a>。</p>
]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>NexT</tag>
      </tags>
  </entry>
  <entry>
    <title>Git初学笔记</title>
    <url>/2022/22760/</url>
    <content><![CDATA[<blockquote>
<p>为了便于日常的查询和使用，将一些git命令总结这篇博客中。</p>
</blockquote>
<p>参考资料：</p>
<ul>
<li>用可视化的方法学习git：<a href="https://learngitbranching.js.org/?locale=zh_CN">https://learngitbranching.js.org/?locale=zh_CN</a></li>
<li>官方文档：<a href="https://git-scm.com/docs/gittutorial">https://git-scm.com/docs/gittutorial</a></li>
</ul>
<span id="more"></span>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">branch可以指代当前分支的最新commit</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">commit^ 表示某个commit的父节点</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">~n表示当前节点的n代父母节点</span></span><br><span class="line"></span><br><span class="line">git help &lt;command&gt;                 # 获取关于某个命令的帮助</span><br><span class="line">git status                         # 输出当前分支的信息</span><br><span class="line">git log                            # 显示git的历史纪录</span><br><span class="line">git diff &lt;file&gt;                    # 输出当前文件与暂存区中文件的区别</span><br><span class="line"></span><br><span class="line">git init                           # 将当前文件夹创建为git repo</span><br><span class="line">git add &lt;file&gt;                     # 将文件添加到暂存区</span><br><span class="line">git commit -m &lt;msg&gt;                # 提交当前分支至remote repo，只有在暂存区中的文件才会被commit</span><br><span class="line">git branch &lt;branch&gt;                # 创建新分支</span><br><span class="line">git branch -f &lt;branch&gt; &lt;commit&gt;    # 将某个分支强制移动到指定的commit节点</span><br><span class="line"></span><br><span class="line">git checkout &lt;branch&gt;              # 切换当前分支</span><br><span class="line">git checkout -b &lt;branch&gt;           # 切换当前分支，若分支不存在则创建</span><br><span class="line"></span><br><span class="line">git reset HEAD^                    # 所有内容回退到HEAD的父节点</span><br><span class="line">git reset HEAD^ &lt;filename&gt;         # 将某个文件回退到HEAD的父节点版本</span><br><span class="line">git reset &lt;commit&gt;                 # 所有内容回退到指定的commit节点</span><br><span class="line"></span><br><span class="line">git revert &lt;commit&gt;                # 撤销指定的commit</span><br><span class="line"></span><br><span class="line">git merge &lt;branch&gt;                 # 将指定分支与当前分支合并，产生一个新的commit节点</span><br><span class="line">git cherry-pick &lt;commit&gt;...        # 将指定commit节点复制到当前分支下</span><br><span class="line">git rebase -i &lt;commit&gt;             # 打开交互页面，显示哪些commit节点会放到指定commit节点下</span><br><span class="line"></span><br><span class="line">git tag &lt;tagname&gt; &lt;commit&gt;         # 在指定commit节点创建tag，可以使用tag指代commit</span><br><span class="line">git describe                       # 返回当前节点的最近tag、距离和节点hash</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">local</span> repo有个“remote repo”，用于描述remote repo的情况（上次同步后的状态，不一定是最新的）</span></span><br><span class="line">git fetch &lt;remote&gt;                 # 更新remote repo的所有分支</span><br><span class="line">git fetch &lt;remote&gt; &lt;branch&gt;        # 更新remote repo的指定分支</span><br><span class="line"></span><br><span class="line">git pull &lt;remote&gt;                  # 获取remote repo中与当前分支对应的分支，并与当前分支合并，等价于：</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">git fetch &lt;remote&gt;</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">git merge origin/&lt;current-branch&gt;</span></span><br><span class="line">git pull &lt;remote&gt; &lt;branch&gt;</span><br><span class="line"></span><br><span class="line">git push &lt;remote&gt; &lt;src-local-branch&gt;:&lt;dst-remote-branch&gt;       # 将本地分支推送到远程</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果不指明src，则是删除对应的remote-branch</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果不指明dst，则是更新到remote repo对应的分支</span></span><br><span class="line"></span><br><span class="line">git fetch &lt;remote&gt; &lt;src-local-branch&gt;:&lt;dst-remote-branch&gt;      # 将远程分支拉取到本地</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果不指明src，则是在<span class="built_in">local</span> repo增加对应的分支</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果不指明dst，则是拉取到<span class="built_in">local</span> repo对应的分支</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>MIT 6.S081 Lab1 Utilities</title>
    <url>/2022/35075/</url>
    <content><![CDATA[<p>参考资料：</p>
<ul>
<li>课程官方网页：<a href="https://pdos.csail.mit.edu/6.S081/2021/index.html">https://pdos.csail.mit.edu/6.S081/2021/index.html</a></li>
<li>xv6 book：<a href="https://pdos.csail.mit.edu/6.S081/2021/xv6/book-riscv-rev2.pdf">https://pdos.csail.mit.edu/6.S081/2021/xv6/book-riscv-rev2.pdf</a></li>
<li>xv6手册中文版：<a href="http://xv6.dgs.zone/">http://xv6.dgs.zone/</a></li>
<li>参考代码：<a href="http://doraemonzzz.com/tags/6-S081/">http://doraemonzzz.com/tags/6-S081/</a>，以下代码主要参考该工作。<span id="more"></span></li>
</ul>
<h1 id="0-配置实验环境"><a href="#0-配置实验环境" class="headerlink" title="0 配置实验环境"></a>0 配置实验环境</h1><ol>
<li>根据<a href="https://pdos.csail.mit.edu/6.S081/2021/tools.html">Tools Used in 6.S081</a>安装环境。</li>
<li>安装好后，在shell运行<code>make qemu</code>进入qemu环境。</li>
<li>同时按住<code>ctrl+a</code>然后松开这两个键，再按<code>x</code>可以退出qemu环境。</li>
</ol>
<h1 id="1-Boot-xv6-easy"><a href="#1-Boot-xv6-easy" class="headerlink" title="1 Boot xv6 (easy)"></a>1 Boot xv6 (easy)</h1><p>根据实验指示逐步执行即可：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> git://g.csail.mit.edu/xv6-labs-2021</span><br><span class="line">Cloning into <span class="string">&#x27;xv6-labs-2021&#x27;</span>...</span><br><span class="line">...</span><br><span class="line">$ <span class="built_in">cd</span> xv6-labs-2021</span><br><span class="line">$ git checkout util  <span class="comment"># 这里我的默认分支下是空的，需要签出分支后才能看到代码</span></span><br><span class="line">$ make qemu <span class="comment"># 进入qemu环境，并启动xv6系统</span></span><br></pre></td></tr></table></figure>

<h1 id="2-sleep-easy"><a href="#2-sleep-easy" class="headerlink" title="2 sleep (easy)"></a>2 sleep (easy)</h1><p>按照xv6教材和实验指示逐步执行即可。</p>
<h1 id="3-pingpong-easy"><a href="#3-pingpong-easy" class="headerlink" title="3 pingpong (easy)"></a>3 pingpong (easy)</h1><p>这个实验的意思是，child进程通过pipe给parent进程发一个字符，parent进程输出字符。同样的，parent进程也要给child进程发一个字符，child进程输出字符。</p>
<p>要注意的是，父子进程是通过同一个pipe通信的，因此要避免两个进程同时读或者同时写，并且parent必须等child进程结束后才能读，否则可能读到自己写的字符，因此需要先让parent进程写、child进程读，然后反过来：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> p[<span class="number">2</span>];</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">2</span>];</span><br><span class="line">    pipe(p);</span><br><span class="line">    <span class="type">int</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123; <span class="comment">// child</span></span><br><span class="line">        <span class="keyword">if</span> (read(p[<span class="number">0</span>], buf, <span class="number">1</span>) != <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Can&#x27;t read from parent!\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        close(p[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">1</span>, <span class="string">&quot;child receive: %c\n&quot;</span>, buf[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">1</span>, <span class="string">&quot;%d: received ping\n&quot;</span>, getpid());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (write(p[<span class="number">1</span>], <span class="string">&quot;b&quot;</span>, <span class="number">1</span>) != <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Can&#x27;t write to parent!\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        close(p[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;  <span class="comment">// parent</span></span><br><span class="line">        <span class="keyword">if</span> (write(p[<span class="number">1</span>], <span class="string">&quot;a&quot;</span>, <span class="number">1</span>) != <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Can&#x27;t write to child!\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        close(p[<span class="number">1</span>]);  </span><br><span class="line"></span><br><span class="line">        wait(<span class="number">0</span>); <span class="comment">// 如果不等待子进程结束，可能读的是&quot;a&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (read(p[<span class="number">0</span>], buf, <span class="number">1</span>) != <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Can&#x27;t read from child!\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        close(p[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">1</span>, <span class="string">&quot;parent receive: %c\n&quot;</span>, buf[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">1</span>, <span class="string">&quot;%d: received pong\n&quot;</span>, getpid());</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4-primes-moderate-x2F-hard"><a href="#4-primes-moderate-x2F-hard" class="headerlink" title="4 primes (moderate)&#x2F;(hard)"></a>4 primes (moderate)&#x2F;(hard)</h1><p>这个题的意思写一个并发版本的素数筛子，令多个筛子可以同时筛数。仔细看下图，这个图说明：如果某个数字在上一个筛子中没有被筛掉，并且这个数字是当前剩余数字中最小的那个，那么该数字是prime，需要输出，并且作为一个新的筛子。为了并行实现，可以通过fork产生子进程，父进程根据当前筛子向子进程输入数据，子进程则负责新的剩余数据，也就是说，实现父进程写和子进程读同时进行：<br><img data-src="/../images/sieve.gif"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">primes</span><span class="params">(<span class="type">int</span> *fd)</span> &#123;</span><br><span class="line">    <span class="type">int</span> p, d;</span><br><span class="line">    close(fd[<span class="number">1</span>]);  <span class="comment">// 由于fork时也复制了文件描述符，因此不需要的文件描述符应该关闭，以避免不可控的事情</span></span><br><span class="line">    <span class="keyword">if</span> (read(fd[<span class="number">0</span>], (<span class="type">void</span>*)&amp;p, <span class="keyword">sizeof</span>(p)) != <span class="keyword">sizeof</span>(p)) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Read fail!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;prime %d\n&quot;</span>, p);</span><br><span class="line">    <span class="keyword">if</span> (read(fd[<span class="number">0</span>], (<span class="type">void</span>*) &amp;d, <span class="keyword">sizeof</span>(d))) &#123;</span><br><span class="line">        <span class="type">int</span> fd1[<span class="number">2</span>];</span><br><span class="line">        pipe(fd1);</span><br><span class="line">        <span class="keyword">if</span> (fork() == <span class="number">0</span>) &#123;</span><br><span class="line">            primes(fd1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            close(fd1[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (d % p != <span class="number">0</span>) &#123;</span><br><span class="line">                    write(fd1[<span class="number">1</span>], (<span class="type">void</span>*) &amp;d, <span class="keyword">sizeof</span>(d));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">while</span> (read(fd[<span class="number">0</span>], (<span class="type">void</span>*)&amp;d, <span class="keyword">sizeof</span>(d)));</span><br><span class="line">            close(fd[<span class="number">0</span>]);</span><br><span class="line">            close(fd1[<span class="number">1</span>]);</span><br><span class="line">            wait(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> fd[<span class="number">2</span>];  <span class="comment">// fd[0]: read fd, fd[1]: write fd</span></span><br><span class="line">    <span class="type">int</span> start = <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> end = <span class="number">35</span>;</span><br><span class="line">    pipe(fd);</span><br><span class="line">    <span class="keyword">if</span> (fork() == <span class="number">0</span>) &#123;  <span class="comment">// 子进程</span></span><br><span class="line">        primes(fd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;  <span class="comment">// 父进程</span></span><br><span class="line">        close(fd[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt;= end; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (write(fd[<span class="number">1</span>], (<span class="type">void</span>*) &amp;i, <span class="keyword">sizeof</span>(i)) != <span class="number">4</span>) &#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Write fail!\n&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        close(fd[<span class="number">1</span>]);</span><br><span class="line">        wait(<span class="number">0</span>);  <span class="comment">// 防止出现孤儿进程</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="5-find-moderate"><a href="#5-find-moderate" class="headerlink" title="5 find (moderate)"></a>5 find (moderate)</h1><p>这个题要求实现给定目录和目标文件，输出给定目录及其子目录下的所有目标文件。仔细阅读<code>user/ls.c</code>：<code>fmtname</code>函数的功能是将输入<code>path</code>中最后一个<code>&#39;\&#39;</code>之后的内容截取出来，<code>ls</code>函数先将<code>fd</code>定向到<code>path</code>，用于后续读取<code>path</code>对应的文件或目录，<code>fstat</code>函数是读入fd指向文件的更具体的info，然后判断指向文件是什么类型，并进一步处理。对比<code>ls</code>和<code>find</code>的区别，可以发现<code>find</code>多了一个目标文件，并且<code>find</code>的<code>path</code>一定是一个目录。因此，<code>find</code>多了是否为目录的判断，以及文件名比对：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/fs.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span>*</span><br><span class="line"><span class="title function_">fmtname</span><span class="params">(<span class="type">char</span> *path)</span>  <span class="comment">// 获取path中最后一个‘/’之后的内容</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">char</span> buf[DIRSIZ+<span class="number">1</span>];</span><br><span class="line">  <span class="type">char</span> *p;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Find first character after last slash.</span></span><br><span class="line">  <span class="keyword">for</span>(p=path+<span class="built_in">strlen</span>(path); p &gt;= path &amp;&amp; *p != <span class="string">&#x27;/&#x27;</span>; p--)</span><br><span class="line">    ;</span><br><span class="line">  p++;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return blank-padded name.</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">strlen</span>(p) &gt;= DIRSIZ)</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">  memmove(buf, p, <span class="built_in">strlen</span>(p));</span><br><span class="line">  <span class="built_in">memset</span>(buf+<span class="built_in">strlen</span>(p), <span class="string">&#x27; &#x27;</span>, DIRSIZ-<span class="built_in">strlen</span>(p));</span><br><span class="line">  <span class="keyword">return</span> buf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">find</span><span class="params">(<span class="type">char</span> *path, <span class="type">char</span> *target_file)</span> &#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">512</span>], *p;</span><br><span class="line">  <span class="type">int</span> fd;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> <span class="title">de</span>;</span>  <span class="comment">// 目录信息</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span>  <span class="comment">// </span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((fd = open(path, <span class="number">0</span>)) &lt; <span class="number">0</span>)&#123;  <span class="comment">// 将fd定向到path</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;find: cannot open %s\n&quot;</span>, path);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(fstat(fd, &amp;st) &lt; <span class="number">0</span>)&#123;  <span class="comment">// 读入fd指向的文件info</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;find: cannot stat %s\n&quot;</span>, path);</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (read(fd, &amp;de, <span class="keyword">sizeof</span>(de)) != <span class="keyword">sizeof</span>(de)) &#123;  <span class="comment">// 判断能否读入fd指向的文件</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;find, cannot read %s\n&quot;</span>, path);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span>(st.type)&#123;</span><br><span class="line">  <span class="keyword">case</span> T_FILE:</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(de.name, target_file) == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%s/%s\n&quot;</span>, path, target_file);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> T_DIR:</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strlen</span>(path) + <span class="number">1</span> + DIRSIZ + <span class="number">1</span> &gt; <span class="keyword">sizeof</span> buf)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;ls: path too long\n&quot;</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">strcpy</span>(buf, path);</span><br><span class="line">    p = buf+<span class="built_in">strlen</span>(buf);</span><br><span class="line">    *p++ = <span class="string">&#x27;/&#x27;</span>;  <span class="comment">// buf下一层文路径</span></span><br><span class="line">    <span class="keyword">while</span>(read(fd, &amp;de, <span class="keyword">sizeof</span>(de)) == <span class="keyword">sizeof</span>(de))&#123;  <span class="comment">// 读取fd指向的文件</span></span><br><span class="line">      <span class="keyword">if</span>((de.inum == <span class="number">0</span>) || (<span class="built_in">strcmp</span>(de.name, <span class="string">&quot;.&quot;</span>) == <span class="number">0</span>) || (<span class="built_in">strcmp</span>(de.name, <span class="string">&quot;..&quot;</span>) == <span class="number">0</span>))&#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      memmove(p, de.name, DIRSIZ);</span><br><span class="line">      p[DIRSIZ] = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span>(stat(buf, &amp;st) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;find: cannot stat %s\n&quot;</span>, buf);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (st.type == T_FILE) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(de.name, target_file) == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, buf);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (st.type == T_DIR) find(buf, target_file);  <span class="comment">// 如果当前是目录，需要递归比对</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  close(fd);    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Usage: find [dir] [target_file]&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        find(argv[<span class="number">1</span>], argv[<span class="number">2</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="6-xargs-moderate"><a href="#6-xargs-moderate" class="headerlink" title="6 xargs (moderate)"></a>6 xargs (moderate)</h1><p>这个实验要求实现的功能是实现<code>xargs</code>命令的简化版本。主要思路是先根据<code>\n</code>确定一条命令，然后根据空格分辨出命令和它的参数。本题比较麻烦的是指针和字符数组的处理，需要特别小心：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/param.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLEN 1024</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">copy</span><span class="params">(<span class="type">char</span> **p1, <span class="type">char</span> *p2)</span> &#123;</span><br><span class="line">    *p1 = <span class="built_in">malloc</span>(<span class="built_in">strlen</span>(p2) + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(*p1, p2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">readLine</span><span class="params">(<span class="type">char</span> **pars, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="type">char</span> buf[MAXLEN];</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (read(<span class="number">0</span>, buf + j, <span class="number">1</span>)) &#123;  <span class="comment">// 每次读取一个字符，直到遇到\n，即读取一条命令</span></span><br><span class="line">        <span class="keyword">if</span> (buf[j] == <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">            buf[j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ++j;</span><br><span class="line">        <span class="keyword">if</span> (j == MAXLEN) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Parameters are too long!\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;  <span class="comment">// 没有读取到内容，即已经到pars的结尾</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (k &lt; j) &#123;  <span class="comment">// 一条命令可能有多个参数，每个参数保存在pars[i]中</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt; MAXARG) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Too much parameters!\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> ((k &lt; j) &amp;&amp; (buf[k] == <span class="string">&#x27; &#x27;</span>)) &#123;  <span class="comment">// 去掉命令的前导空格</span></span><br><span class="line">            ++k;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> l = k;</span><br><span class="line">        <span class="keyword">while</span> ((k &lt; j) &amp;&amp; (buf[k] != <span class="string">&#x27; &#x27;</span>)) &#123;</span><br><span class="line">            ++k;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        buf[k++] = <span class="number">0</span>;</span><br><span class="line">        copy(&amp;pars[i], buf + l);</span><br><span class="line">        ++i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Please enter more parameters!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *pars[MAXARG];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; argc; ++i) &#123;</span><br><span class="line">        copy(&amp;pars[i<span class="number">-1</span>], argv[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> e;</span><br><span class="line">    <span class="keyword">while</span> ((e = readLine(pars, argc - <span class="number">1</span>)) != <span class="number">-1</span>) &#123;</span><br><span class="line">        pars[e] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (fork() == <span class="number">0</span>) &#123;  <span class="comment">// 子进程执行命令</span></span><br><span class="line">            exec(pars[<span class="number">0</span>], pars);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            wait(<span class="number">0</span>);  <span class="comment">// 父进程等待子进程完成</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>MIT 6.S081</tag>
      </tags>
  </entry>
  <entry>
    <title>MIT 6.S081 Lab2 System Calls</title>
    <url>/2022/35594/</url>
    <content><![CDATA[<p>参考资料：</p>
<ul>
<li>课程官方网页：<a href="https://pdos.csail.mit.edu/6.S081/2021/index.html">https://pdos.csail.mit.edu/6.S081/2021/index.html</a></li>
<li>xv6 book：<a href="https://pdos.csail.mit.edu/6.S081/2021/xv6/book-riscv-rev2.pdf">https://pdos.csail.mit.edu/6.S081/2021/xv6/book-riscv-rev2.pdf</a></li>
<li>xv6手册中文版：<a href="http://xv6.dgs.zone/">http://xv6.dgs.zone/</a></li>
<li>参考代码：<a href="https://github.com/PKUFlyingPig/MIT6.S081-2020fall">https://github.com/PKUFlyingPig/MIT6.S081-2020fall</a></li>
</ul>
<span id="more"></span>

<h1 id="1-System-call-tracing-moderate"><a href="#1-System-call-tracing-moderate" class="headerlink" title="1 System call tracing (moderate)"></a>1 System call tracing (moderate)</h1><h2 id="1-1-题意"><a href="#1-1-题意" class="headerlink" title="1.1 题意"></a>1.1 题意</h2><p>这个题目的意思是，修改xv6系统的kernel，使得可以用<code>trace</code>跟踪系统调用输出<code>process id</code>，<code>system call name</code>和<code>return value</code>，并且<code>trace</code>调用需要保证可以跟踪调用进程及其子进程。<code>trace.c</code>已经实现了在user-level实现了trace的功能，我们只需要在kernel-level补充相关实现。</p>
<h2 id="1-2-实现步骤"><a href="#1-2-实现步骤" class="headerlink" title="1.2 实现步骤"></a>1.2 实现步骤</h2><p>根据题目提示，首先是在<code>user/user.h</code>增加trace函数的声明，在<code>user/usys.pl</code>增加trace函数的stub,<code>kernel/syscall.h</code>增加syscall number，这是为了使得xv6系统能通过编译：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// `user/user.h`</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">trace</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// user/usys.pl</span></span><br><span class="line">entry(<span class="string">&quot;trace&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// kernel/syscall.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_trace  22</span></span><br></pre></td></tr></table></figure>
<p>后两步的目的在于，将trace函数声明为syscall函数，使得<code>trace.c</code>的第17行调用trace函数时会自动调用系统函数。</p>
<p>然而，trace函数实际上在kernel-level并没有被实现。为了实现这一目标，根据题目提示，<code>kernel/proc.h</code>的进程结构中需要增加一个变量mask，用于记住调用trace syscall时所需的参数。<code>kernel/sysproc.c</code>中需要实现sys_trace()函数，该函数可以用于获取用户输入的变量mask，将其保存到进程中：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/proc.h</span></span><br><span class="line"><span class="type">int</span> mask;                    <span class="comment">// trace mask</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// kernel/sysproc.c</span></span><br><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_trace</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="type">int</span> mask;</span><br><span class="line">  <span class="keyword">if</span>(argint(<span class="number">0</span>, &amp;mask) &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  myproc()-&gt;mask = mask;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时，由于trace需要能跟踪子进程，因此需要修改<code>kernel/proc.c</code>中的fork()函数，使得trace mask可以复制到child process中：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/proc.c</span></span><br><span class="line">np-&gt;mask = p-&gt;mask;  <span class="comment">// copy mask from parent to child</span></span><br></pre></td></tr></table></figure>

<p>上述步骤实际上是实现trace的准备工作，为了实际实现trace功能，需要修改<code>kernel/syscall.c</code>的syscall()函数，用于打印trace的输出：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/syscall.c</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_trace</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="title function_">uint64</span> <span class="params">(*syscalls[])</span><span class="params">(<span class="type">void</span>)</span> = &#123;</span><br><span class="line">  ...</span><br><span class="line">  [SYS_trace]   sys_trace,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* sysnames[] = &#123;</span><br><span class="line">  <span class="string">&quot;fork&quot;</span>, <span class="string">&quot;exit&quot;</span>, <span class="string">&quot;wait&quot;</span>, <span class="string">&quot;pipe&quot;</span>, <span class="string">&quot;read&quot;</span>, <span class="string">&quot;kill&quot;</span>, <span class="string">&quot;exec&quot;</span>, <span class="string">&quot;fstat&quot;</span>, </span><br><span class="line">  <span class="string">&quot;chdir&quot;</span>, <span class="string">&quot;dup&quot;</span>, <span class="string">&quot;getpid&quot;</span>, <span class="string">&quot;sbrk&quot;</span>, <span class="string">&quot;sleep&quot;</span>, <span class="string">&quot;uptime&quot;</span>, <span class="string">&quot;open&quot;</span>, <span class="string">&quot;write&quot;</span>, </span><br><span class="line">  <span class="string">&quot;mknod&quot;</span>, <span class="string">&quot;unlink&quot;</span>, <span class="string">&quot;link&quot;</span>, <span class="string">&quot;mkdir&quot;</span>,<span class="string">&quot;close&quot;</span>,<span class="string">&quot;trace&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">syscall</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> num;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  num = p-&gt;trapframe-&gt;a7;  <span class="comment">// syscall number</span></span><br><span class="line">  <span class="keyword">if</span>(num &gt; <span class="number">0</span> &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123;</span><br><span class="line">    p-&gt;trapframe-&gt;a0 = syscalls[num]();  <span class="comment">// return value</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (p-&gt;mask &amp; (<span class="number">1</span> &lt;&lt; num))  <span class="comment">// syscall必须在mask中指定才能有输出</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d: syscall %s -&gt; %d\n&quot;</span>, p-&gt;pid, sysnames[num<span class="number">-1</span>], p-&gt;trapframe-&gt;a0);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %s: unknown sys call %d\n&quot;</span>,</span><br><span class="line">            p-&gt;pid, p-&gt;name, num);</span><br><span class="line">    p-&gt;trapframe-&gt;a0 = <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="1-3-总结"><a href="#1-3-总结" class="headerlink" title="1.3 总结"></a>1.3 总结</h1><ul>
<li><blockquote>
<p>在最开始，我们设置了一个perl脚本，Makefile会调用<code>user/usys.pl</code>，生成一个<code>user/usys.S</code>，这个文件就像一个switch语句一样，当你使用一个系统调用的时候，比如read，OS会查询<code>user/usys.S</code>中对应的标签target来执行相应的语句。</p>
</blockquote>
</li>
<li>注意看<code>user/usys.pl</code>中<code>print &quot; li a7, SYS_$&#123;name&#125;\n&quot;;</code>把被调用syscall名称放入寄存器a7，而在<code>kernel/syscall.c</code>中，syscall的编号也是在寄存器a7中获取的。</li>
<li>syscall的通用注册和实现流程：<ul>
<li><code>user/user.h</code>中声明该函数</li>
<li><code>user/usys.pl</code>中增加对应的syscall name</li>
<li><code>kernel/syscall.h</code>中增加syscall number</li>
<li><code>kernel/proc.h</code>的<strong>process</strong>结构中增加该syscall需要的变量</li>
<li><code>kernel/sysproc.c</code>中实现sys_*函数，该函数用于处理调用sys_*后需要做的事情</li>
<li><code>kernel/proc.c</code>中可以处理sys_*涉及到的变量在<strong>process</strong>中的使用</li>
<li><code>kernel/syscall.c</code>中增加指向新的系统函数的指针，并且可以修改<code>syscall</code>函数以配合sys_*的功能</li>
</ul>
</li>
<li>myproc可以用于获取当前正在运行的process</li>
</ul>
<h1 id="2-Sysinfo-moderate"><a href="#2-Sysinfo-moderate" class="headerlink" title="2 Sysinfo (moderate)"></a>2 Sysinfo (moderate)</h1><h2 id="2-1-题意"><a href="#2-1-题意" class="headerlink" title="2.1 题意"></a>2.1 题意</h2><p>本题要求增加系统调用<code>sysinfo</code>用于收集running system的信息，该系统调用函数使用一个指向<code>struct sysinfo</code>的指针作为输入。结构体字段包括freemem字段应该设置为空闲内存的字节数，nproc字段应该设置成状态不是UNUSED的进程数。</p>
<h2 id="2-2-实现步骤"><a href="#2-2-实现步骤" class="headerlink" title="2.2 实现步骤"></a>2.2 实现步骤</h2><p>根据题目提示，首先类似1.2注册sysinfo这个系统调用，并且需要在<code>user/user.h</code>中预声明<code>struct sysinfo</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// `user/user.h`</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sysinfo</span>;</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sysinfo</span><span class="params">(<span class="keyword">struct</span> sysinfo*)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// user/usys.pl</span></span><br><span class="line">entry(<span class="string">&quot;sysinfo&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// kernel/syscall.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_sysinfo  23</span></span><br></pre></td></tr></table></figure>

<p>然后，在<code>kernel/sysproc.c</code>中实现sys_sysinfo函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/sysproc.c</span></span><br><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_sysinfo</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 p;  <span class="comment">// pointer to struct sysinfo address</span></span><br><span class="line">  <span class="keyword">if</span>(argaddr(<span class="number">0</span>, &amp;p) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sysinfo</span> <span class="title">info</span>;</span></span><br><span class="line">  info.freemem = freemem();  <span class="comment">// get free memory</span></span><br><span class="line">  info.nproc = nproc();  <span class="comment">// get used proc</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span>* <span class="title">curproc</span> =</span> myproc();</span><br><span class="line">  <span class="comment">// copyout: curprocess pagetable, dst, src, size</span></span><br><span class="line">  <span class="keyword">if</span> (copyout(curproc-&gt;pagetable, p, (<span class="type">char</span>*)&amp;info, <span class="keyword">sizeof</span>(info)) &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据题目提示，freemem函数在<code>kernel/kalloc.c</code>中实现，nproc函数在<code>kernel/proc.c</code>中实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/kalloc.c</span></span><br><span class="line">uint64 <span class="title function_">freemem</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line">  uint64 sz = <span class="number">0</span>;</span><br><span class="line">  acquire(&amp;kmem.lock);</span><br><span class="line">  r = kmem.freelist;  <span class="comment">// freelist是第一个未被使用的页的地址</span></span><br><span class="line">  <span class="keyword">while</span> (r) &#123;</span><br><span class="line">    sz += <span class="number">1</span>;</span><br><span class="line">    r = r -&gt; next;</span><br><span class="line">  &#125;</span><br><span class="line">  sz = sz * PGSIZE;</span><br><span class="line">  release(&amp;kmem.lock);</span><br><span class="line">  <span class="keyword">return</span> sz;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// kernel/proc.c</span></span><br><span class="line">uint64 <span class="title function_">nproc</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  uint64 cnt = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NPROC; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (proc[i].state != UNUSED) ++cnt;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-3-总结"><a href="#2-3-总结" class="headerlink" title="2.3 总结"></a>2.3 总结</h2><p>无</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>MIT 6.S081</tag>
      </tags>
  </entry>
  <entry>
    <title>MIT 6.S081 Lab3 Page Tables</title>
    <url>/2022/29909/</url>
    <content><![CDATA[<ul>
<li>课程官方网页：<a href="https://pdos.csail.mit.edu/6.S081/2021/index.html">https://pdos.csail.mit.edu/6.S081/2021/index.html</a></li>
<li>xv6 book：<a href="https://pdos.csail.mit.edu/6.S081/2021/xv6/book-riscv-rev2.pdf">https://pdos.csail.mit.edu/6.S081/2021/xv6/book-riscv-rev2.pdf</a></li>
<li>xv6手册中文版：<a href="http://xv6.dgs.zone/">http://xv6.dgs.zone/</a></li>
<li>参考代码：<a href="https://blog.csdn.net/qq_33894666/article/details/121625097">https://blog.csdn.net/qq_33894666/article/details/121625097</a></li>
</ul>
<h1 id="0-Preliminary"><a href="#0-Preliminary" class="headerlink" title="0 Preliminary"></a>0 Preliminary</h1><h1 id="1-Speed-up-system-calls-easy"><a href="#1-Speed-up-system-calls-easy" class="headerlink" title="1 Speed up system calls (easy)"></a>1 Speed up system calls (easy)</h1><h2 id="1-1-题意"><a href="#1-1-题意" class="headerlink" title="1.1 题意"></a>1.1 题意</h2><p>第一个任务是实现对系统调用<code>getpid</code>的优化。具体地说，当每个进程创建时，都映射一个read-only的页到<code>USYSCALL</code>（定义在<code>kernel/memlayout.h</code>中的<strong>虚拟地址</strong>），这个页的开头是一个<code>struct usyscall</code>，并将当前进程的pid保存在其中。</p>
<h2 id="1-2-实验步骤"><a href="#1-2-实验步骤" class="headerlink" title="1.2 实验步骤"></a>1.2 实验步骤</h2><p>根据提示，需要把一个结构体<code>struct usyscall</code>映射到<code>kernel/memlayout.h</code>中的<code>USYSCALL</code>地址。映射过程在<code>kernel/proc.c</code>中的<code>proc_pagetable</code>函数中执行，映射过程中需要用到<code>mappages</code>函数，且在使用<code>mappages</code>函数时设定给userspace只读权限的permission bits。此外需要在<code>allocproc</code>中分配和初始化页，以及确保在<code>freeproc</code>中初始化内存。在完成以上步骤后，就可以通过直接读取<code>USYSCALL</code>，获取进程id，而无需通过系统调用<code>getpid</code>获取进程id。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernal/proc.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">usyscall</span> *<span class="title">usysc</span>;</span>      <span class="comment">// 在进程结构体中添加保存映射信息的部分</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// kernal/proc.c</span></span><br><span class="line"><span class="type">pagetable_t</span></span><br><span class="line"><span class="title function_">proc_pagetable</span><span class="params">(<span class="keyword">struct</span> proc *p)</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将USYSCALL映射到进程的usysc</span></span><br><span class="line">  <span class="keyword">if</span> (mappages(pagetable, USYSCALL, PGSIZE, (uint64)(p-&gt;usysc), PTE_U | PTE_R) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    uvmfree(pagetable, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// kernal/proc.c</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> proc*</span><br><span class="line"><span class="title function_">allocproc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 给进程的usysc分配空间</span></span><br><span class="line">  <span class="keyword">if</span> ((p-&gt;usysc = (<span class="keyword">struct</span> usyscall *)kalloc()) == <span class="number">0</span>) &#123;</span><br><span class="line">    freeproc(p);</span><br><span class="line">    release(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  p-&gt;usysc-&gt;pid = p-&gt;pid;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// kernal/proc.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">freeproc</span><span class="params">(<span class="keyword">struct</span> proc *p)</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(p-&gt;usysc)</span><br><span class="line">    kfree((<span class="type">void</span>*)p-&gt;usysc);</span><br><span class="line">  p-&gt;usysc = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// kernal/proc.c</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">proc_freepagetable</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 sz)</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  uvmunmap(pagetable, USYSCALL, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="2-Print-a-page-table-easy"><a href="#2-Print-a-page-table-easy" class="headerlink" title="2 Print a page table (easy)"></a>2 Print a page table (easy)</h1><h2 id="2-1-题意"><a href="#2-1-题意" class="headerlink" title="2.1 题意"></a>2.1 题意</h2><p>本题要求实现函数<code>vmprint</code>，输入是<code>pagetable_t</code>，标准输出页表内容：page-table page，pte bits，physical address，不输出无效的pte。</p>
<h2 id="2-2-实验步骤"><a href="#2-2-实验步骤" class="headerlink" title="2.2 实验步骤"></a>2.2 实验步骤</h2><p>根据提示，首先在<code>exec.c</code>中添加<code>vmprint</code>调用语句<code>if(p-&gt;pid==1) vmprint(p-&gt;pagetable)</code>，并且在<code>kernel/defs.h</code>中添加<code>vmprint</code>函数的声明。接着，仔细阅读<code>kernel/vm.c</code>中的<code>freewalk</code>，并参照该函数实现<code>vmprint</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// exec.c</span></span><br><span class="line"><span class="keyword">if</span> (p-&gt;pid == <span class="number">1</span>) vmprint(p-&gt;pagetable);</span><br><span class="line"></span><br><span class="line"><span class="comment">// kernel/defs.h</span></span><br><span class="line"><span class="type">void</span>            <span class="title function_">vmprint</span><span class="params">(<span class="type">pagetable_t</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// kernel/vm.c</span></span><br><span class="line"><span class="type">void</span> __vmprint(<span class="type">pagetable_t</span> pagetable, <span class="type">int</span> level) &#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">512</span>; i++)&#123;</span><br><span class="line">    <span class="type">pte_t</span> pte = pagetable[i];</span><br><span class="line">    <span class="keyword">if</span>((pte &amp; PTE_V) &amp;&amp; (pte &amp; (PTE_R|PTE_W|PTE_X)) == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="comment">// this PTE points to a lower-level page table.</span></span><br><span class="line">      uint64 child = PTE2PA(pte);</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= level; ++j) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;..&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (j + <span class="number">1</span> &lt;= level) <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d: pte %p pa %p\n&quot;</span>, i, pte, child);</span><br><span class="line">      __vmprint((<span class="type">pagetable_t</span>)child, level + <span class="number">1</span>);  </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pte &amp; PTE_V)&#123;  <span class="comment">// leaf pte</span></span><br><span class="line">      uint64 child = PTE2PA(pte);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;.. .. ..%d: pte %p pa %p\n&quot;</span>, i, pte, child);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">vmprint</span><span class="params">(<span class="type">pagetable_t</span> p)</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;page table %p\n&quot;</span>, p);</span><br><span class="line">  __vmprint(p, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-Detecting-which-pages-have-been-accessed-hard"><a href="#3-Detecting-which-pages-have-been-accessed-hard" class="headerlink" title="3 Detecting which pages have been accessed (hard)"></a>3 Detecting which pages have been accessed (hard)</h1><h2 id="3-1-题意"><a href="#3-1-题意" class="headerlink" title="3.1 题意"></a>3.1 题意</h2><p>题目要求实现函数<code>pgaccess</code>，该函数用于报告哪个页被访问过。该函数包括三个输入参数：首先是待检查的第一个user page的虚拟地址（virtual address, va）；第二，是要检查的页的数量；第三，保存结果的结构体，该结构体以bitmask的形式保存页表是否被访问过，其中最低位对应第一个页。</p>
<h2 id="3-2-实现步骤"><a href="#3-2-实现步骤" class="headerlink" title="3.2 实现步骤"></a>3.2 实现步骤</h2><p>根据<code>user/pgtbltest.c</code>中的<code>pgaccess_test</code>函数，<code>pgaccess</code>有三个输入参数：<code>buf</code>、32和<code>&amp;abits</code>。<code>buf</code>是新申请的内存，大小为32个页，在当前进程的页表中有指向这些页的pte，我们只要获取<strong>最终</strong>指向这些页的pte，就可以知道这些页是否被访问过。我们可以根据<code>buf</code>的va为索引在当前进程的页表中找到这些pte，**<code>buf</code>本身就是va**。32表示页数。<code>abits</code>用于保存这32个页是否被访问过的结果，<code>&amp;abits</code>使得<code>pgaccess</code>函数可以直接修改<code>abits</code>。</p>
<p>RISC-V在硬件上已经实现了将page是否被访问过保存在pte的flags中，本题要做的只是把flags中的内容提取出来。<code>pageaccess</code>已经在userspace层面实现，所以只需要在kernel level实现<code>sys_pgaccess</code>函数即可。根据提示，需要在<code>kernel/riscv.h</code>中定义<code>PTE_A</code>，即判断一个页是否被访问过的bit（类似<code>PTE_U</code>，<code>PTE_R</code>等），根据<a href="https://pdos.csail.mit.edu/6.S081/2021/xv6/book-riscv-rev2.pdf">xv6 book</a>的Fig 3.2可知，<code>PTE_A</code>应该是每个PTE的右起第6个bit：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/riscv.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_A (1L &lt;&lt; 6) <span class="comment">// accessed</span></span></span><br></pre></td></tr></table></figure>

<p>在<code>sys_pgaccess</code>函数中，首先需要获取保存在寄存器中的参数，这和Lab2是一样的。然后，就可以根据va（再次强调，**<code>buf</code>本身就是va**）在当前进程的页表中索引到对应的<code>pte</code>，索引过程可以参考<code>kernel/vm.c</code>中的<code>walk</code>函数。最后，将这些<code>pte</code>的<code>PTE_A</code>截取出来保存到输出结果中，并且重置<code>PTE_A</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">sys_pgaccess</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// lab pgtbl: your code here.</span></span><br><span class="line">  uint64 va;           <span class="comment">// va保存待检查的page数组的虚拟地址</span></span><br><span class="line">  <span class="type">int</span> page_num;        <span class="comment">// 要核验的page数</span></span><br><span class="line">  uint64 abits_addr;   <span class="comment">// abits从低到高记录page是否被访问过，abits_addr保存abits的地址</span></span><br><span class="line">  <span class="keyword">if</span> (argaddr(<span class="number">0</span>, &amp;va) &lt; <span class="number">0</span> || argint(<span class="number">1</span>, &amp;page_num) &lt; <span class="number">0</span> || argaddr(<span class="number">2</span>, &amp;abits_addr) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(va &gt;= MAXVA)</span><br><span class="line">    panic(<span class="string">&quot;walk&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">pagetable_t</span> pagetable = myproc() -&gt; pagetable;</span><br><span class="line">  uint mask = <span class="number">0</span>;  <span class="comment">// 内核数据</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; page_num; ++i, va += PGSIZE) &#123;</span><br><span class="line">    <span class="type">pte_t</span> *pte = <span class="number">0</span>;</span><br><span class="line">    <span class="type">pagetable_t</span> p = pagetable;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> level = <span class="number">2</span>; level &gt;= <span class="number">0</span>; --level) &#123;</span><br><span class="line">      <span class="comment">// PX根据level提取va对应的9bit的L0/L1/L2，即64bits只有最右9bit起作用，可以索引pagetable不越界</span></span><br><span class="line">      pte = &amp;p[PX(level, va)];  <span class="comment">// 根据L0/L1/L2获取页表中对应的pte，并取其地址</span></span><br><span class="line">      <span class="keyword">if</span>(*pte &amp; PTE_V)  <span class="comment">// 如果该PTE有效</span></span><br><span class="line">        p = (<span class="type">pagetable_t</span>)PTE2PA(*pte);  <span class="comment">// 找到次一级页表</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (*pte&amp;PTE_V &amp;&amp; *pte&amp;PTE_A) &#123;</span><br><span class="line">      mask = mask | (<span class="number">1L</span> &lt;&lt; i); </span><br><span class="line">      *pte &amp;= ~PTE_A;  <span class="comment">// 重置pte的PTE_A</span></span><br><span class="line">    &#125;    </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (copyout(pagetable, abits_addr, (<span class="type">char</span>*)&amp;mask, <span class="keyword">sizeof</span>(uint64)) &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-3-总结"><a href="#3-3-总结" class="headerlink" title="3.3 总结"></a>3.3 总结</h2><p>在做这个实验时，我一直没搞明白<code>buf</code>到底指什么：它是pte？还是pagetable。后来读了参考代码才搞清楚，buf实际上就是大小为32个页的内存，当前进程的页表里有指向这些页的pte。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>MIT 6.S081</tag>
      </tags>
  </entry>
  <entry>
    <title>如何在电脑上操作手机</title>
    <url>/2022/8240/</url>
    <content><![CDATA[<blockquote>
<p>手机进了水，能开机，想把手机上的资料都备份一下。但是因为屏幕花了看得很吃力、不方便，所以打算在电脑上操作手机。</p>
</blockquote>
<p>参考1：<a href="https://www.zhihu.com/question/46795475/answer/869985800">如何在电脑上控制手机上所有的app软件操作？ - 张脑湿的回答 - 知乎</a></p>
<span id="more"></span>
<p>参考2：<a href="https://jingyan.baidu.com/article/08b6a591a3658955a80922ad.html">小米手机开发者模式怎么打开</a><br>参考3：<a href="https://blog.csdn.net/qq_50082325/article/details/121696514">Scrcpy投屏神器基本使用</a></p>
<h1 id="1-开启小米手机的开发者模式"><a href="#1-开启小米手机的开发者模式" class="headerlink" title="1 开启小米手机的开发者模式"></a>1 开启小米手机的开发者模式</h1><ul>
<li>设置 -&gt; 我的设备 -&gt; 全部参数 -&gt; MIUI 版本</li>
<li>连续点击“MIUI 版本”，直到弹出提示“您现在处于开发者模式”</li>
<li>设置 -&gt; 更多设置 -&gt; 开发者选项，允许“USB调试”和“USB调试（安全设置）”</li>
</ul>
<h1 id="2-下载scrcpy"><a href="#2-下载scrcpy" class="headerlink" title="2 下载scrcpy"></a>2 下载scrcpy</h1><ul>
<li>scrcpy是一款开源免费投屏控制软件，项目地址见scrcpy</li>
</ul>
<h1 id="3-将手机投屏到电脑"><a href="#3-将手机投屏到电脑" class="headerlink" title="3 将手机投屏到电脑"></a>3 将手机投屏到电脑</h1><ul>
<li>电脑开热点，然后手机连接电脑的热点，此时在电脑上可以看到手机的ip，等会需要用到这个ip。</li>
<li>手机通过USB连接到电脑，在USB配置弹窗中选择“文件传输”</li>
<li>在scrcpy目录中打开终端</li>
<li>终端中执行命令adb tcpip [端口号]，例如adb tcpip 5555</li>
<li>断开USB连接</li>
<li>终端中执行命令adb connect [ip]: [端口号]，例如adb connect 192.168.137.10: 5555</li>
<li>终端中执行命令scrcpy运行scrcpy软件</li>
</ul>
]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>tips</tag>
      </tags>
  </entry>
  <entry>
    <title>用树莓派3b搭建个人网盘</title>
    <url>/2022/15837/</url>
    <content><![CDATA[<blockquote>
<p>在淘宝上花10块钱搞了一大堆电子书，打算用树莓派3b搞个个人网盘存起来。虽然网口速度不行，但是一本书也就2MB左右，问题不大。</p>
</blockquote>
<p>参考1：<a href="https://blog.csdn.net/lz_quiet/article/details/103651730">私有云搭建-owncloud</a></p>
<span id="more"></span> 
<p>参考2：<a href="https://central.owncloud.org/t/access-denied-to-mariadb-any-suggestions/2783/3">Access denied to MariaDB. Any suggestions?</a></p>
<p>参考3：<a href="https://blog.chongyeye.com/?id=6">树莓派owncloud私有云挂载NTFS本地存储</a></p>
<h1 id="1-更换软件源"><a href="#1-更换软件源" class="headerlink" title="1 更换软件源"></a>1 更换软件源</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo nano /etc/apt/sources.list</span><br><span class="line"></span><br><span class="line"># 注释掉原来的源</span><br><span class="line"># deb http://raspbian.raspberrypi.org/raspbian/ buster main contrib non-free rpi</span><br><span class="line"># Uncomment line below then &#x27;apt-get update&#x27; to enable &#x27;apt-get source&#x27;</span><br><span class="line"># deb-src http://raspbian.raspberrypi.org/raspbian/ buster main contrib non-free rpi</span><br><span class="line"></span><br><span class="line"># 添加清华源</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ stretch main contrib non-free rpi</span><br><span class="line"></span><br><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure>

<h1 id="2-安装php"><a href="#2-安装php" class="headerlink" title="2 安装php"></a>2 安装php</h1><p>这里安装php不指明具体版本，直接安装默认版本，避免找不到对应版本的错误。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install php</span><br><span class="line">sudo apt-get install php-mysql php-zip php-xml php-intl php-mbstring php-gd php-curl</span><br></pre></td></tr></table></figure>

<h1 id="3-安装apache2"><a href="#3-安装apache2" class="headerlink" title="3 安装apache2"></a>3 安装apache2</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install apache2</span><br><span class="line"></span><br><span class="line"># 启动apache2</span><br><span class="line">systemctl restart apache2</span><br></pre></td></tr></table></figure>

<h1 id="4-安装mariadb"><a href="#4-安装mariadb" class="headerlink" title="4 安装mariadb"></a>4 安装mariadb</h1><p>不知道为什么搜索不到mysql-server的源，按<a href="https://blog.csdn.net/lz_quiet/article/details/103651730">参考1</a>装了mariadb-server。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install mariadb-server</span><br></pre></td></tr></table></figure>

<h1 id="5-数据库管理"><a href="#5-数据库管理" class="headerlink" title="5 数据库管理"></a>5 数据库管理</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo mysql -uroot -p</span><br><span class="line"></span><br><span class="line">CREATE DATABASE IF NOT EXISTS owncloud;</span><br><span class="line">GRANT ALL PRIVILEGES ON owncloud.* TO &#x27;owncloudUser&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;123123&#x27;;</span><br></pre></td></tr></table></figure>
<p>在mariadb执行完以上命令后，需要刷新再退出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FLUSH PRIVILEGES;</span><br><span class="line">exit</span><br><span class="line"></span><br><span class="line"># 退出后重启服务</span><br><span class="line">systemctl restart mariadb</span><br></pre></td></tr></table></figure>

<h1 id="6-安装owncloud"><a href="#6-安装owncloud" class="headerlink" title="6 安装owncloud"></a>6 安装owncloud</h1><p>按照<a href="https://blog.csdn.net/lz_quiet/article/details/103651730">参考1</a>执行。</p>
<h1 id="7-挂载机械硬盘"><a href="#7-挂载机械硬盘" class="headerlink" title="7 挂载机械硬盘"></a>7 挂载机械硬盘</h1><p>主要参考了<a href="https://blog.chongyeye.com/?id=6">树莓派owncloud私有云挂载NTFS本地存储</a>。以下操作针对NTFS硬盘格式。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 安装NTFS-3G</span><br><span class="line">sudo apt-get install ntfs-3g</span><br><span class="line"></span><br><span class="line"># 查看硬盘是否被检测到</span><br><span class="line">fdisk -l</span><br><span class="line"></span><br><span class="line"># 创建目录，挂载硬盘</span><br><span class="line">sudo mkdir -p /media/owncloudData</span><br><span class="line">sudo mount -t ntfs-3g  /dev/sda1 /media/owncloudData</span><br><span class="line"></span><br><span class="line"># 在owncloud中开启本地存储</span><br><span class="line">sudo nano /var/www/html/owncloud/config/config.php</span><br><span class="line"></span><br><span class="line"># 在文档中添加一句</span><br><span class="line">&#x27;files_external_allow_create_new_local&#x27; =&gt; &#x27;true&#x27;,</span><br></pre></td></tr></table></figure>
<p>之后，在owncloud的管理员setting中启用外置存储，完成。</p>
<h1 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h1><ul>
<li>树莓派直接给机械硬盘供电很吃力。</li>
<li>没有公共IP，设备只有和树莓派处于同一个子网时才能访问。</li>
</ul>
]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>树莓派</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL语句速成</title>
    <url>/2022/63903/</url>
    <content><![CDATA[<blockquote>
<p>工作中时不时要用到SQL语句，根据SQL经典50题复习下SQL语句的用法。</p>
</blockquote>
<p>参考资料：</p>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/38354000">图解SQL面试题：经典50题</a></li>
<li><a href="https://blog.csdn.net/m0_56869501/article/details/121011304">inner join 、left join 、right join 和full join的区别</a><span id="more"></span></li>
</ul>
<h1 id="1-创建表和添加数据"><a href="#1-创建表和添加数据" class="headerlink" title="1 创建表和添加数据"></a>1 创建表和添加数据</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> [tableName]([fieldName] [fieldType]...);</span><br><span class="line"><span class="comment">-- e.g.,</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> student(学号 <span class="type">VARCHAR</span>(<span class="number">255</span>), 姓名 <span class="type">VARCHAR</span>(<span class="number">255</span>), 出生日期 DATETIME(<span class="number">6</span>), 性别 <span class="type">VARCHAR</span>(<span class="number">255</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> [tableName] <span class="keyword">VALUES</span>(...);</span><br><span class="line"><span class="comment">-- e.g.,</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Student <span class="keyword">VALUES</span>(<span class="string">&#x27;01&#x27;</span> , <span class="string">&#x27;赵雷&#x27;</span> , <span class="string">&#x27;1990-01-01&#x27;</span> , <span class="string">&#x27;男&#x27;</span>);</span><br></pre></td></tr></table></figure>
<h1 id="2-查询"><a href="#2-查询" class="headerlink" title="2 查询"></a>2 查询</h1><h2 id="2-1-简单查询"><a href="#2-1-简单查询" class="headerlink" title="2.1 简单查询"></a>2.1 简单查询</h2><p>只涉及一张表的简单查询，<code>SELECT</code>指定查询目标；<code>FROM</code>指定查询对象；<code>WHERE</code>指定查询条件：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询姓王的学生的信息</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> student</span><br><span class="line"><span class="keyword">WHERE</span> 姓名 <span class="keyword">LIKE</span> <span class="string">&#x27;王%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询姓王的学生的个数</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(学号)</span><br><span class="line"><span class="keyword">FROM</span> student</span><br><span class="line"><span class="keyword">WHERE</span> 姓名 <span class="keyword">LIKE</span> <span class="string">&#x27;王%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h2 id="2-2-分组查询"><a href="#2-2-分组查询" class="headerlink" title="2.2 分组查询"></a>2.2 分组查询</h2><p><code>GROUP BY</code>指定分组字段，即根据哪个字段分组；<code>HAVING</code>对<code>GROUP BY</code>得到的结果作出限制；<code>ORDER BY</code>对最终结果进行排序，其中<code>DESC</code>为降序，<code>ASC</code>为升序；<code>LIMIT i, n</code>从查询结果中取出指定行，<code>i</code>指定从哪一行开始取数据，<code>n</code>指定取多少条数据，当<code>i=0</code>时可以省略指定<code>i</code>：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询每门课程选修的学生数</span></span><br><span class="line"><span class="keyword">SELECT</span> 课程号, <span class="built_in">COUNT</span>(学号)</span><br><span class="line"><span class="keyword">FROM</span> score</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> 课程号;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询平均成绩大于60分学生的学号和平均成绩</span></span><br><span class="line"><span class="keyword">SELECT</span> 学号, <span class="built_in">AVG</span>(成绩)</span><br><span class="line"><span class="keyword">FROM</span> score</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> 学号</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">AVG</span>(成绩)<span class="operator">&gt;</span><span class="number">60</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询总成绩排名前3的学生的学号</span></span><br><span class="line"><span class="keyword">SELECT</span> 学号</span><br><span class="line"><span class="keyword">FROM</span> score</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> 学号</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="built_in">SUM</span>(成绩) <span class="keyword">DESC</span></span><br><span class="line">LIMIT <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<h2 id="2-3-复杂查询"><a href="#2-3-复杂查询" class="headerlink" title="2.3 复杂查询"></a>2.3 复杂查询</h2><p>涉及到至少两张表的查询，也是平时工作中较常见的情况。</p>
<h3 id="2-3-1-子查询"><a href="#2-3-1-子查询" class="headerlink" title="2.3.1 子查询"></a>2.3.1 子查询</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询所有课程成绩小于60分学生的学号、姓名</span></span><br><span class="line"><span class="keyword">SELECT</span> s.学号, s.姓名</span><br><span class="line"><span class="keyword">FROM</span> student s</span><br><span class="line"><span class="keyword">WHERE</span> s.学号 <span class="keyword">IN</span> (</span><br><span class="line">  <span class="keyword">SELECT</span> 学号</span><br><span class="line">  <span class="keyword">FROM</span> score</span><br><span class="line">  <span class="keyword">GROUP</span> <span class="keyword">BY</span> 学号</span><br><span class="line">  <span class="keyword">HAVING</span> <span class="built_in">MAX</span>(成绩)<span class="operator">&lt;</span><span class="number">60</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h3 id="2-3-2-多表查询"><a href="#2-3-2-多表查询" class="headerlink" title="2.3.2 多表查询"></a>2.3.2 多表查询</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询所有学生的学号、姓名、选课数、总成绩</span></span><br><span class="line"><span class="keyword">SELECT</span> stu.学号, stu.姓名, <span class="built_in">COUNT</span>(sc.课程号) <span class="keyword">AS</span> 选课数, <span class="built_in">SUM</span>(sc.成绩) <span class="keyword">AS</span> 总成绩</span><br><span class="line"><span class="keyword">FROM</span> student <span class="keyword">AS</span> stu <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> score <span class="keyword">AS</span> sc</span><br><span class="line"><span class="keyword">ON</span> stu.学号 <span class="operator">=</span> sc.学号</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> stu.学号</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询平均成绩大于85的所有学生的学号、姓名和平均成绩</span></span><br><span class="line"><span class="keyword">SELECT</span> stu.学号, stu.姓名, <span class="built_in">AVG</span>(sc.成绩) <span class="keyword">AS</span> 平均成绩</span><br><span class="line"><span class="keyword">FROM</span> student <span class="keyword">AS</span> stu <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> score <span class="keyword">AS</span> sc</span><br><span class="line"><span class="keyword">ON</span> stu.学号 <span class="operator">=</span> sc.学号</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> stu.学号</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">AVG</span>(sc.成绩)<span class="operator">&gt;</span><span class="number">85</span>;</span><br></pre></td></tr></table></figure>
<p>多表查询涉及到表联结，包括<code>INNOR JOIN</code> &#x2F; <code>JOIN</code>，<code>LEFT JOIN</code>，<code>RIGHT JOIN</code>，<code>FULL JOIN</code>，<code>CROSS JOIN</code>：</p>
<ul>
<li><code>INNOR JOIN</code> &#x2F; <code>JOIN</code>：返回左右表完全符合匹配条件时的数据</li>
</ul>
<p><img data-src="/../images/sql/inner_join.png" alt="`INNOR JOIN`"></p>
<ul>
<li><code>LEFT JOIN</code>：基于左表去匹配右表，结果左表全部行都显示，右表判断列与左边一致才有数据</li>
</ul>
<p><img data-src="/../images/sql/left_join.png" alt="`LEFT JOIN`"></p>
<ul>
<li><code>RIGHT JOIN</code>：基于右表去匹左表，结果右表全部行都显示，左表判断列与右表一致才有数据</li>
</ul>
<p><img data-src="/../images/sql/right_join.png" alt="`RIGHT JOIN`"></p>
<ul>
<li><code>FULL JOIN</code>：左右表格的行全部都有，左右表格判断一致的在同一行，不一致的单独一行。注意MYSQL数据库不支持<code>FULL JOIN</code>，可以通过同时使用<code>LEFT JOIN</code>和<code>RIGHT JOIN</code>，再使用<code>UNION</code>合并二者结果来实现。</li>
</ul>
<p><img data-src="/../images/sql/full_join.png" alt="`FULL JOIN`"></p>
<ul>
<li><code>CROSS JOIN</code>：返回的是左右表的笛卡尔乘积</li>
</ul>
<h3 id="2-3-3-CASE表达式"><a href="#2-3-3-CASE表达式" class="headerlink" title="2.3.3 CASE表达式"></a>2.3.3 CASE表达式</h3><p>根据数据转换为不同结果：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询各分数段的人数、课程号和课程名称</span></span><br><span class="line"><span class="keyword">SELECT</span> sc.课程号, c.课程名称,</span><br><span class="line">  <span class="built_in">SUM</span>(<span class="keyword">CASE</span></span><br><span class="line">        <span class="keyword">WHEN</span> 成绩 <span class="keyword">BETWEEN</span> <span class="number">80</span> <span class="keyword">AND</span> <span class="number">100</span> <span class="keyword">THEN</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">ELSE</span> <span class="number">0</span> <span class="keyword">END</span></span><br><span class="line">      ) <span class="keyword">AS</span> <span class="string">&#x27;[100-80]&#x27;</span>,</span><br><span class="line">  <span class="built_in">SUM</span>(<span class="keyword">CASE</span></span><br><span class="line">        <span class="keyword">WHEN</span> 成绩<span class="operator">&gt;=</span><span class="number">60</span> <span class="keyword">AND</span> 成绩<span class="operator">&lt;</span><span class="number">80</span> <span class="keyword">THEN</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">ELSE</span> <span class="number">0</span> <span class="keyword">END</span></span><br><span class="line">      ) <span class="keyword">AS</span> <span class="string">&#x27;[80-60]&#x27;</span>,</span><br><span class="line">  <span class="built_in">SUM</span>(<span class="keyword">CASE</span></span><br><span class="line">        <span class="keyword">WHEN</span> 成绩<span class="operator">&lt;</span><span class="number">60</span> <span class="keyword">THEN</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">ELSE</span> <span class="number">0</span> <span class="keyword">END</span></span><br><span class="line">      ) <span class="keyword">AS</span> <span class="string">&#x27;[&lt;60]&#x27;</span></span><br><span class="line"><span class="keyword">FROM</span> score <span class="keyword">AS</span> sc <span class="keyword">JOIN</span> course <span class="keyword">AS</span> c</span><br><span class="line"><span class="keyword">ON</span> sc.课程号 <span class="operator">=</span> c.课程号</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> sc.课程号, c.课程名称;</span><br></pre></td></tr></table></figure>

<h1 id="3-修改数据和数据表"><a href="#3-修改数据和数据表" class="headerlink" title="3 修改数据和数据表"></a>3 修改数据和数据表</h1><p>基本的<code>UPDATE</code>语句由三部分组成：要更新的表，列名和它们的新值；确定要更新哪些行的过滤条件：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> [tableName]</span><br><span class="line"><span class="keyword">SET</span> [field]</span><br><span class="line"><span class="keyword">WHERE</span> [<span class="keyword">condition</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">-- e.g.,</span></span><br><span class="line"><span class="keyword">UPDATE</span> student</span><br><span class="line"><span class="keyword">SET</span> 姓名<span class="operator">=</span><span class="string">&#x27;赵五&#x27;</span></span><br><span class="line"><span class="keyword">WHERE</span> 学号<span class="operator">=</span><span class="string">&#x27;11&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h1 id="4-删除数据和数据表"><a href="#4-删除数据和数据表" class="headerlink" title="4 删除数据和数据表"></a>4 删除数据和数据表</h1><h2 id="4-1-DELETE"><a href="#4-1-DELETE" class="headerlink" title="4.1 DELETE"></a>4.1 DELETE</h2><p>用于删除表中的特定数据：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> [tableName] <span class="keyword">WHERE</span> [codition];</span><br></pre></td></tr></table></figure>

<h2 id="4-2-DROP"><a href="#4-2-DROP" class="headerlink" title="4.2 DROP"></a>4.2 DROP</h2><p>删除整张表，包括表数据和表结构：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> [tableName];</span><br></pre></td></tr></table></figure>

<h2 id="4-3-TRUNCATE"><a href="#4-3-TRUNCATE" class="headerlink" title="4.3 TRUNCATE"></a>4.3 TRUNCATE</h2><p>清空表中数据：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> [tableName];</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> [查询目标]    <span class="comment">-- 指定要输出的结果</span></span><br><span class="line"><span class="keyword">FROM</span> [查询对象]      <span class="comment">-- 指定查哪些表，可以使用表联结：LEFT JOIN/INNER JOIN等</span></span><br><span class="line"><span class="keyword">WHERE</span> [查询条件]     <span class="comment">-- 可以使用子查询：IN/NOT IN</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> [分组字段]</span><br><span class="line"><span class="keyword">HAVING</span> [分组条件]    <span class="comment">-- 去掉不符合条件的分组，可以使用子查询：IN/NOT IN</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> [排序字段]  <span class="comment">-- 对分组结果进行排序</span></span><br><span class="line">LIMIT [i, n];</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Vim初学笔记（基于vimtutor）</title>
    <url>/2022/19295/</url>
    <content><![CDATA[<blockquote>
<p>之前一直觉得vim难用，远远比不上vscode之类的编辑器好用。最近在学Java后端开发，敲代码的时候居然感觉vim编辑器好像是方便一些，所以打算再复习一下。以下笔记仅供查阅。</p>
</blockquote>
<span id="more"></span>
<h1 id="1-基本操作"><a href="#1-基本操作" class="headerlink" title="1 基本操作"></a>1 基本操作</h1><h2 id="1-1-移动光标"><a href="#1-1-移动光标" class="headerlink" title="1.1 移动光标"></a>1.1 移动光标</h2><ul>
<li>h 左移</li>
<li>l 右移</li>
<li>j 下移</li>
<li>k 上移</li>
</ul>
<h2 id="1-2-删除、插入和添加"><a href="#1-2-删除、插入和添加" class="headerlink" title="1.2 删除、插入和添加"></a>1.2 删除、插入和添加</h2><ul>
<li>x 删除</li>
<li>a 在光标后插入</li>
<li>A 行尾插入</li>
<li>i 在光标前插入</li>
<li>I 在行首插入</li>
</ul>
<h1 id="2-组合命令"><a href="#2-组合命令" class="headerlink" title="2 组合命令"></a>2 组合命令</h1><h2 id="2-1-删除操作和相关命令"><a href="#2-1-删除操作和相关命令" class="headerlink" title="2.1 删除操作和相关命令"></a>2.1 删除操作和相关命令</h2><ul>
<li>de 删除当前字符到单词末尾</li>
<li>dw 删除当前光标到下个单词之前的内容 </li>
<li>d$ 删除本行光标之后的所有字符（包括光标指向的字符）</li>
<li>dd 删除整行（实际上相当于剪切）</li>
</ul>
<h2 id="2-2-关于命令和对象"><a href="#2-2-关于命令和对象" class="headerlink" title="2.2 关于命令和对象"></a>2.2 关于命令和对象</h2><ul>
<li>许多改变文本的命令都是由一个操作和一个对象构成：例如<code>d</code>表示delete，<code>w</code>表示<code>word</code>。</li>
<li>在命令前加数字可以表示该命令重复的次数，例如<code>2dw</code>表示执行两次<code>dw</code>。</li>
</ul>
<h2 id="2-4-撤销类命令"><a href="#2-4-撤销类命令" class="headerlink" title="2.4 撤销类命令"></a>2.4 撤销类命令</h2><ul>
<li>u 撤销最后执行的命令</li>
<li>U 撤销对整行的修改</li>
</ul>
<h1 id="3-剪贴和修改"><a href="#3-剪贴和修改" class="headerlink" title="3 剪贴和修改"></a>3 剪贴和修改</h1><h2 id="3-1-剪贴"><a href="#3-1-剪贴" class="headerlink" title="3.1 剪贴"></a>3.1 剪贴</h2><ul>
<li>dd 剪切整行</li>
<li>p 粘贴</li>
</ul>
<h2 id="3-2-修改"><a href="#3-2-修改" class="headerlink" title="3.2 修改"></a>3.2 修改</h2><ul>
<li>r 替换光标所在位置的字符</li>
<li>cw 修改至单词末尾的文本</li>
<li>ce 同上</li>
<li>c$ 修改至行末的文本</li>
</ul>
<h1 id="4-定位、搜索和替换"><a href="#4-定位、搜索和替换" class="headerlink" title="4 定位、搜索和替换"></a>4 定位、搜索和替换</h1><h2 id="4-1-定位及文件状态"><a href="#4-1-定位及文件状态" class="headerlink" title="4.1 定位及文件状态"></a>4.1 定位及文件状态</h2><ul>
<li>&lt;ctrl&gt;+g&#x2F;G 显示当前编辑的文件名和光标所在位置</li>
<li>G 跳转到文件最后一行</li>
<li>gg 跳转到文件第一行</li>
<li>#n G 跳转到第n行</li>
</ul>
<h2 id="4-2-搜索"><a href="#4-2-搜索" class="headerlink" title="4.2 搜索"></a>4.2 搜索</h2><ul>
<li>&#x2F;[target] 从前往后找</li>
<li>?[target] 从后往前找</li>
<li>n 下一个</li>
<li>N 上一个</li>
<li>% 将光标放在括号处，查找匹配的另一半括号</li>
</ul>
<h2 id="4-3-替换"><a href="#4-3-替换" class="headerlink" title="4.3 替换"></a>4.3 替换</h2><ul>
<li>:s&#x2F;[old]&#x2F;[new] 只替换第一个匹配到的串</li>
<li>:s&#x2F;[old]&#x2F;[new]&#x2F;g 替换全行的匹配串</li>
<li>:#,#s&#x2F;[old]&#x2F;[new]&#x2F;g 替换指定两行之间出现的每个匹配串，其中#,#代表的是替换操作的若干行中首尾两行的行号。</li>
<li>:%s&#x2F;[old]&#x2F;[new]&#x2F;g 替换整个文件中的每个匹配串</li>
<li>:%s&#x2F;[old]&#x2F;[new]&#x2F;gc 找到个文件中的每个匹配串，并且对每个匹配串提示是否进行替换</li>
</ul>
<h1 id="5-执行外部命令和保存"><a href="#5-执行外部命令和保存" class="headerlink" title="5 执行外部命令和保存"></a>5 执行外部命令和保存</h1><h2 id="5-1-执行外部命令"><a href="#5-1-执行外部命令" class="headerlink" title="5.1 执行外部命令"></a>5.1 执行外部命令</h2><ul>
<li>:![command] 可以执行外部命令，如<code>:!ls</code></li>
</ul>
<h2 id="5-2-保存和导入"><a href="#5-2-保存和导入" class="headerlink" title="5.2 保存和导入"></a>5.2 保存和导入</h2><ul>
<li>:w [filename] 保存文件</li>
<li>v进入visual模式，移动光标可以高亮部分文本，<code>:w [filename]</code>选择性保存文件</li>
<li>:r [filename] 导入指定文件</li>
</ul>
<h1 id="6-更多的编辑命令"><a href="#6-更多的编辑命令" class="headerlink" title="6 更多的编辑命令"></a>6 更多的编辑命令</h1><h2 id="6-1-插入"><a href="#6-1-插入" class="headerlink" title="6.1 插入"></a>6.1 插入</h2><ul>
<li>o 在光标的下方打开新的一行，并进入插入模式</li>
<li>R 可连续替换多个字符</li>
</ul>
<h2 id="6-2-复制"><a href="#6-2-复制" class="headerlink" title="6.2 复制"></a>6.2 复制</h2><ul>
<li>y 复制文本，使用这条命令要先用v进入visual模式，然后按y选中部分文本，最后按p粘贴文本</li>
</ul>
<h2 id="6-3-设置类命令"><a href="#6-3-设置类命令" class="headerlink" title="6.3 设置类命令"></a>6.3 设置类命令</h2><ul>
<li>:set ic 忽略搜索target的大小写</li>
<li>:set hls is 高亮搜索，输入的同时显示效果</li>
<li>:set noic 禁用忽略大小写</li>
<li>:nohlsearch 移除匹配项的高亮显示</li>
<li>&#x2F;[target]\c 仅在一次查找时忽略大小写</li>
</ul>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Vim</tag>
      </tags>
  </entry>
</search>
