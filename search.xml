<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hexo + NexT 搭建个人博客</title>
    <url>/2022/63969/</url>
    <content><![CDATA[<h1 id="1-主要安装步骤"><a href="#1-主要安装步骤" class="headerlink" title="1 主要安装步骤"></a>1 主要安装步骤</h1><h2 id="1-1-创建github仓库"><a href="#1-1-创建github仓库" class="headerlink" title="1.1 创建github仓库"></a>1.1 创建github仓库</h2><p>仓库命名：[username].github.io</p>
<h2 id="1-2-安装博客框架Hexo"><a href="#1-2-安装博客框架Hexo" class="headerlink" title="1.2 安装博客框架Hexo"></a>1.2 安装博客框架Hexo</h2><p><a href="https://hexo.io/zh-cn/docs/">Hexo安装文档</a>。在站点配置文件中，deploy字段修改为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: git@github.com:[username]/[username].github.io.git</span><br><span class="line">  branch: main</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>url字段修改为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://[username].github.io</span><br></pre></td></tr></table></figure>

<p>根据需要修改博客信息：author，title，subtitle等字段。</p>
<h2 id="1-3-下载博客主题NexT"><a href="#1-3-下载博客主题NexT" class="headerlink" title="1.3 下载博客主题NexT"></a>1.3 下载博客主题NexT</h2><p><a href="https://github.com/theme-next/hexo-theme-next">NexT安装</a><br>下载完成后，打开站点配置文件，找到theme字段，并将其值更改为next。在官方文档里有对使用NexT的教程，虽然这个教程似乎很久没更新过，但是基本步骤还是差不多的。</p>
<p>完成以上步骤后，<code>hexo cl &amp;&amp; hexo g &amp;&amp; hexo s</code>三连生成页面并在本地预览，<code>hexo d</code>将页面发布到[username].github.io.</p>
<h1 id="2-功能配置"><a href="#2-功能配置" class="headerlink" title="2 功能配置"></a>2 功能配置</h1><p>以下为可选功能，不是必须。</p>
<h2 id="2-1-评论功能"><a href="#2-1-评论功能" class="headerlink" title="2.1 评论功能"></a>2.1 评论功能</h2><p>gitment似乎不能用了，但是好在NexT已经支持gitalk，问题不大。教程详见<a href="https://hexo-next.readthedocs.io/zh_CN/latest/next/advanced/gitalk-%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F/">gitalk评论系统</a>。</p>
<h2 id="2-2-站内搜索功能"><a href="#2-2-站内搜索功能" class="headerlink" title="2.2 站内搜索功能"></a>2.2 站内搜索功能</h2><p>详见<a href="https://theme-next.iissnan.com/third-party-services.html#search-system">第三方服务集成</a>中Local Search部分。</p>
<h2 id="2-3-数学公式"><a href="#2-3-数学公式" class="headerlink" title="2.3 数学公式"></a>2.3 数学公式</h2><p><a href="https://blog.csdn.net/ssjdoudou/article/details/103318019">Hexo-next主题支持数学公式</a></p>
<h2 id="2-4-版权信息"><a href="#2-4-版权信息" class="headerlink" title="2.4 版权信息"></a>2.4 版权信息</h2><p>在<code>主题配置文件</code>中修改：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">creative_commons:</span><br><span class="line">  license: by-nc-sa</span><br><span class="line">  sidebar: false</span><br><span class="line">  post: true</span><br></pre></td></tr></table></figure>

<h2 id="2-5-永久链接"><a href="#2-5-永久链接" class="headerlink" title="2.5 永久链接"></a>2.5 永久链接</h2><p><a href="https://www.jianshu.com/p/c7de2ae59975">Hexo-abbrlink生成唯一永久文章链接</a>。但是按照这个教程修改站点配置文件的permalink字段好像没用，我按下面修改是有用的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">permalink: :year/:abbrlink/</span><br></pre></td></tr></table></figure>

<h2 id="2-6-统计信息"><a href="#2-6-统计信息" class="headerlink" title="2.6 统计信息"></a>2.6 统计信息</h2><p>我用的是不蒜子，优势是不需要注册，提供博客阅读量和访问人数数据。在主题配置文件里找到busuanzi字段，直接修改即可。</p>
<h2 id="2-7-搜索引擎抓取"><a href="#2-7-搜索引擎抓取" class="headerlink" title="2.7 搜索引擎抓取"></a>2.7 搜索引擎抓取</h2><p>可以参考这篇<a href="https://blog.csdn.net/fzhhsa/article/details/89839885">hexo个人博客收录谷歌</a>。</p>
]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>NexT</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker新手笔记</title>
    <url>/2022/64510/</url>
    <content><![CDATA[<p>参考资料：</p>
<ul>
<li>官方文档：<a href="https://docs.docker.com/">https://docs.docker.com/</a></li>
<li>Docker新手课程：<a href="https://kodekloud.com/courses/docker-for-the-absolute-beginner/">https://kodekloud.com/courses/docker-for-the-absolute-beginner/</a></li>
<li>其他参考来源：<ul>
<li><a href="https://baike.baidu.com/item/hypervisor/3353492?fr=aladdin#2_4">百度百科：hypervisor</a></li>
<li><a href="https://blog.csdn.net/qunyaoaiziji/article/details/106222328">容器 &amp; Docker &amp; Docker镜像 &amp; Docker容器的关系和区别</a></li>
<li><a href="https://blog.csdn.net/qq_47042899/article/details/122329491">docker运行容器命令中-it是什么意思</a></li>
<li><a href="https://www.runoob.com/docker/docker-dockerfile.html">Docker Dockerfile</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU0NDc4NjA0MQ==&mid=2247485082&idx=1&sn=9408123ececeed9ab56893546cda31ee&chksm=fb77958ccc001c9aadcf4f32093e4449a0bef95650b6a54f634932eca795097dde59d2879062&token=399001106&lang=zh_CN&scene=21#wechat_redirect">Docker Compose</a><span id="more"></span></li>
</ul>
</li>
</ul>
<h1 id="0-Get-Docker"><a href="#0-Get-Docker" class="headerlink" title="0 Get Docker"></a>0 Get Docker</h1><p>见官方文档：<a href="https://docs.docker.com/get-docker/">https://docs.docker.com/get-docker/</a></p>
<h1 id="1-Overview"><a href="#1-Overview" class="headerlink" title="1 Overview"></a>1 Overview</h1><ul>
<li>Virtual machine vs. Container：Hypervisor（又称虚拟机监视器，Virtual Machine Monitor，VMM），一种运行在基础物理服务器和操作系统之间的中间软件层（如VirutalBox，VMware vSphere等），可以用于模拟计算机硬件（如声卡、网卡）。虚拟机基于Hypervisor实现了在一台计算机的硬件上运行看起来多台独立的计算机。每个虚拟机可以安装其独立的操作系统镜像（“镜像”可以理解为一个复制品，一个软件安装包）。操作系统在硬件和应用程序之间构建起桥梁，提供应用程序所需的运行环境（如提供磁盘读写等系统调用）。容器与操作系统类似，也可以为应用程序提供所需的运行环境。不同的是，容器直接运行在操作系统之上、不依赖于特定的运行环境，它直接利用宿主机的内核，更加轻量化，启动速度快，更加容易迁移服务，实现了容器化应用与操作系统的隔离。</li>
</ul>
<p><img data-src="/../images/docker/vm_container.jpg"></p>
<ul>
<li>Docker：docker是一种基于容器技术开发的工具&#x2F;软件，docker可以像打包应用程序一样打包运行应用程序所需的环境，这种操作极大地节省了应用部署成本、提高了开发效率。</li>
<li>Docker images：docker image是包含了运行应用程序所需的各种资源和依赖环境，是静态的，像一个软件安装包。一个Docker image可以基于另一个Docker image，在此基础上添加一些额外内容。例如，可以在ubuntu image的基础上，安装Apache web服务器和应用程序，以及运行应用程序所需的配置信息。为了构建image，需要通过Dockerfile定义构建image的步骤。Dockerfile中的每个指令都会在image中创建一个层。当更改Dockerfile并重建图像时，仅重建已更改的层（因此Docker image使用起来显得轻便快捷）。</li>
<li>Docker container：docker container和docker image都是docker系统的一部分。docker container是docker image的可运行实例，提供了软件所需的运行环境，可以看作一个特殊的进程。运行container时，在image层上面增加了一个读写层，可以对运行的container做一些更改，但这些更改不会对image产生影响，关闭或删除container后，这些更改也不会保存</li>
<li>Docker daemon：Docker daemon和Docker container都运行在宿主机上。Docker daemon (<code>dockerd</code>) 监听Docker API请求并管理Docker objects，如images，containers，networks等。Docker daemon还可以与其他daemon通信以管理Docker services</li>
<li>Docker client：Docker client (<code>docker</code>) 是dokcer用户与Docker交互的主要方式。当使用<code>docker run</code>等命令时，client将这些命令发送到<code>dockerd</code>，由<code>dockerd</code>执行命令。client可以与多个Docker daemon通信。</li>
<li>Docker registry：保存docker image的仓库，特别地，DockerHub是由Docker官方维护的一个公共仓库，包含了大量的可以用来下载和构建container的image<ul>
<li>类似<code>git</code>命令，通过<code>docker pull</code>等命令，可以从配置仓库中拉取所需image，使用<code>docker push</code>命令，可以将docker image推送到配置仓库中</li>
</ul>
</li>
<li>Docker API：基于Docker API，可以将docker视为一种网络资源，用程序化的方式对docker进行操作<ul>
<li>Docker Registry API：操作docker镜像仓库的API</li>
<li>Docker Hub API：管理用户docker镜像的API</li>
<li>Docker Remote API：用于控制宿主机docker服务的API，等价于docker命令行客户端</li>
</ul>
</li>
</ul>
<p><img data-src="/../images/docker/architecture.png"></p>
<h1 id="2-Commands"><a href="#2-Commands" class="headerlink" title="2 Commands"></a>2 Commands</h1><h2 id="2-1-获取信息"><a href="#2-1-获取信息" class="headerlink" title="2.1 获取信息"></a>2.1 获取信息</h2><ul>
<li><code>docker info</code>：获取docker系统信息，包括docker版本，containers和images的数量等</li>
<li><code>docker version</code>：获取docker版本信息</li>
<li><code>docker COMMAND --help</code>：获取某条命令的帮助信息</li>
<li><code>docker images</code>：列出宿主机拥有的所有images</li>
<li><code>docker inspect NAME|ID</code>：输出docker对象的元数据</li>
<li><code>docker logs CONTAINER</code>：获取container的日志</li>
<li><code>docker ps</code>：列出正在运行的container<ul>
<li><code>docker ps -a</code>：列出所有container，包括未运行的container</li>
</ul>
</li>
</ul>
<h2 id="2-2-容器命令"><a href="#2-2-容器命令" class="headerlink" title="2.2 容器命令"></a>2.2 容器命令</h2><ul>
<li><code>docker run IMAGE</code>：开始一个container，该container基于指定的image<ul>
<li><code>docker run IMAGE[:TAG]</code>：指定image版本，例如<code>docker run redis:4.0</code></li>
<li><code>--name [NAME]</code>：指定container的名称</li>
<li><code>--detach, -d</code>：在后台运行container</li>
<li><code>--interactive, -i</code>：以交互模式运行container（即使docker在后台运行）。只输入<code>-i</code>可以执行命令，但是无法出现命令行界面</li>
<li><code>--tty, -t</code>：为container重新分配一个伪输入终端。只输入<code>-t</code>会出现一个可以输入命令行界面，但是无法交互、不会执行命令</li>
<li><code>--publish, -p &lt;HOSTPORT&gt;:&lt;CONTAINERPORT&gt;</code>：e.g., <code>docker run -p 8080:80</code>，将container的80端口映射到宿主机的8080端口</li>
<li><code>--publish-all, -P</code>：随机映射container的暴露端口到宿主机的端口</li>
<li><code>--volume, -v</code>：e.g., <code>docker run -v host_dir:container_dir</code>，将宿主机目录挂到container中，如果不存在该目录将自动创建。挂载后，在宿主机里放文件，通过container对应的目录就能看到该文件</li>
<li><code>--env, -e</code>：设置环境变量，然后docker里可以使用这个变量（比如通过代码获取该变量的值）</li>
<li><code>--link &lt;NAME|ID&gt;:alias</code>：添加访问另一个container的link，<code>NAME|ID</code>为被访问container的名称或id，<code>alias</code>为被访问container在当前container中的别名</li>
<li><code>--network</code>：指定container使用的网络配置。当docker启动时，会创建名为<code>docker0</code>的虚拟网桥，相当于一个交换机，在该宿主机上启动的docker container都会连接到该虚拟网桥<ul>
<li><code>--network=bridge</code>：默认网络模式，当container启动时，会分配一个与docker0同子网的IP，并且docker0是该container的默认网关。container与外界通信时，docker进程会根据收到消息的宿主机端口与container端口的映射关系，向指定的container端口转发消息</li>
<li><code>--network=host</code>：container与宿主机使用同一网络命令空间，避免NAT。在此模式下，container可以直接使用宿主机的IP与外界进行通信，并且container内服务的端口地址也能直接使用宿主机的端口</li>
<li><code>--network=none</code>：不为container配置网络，此时container无法与外界联网</li>
<li><code>--network=container:&lt;name|id&gt;</code>：与一个已经存在的container共享网络</li>
<li><code>--network=&lt;network-name&gt;|&lt;network-id&gt;</code>：连接到自定义网络</li>
</ul>
</li>
</ul>
</li>
<li><code>docker network</code>：配置网络</li>
<li><code>docker attach CONTAINER</code>：将container恢复在前台运行</li>
<li><code>docker stop CONTAINER</code>：停止一个container</li>
<li><code>docker rm CONTAINER</code>：删除一个container实例</li>
<li><code>docker rmi IMAGE</code>：删除所有依赖于此image的container，并删除该image</li>
<li><code>docker exec CONTAINER COMMAND [ARG...]</code>：在一个运行中的container里执行command。例如，<code>docker exec -it d2ca47f84f18 /bin/bash</code>，就是以交互的方式在指定container中启动一个新的bash终端，并以可交互的方式展现该终端。</li>
<li><code>docker build PATH</code>：根据Dockerfile构建image<ul>
<li><code>docker build PATH -t IMAGE:TAG</code>：PATH指定Dockerfile所在的目录，IMAGE指定输出image名，TAG指定标签</li>
</ul>
</li>
<li><code>docker volume</code>：与通过<code>docker run</code>中的<code>--volume</code>参数直接指定主机目录的不同之处在于，<code>volume</code>在Docker文件目录（<code>/var/lib/docker/volumes</code>）下创建（例如<code>docker volume test_dir</code>），由Docker来管理，非Docker进程不应该修改这些数据。一个给定的volume可以同时挂载到多个容器中</li>
</ul>
<h1 id="3-Dockerfile"><a href="#3-Dockerfile" class="headerlink" title="3 Dockerfile"></a>3 Dockerfile</h1><p>Dockerfile指定构建image的步骤，其基本格式是<code>INSTRUCTION ARGUMENT</code>。例如，下面的Dockerfile一开始指定了运行的image是<code>Ubuntu</code>，然后在container内更新apt库、安装依赖等。<code>COPY</code>命令把源代码复制到<code>/opt</code>文件夹。最后一行命令用<code>flask</code>命令运行web server。</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> Ubuntu</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get install python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> pip install flask</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> pip install flask-mysql</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> . /opt/source-code</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> FLASK_APP=/opt/source-code/app.py flask run</span></span><br></pre></td></tr></table></figure>

<h2 id="3-1-Dockerfile常用命令"><a href="#3-1-Dockerfile常用命令" class="headerlink" title="3.1 Dockerfile常用命令"></a>3.1 Dockerfile常用命令</h2><p>当以下命令与<code>docker run ...</code>中通过<strong>可选参数</strong>指定的命令矛盾时，可选参数的优先级更高。</p>
<ul>
<li><code>FROM</code>：指定基础image，后续操作基于该image执行</li>
<li><code>MAINTAINER &lt;NAME&gt;</code>：写入关于镜像制作者的信息，e.g., <code>MAINTAINER aaa aaa@163.com</code></li>
<li><code>RUN</code>：构建image时运行的shell命令。有两种格式：<code>RUN &lt;COMMAND&gt;</code>和<code>RUN [&quot;EXECFILE&quot;, &quot;ARG1&quot;, &quot;ARG2&quot;]</code>。例如<code>RUN ls</code>，<code>RUN [&quot;./test.php&quot;, &quot;dev&quot;, &quot;offline&quot;]</code>。Dockerfile中的每条指令都会在image上新建一层，可以通过<code>&amp;&amp;</code>合并命令以减少层数。</li>
<li><code>ADD &lt;SRC&gt; &lt;DST&gt;</code>：将本地文件添加到容器中</li>
<li><code>CMD</code>：指定启动container时执行的命令，在Dockerfile中只能存在一个，如果使用多个CMD，则以最后一个CMD指令为准。当出现<code>ENTRYPOINT</code>指令时，<code>CMD</code>中定义的内容会作为<code>ENTRYPOINT</code>的默认参数，即可以通过<code>CMD</code>给<code>ENTRYPOINT</code>传递参数。<code>CMD</code>中指定的程序可以被<code>docker run</code>命令行参数中指定要运行的程序所覆盖。 <ul>
<li><code>CMD [&quot;&lt;executable&gt;&quot;,&quot;&lt;param1&gt;&quot;,&quot;&lt;param2&gt;&quot;,...]</code></li>
<li><code>CMD [&quot;&lt;param1&gt;&quot;,&quot;&lt;param2&gt;&quot;,...]</code>，该写法是为<code>ENTRYPOINT</code>指令指定的程序提供默认参数</li>
</ul>
</li>
<li><code>ENTRYPOINT</code>：类似<code>CMD</code>指定image运行时的命令，如果存在多个<code>ENTRYPOINT</code>，则以最后一个为准。<strong>不同的是</strong>，<code>ENTRYPOINT</code>不会被<code>docker run</code>指定的命令所覆盖，而且<code>docker run</code>指定的命令行参数会被当做参数传给<code>ENTRYPOINT</code>指令指定的程序（但是如果<code>docker run</code>通过<code>--entrypoint</code>指定了命令，则以<code>--entrypoint</code>指定的命令为准）<ul>
<li><code>ENTRYPOINT [&quot;&lt;executeable&gt;&quot;,&quot;&lt;param1&gt;&quot;,&quot;&lt;param2&gt;&quot;,...]</code></li>
<li>可以搭配<code>CMD</code>命令使用：一般是变参才会使用<code>CMD</code>：<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> nginx</span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;nginx&quot;</span>, <span class="string">&quot;-c&quot;</span>]</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;/etc/nginx/nginx.conf&quot;</span>]</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><code>ENV</code>：设置环境变量，在后续的指令中可以使用这个变量<ul>
<li><code>ENV KEY VALUE</code></li>
<li><code>ENV KEY1=VALUE1 KEY2=VALUE2</code></li>
</ul>
</li>
<li><code>ARG</code>：设置环境变量。与<code>ENV</code>的不同之处在于，<code>ARG</code>设置的变量仅在<code>Dockerfile</code>中有效，即只在<code>docker build</code>的过程中有效，构建好的image内不存在此环境变量<ul>
<li><code>ARG &lt;NAME&gt;[=&lt;DEFAULT VALUE&gt;]</code></li>
</ul>
</li>
<li><code>VOLUME</code>：定义匿名数据卷。在启动容器时忘记挂载数据卷会自动挂载到匿名卷，避免丢失重要数据<ul>
<li><code>VOLUME &lt;PATH&gt;</code></li>
</ul>
</li>
<li><code>USER</code>：指定运行container时的用户和用户组，默认是root，后续的RUN也会使用指定用户</li>
<li><code>EXPOSE</code>：暴露container端口。再通过<code>docker run</code>的<code>-p</code>参数，暴露的端口可以被映射到宿主机的某个端口，因此可以通过宿主机IP和端口去访问容器对应的服务</li>
<li><code>WORKDIR</code>：指定工作目录，会作为构建image时每一层的当前目录，如果不存在就创建该目录</li>
<li><code>ONBUILD</code>：指定延迟执行的命令，即通过<code>ONBUILD</code>指定的命令，不会在构建当前image时执行。只有在以当前image为基础image，去构建下一级image时才会执行</li>
</ul>
<h1 id="4-Docker-compose"><a href="#4-Docker-compose" class="headerlink" title="4 Docker compose"></a>4 Docker compose</h1><p>当涉及到的container和image过多时，逐个敲docker commands和Dockerfile会很麻烦。为了解决该问题，可以使用docker-compose。  <strong>docker-compose是用于定义和运行Docker应用程序的工具</strong>。通过该工具，可以使用yml文件来配置应用程序所需的所有服务。然后只需一个命令，就可以基于yml文件创建并启动所有服务。Docker compose使用的三个步骤：</p>
<ul>
<li>使用<code>Dockerfile</code>指定构建应用程序image的步骤</li>
<li>使用<code>docker-compose.yml</code>定义构成应用程序的服务，使得它们可以在隔离环境中一起运行</li>
<li>最后，执行<code>docker-compose up</code>命令来启动并运行整个应用程序。当需要停止服务时，就执行<code>docker-compose down</code></li>
</ul>
<p>以下代码来自：<a href="https://mp.weixin.qq.com/s?__biz=MzU0NDc4NjA0MQ==&mid=2247485082&idx=1&sn=9408123ececeed9ab56893546cda31ee&chksm=fb77958ccc001c9aadcf4f32093e4449a0bef95650b6a54f634932eca795097dde59d2879062&token=399001106&lang=zh_CN&scene=21#wechat_redirect">Docker Compose</a>。通过阅读这些代码，可以发现docker-compose实际上可以看作是使用更加方便的docker commands</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3.0&#x27;</span>  <span class="comment"># 指定docker-compose的版本，一般是3.0</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span>                         <span class="comment"># 定义网络</span></span><br><span class="line">  <span class="attr">docker-compose-demo-net:</span>        <span class="comment"># 自定义网络名称</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">bridge</span>                <span class="comment"># 网络模式</span></span><br><span class="line">    <span class="attr">ipam:</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">subnet:</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.0</span><span class="string">/24</span>  <span class="comment"># 可以使用ipv4/ipv6地址</span></span><br><span class="line">          <span class="attr">gateway:</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.1</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">docker-compose-demo01:</span></span><br><span class="line">    <span class="attr">build:</span></span><br><span class="line">      <span class="attr">context:</span> <span class="string">/usr/local/docker-compose-demo</span>  <span class="comment"># 构建应用的地址</span></span><br><span class="line">      <span class="attr">dockerfile:</span> <span class="string">Dockerfile</span>  <span class="comment"># Dockerfile的路径</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">docker-compose-demo</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">docker-compose-demo01</span></span><br><span class="line">    <span class="attr">networks:</span>        <span class="comment">#选择网络</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">docker-compose-demo-net</span></span><br><span class="line">    <span class="attr">ports:</span>           <span class="comment">#选择端口                  </span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">8081</span><span class="string">:8080/tcp</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span>  <span class="comment"># 重启策略</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">docker-compose-demo02:</span></span><br><span class="line">    <span class="attr">build:</span></span><br><span class="line">      <span class="attr">context:</span> <span class="string">/usr/local/docker-compose-demo</span></span><br><span class="line">      <span class="attr">dockerfile:</span> <span class="string">Dockerfile</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">docker-compose-demo</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">docker-compose-demo02</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">docker-compose-demo-net</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">8082</span><span class="string">:8080/tcp</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">nginx:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:latest</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">nginx-demo</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">docker-compose-demo-net</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">80</span><span class="string">:80/tcp</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/usr/local/docker-compose-demo/nginx.conf:/etc/nginx/nginx.conf:rw</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="attr">docker-compose-demo-volume:</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<h1 id="5-Docker-swarm"><a href="#5-Docker-swarm" class="headerlink" title="5 Docker swarm"></a>5 Docker swarm</h1><p>…</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>gdb初学笔记</title>
    <url>/2022/56307/</url>
    <content><![CDATA[<blockquote>
<p>读书时学过怎么用gdb，但是因为不常用很快忘光了。由于某些环境下只能用gdb调试，所以现在再次学习总结一下gdb。</p>
</blockquote>
<span id="more"></span>
<h1 id="0-gcc编译命令"><a href="#0-gcc编译命令" class="headerlink" title="0 gcc编译命令"></a>0 gcc编译命令</h1><p>从源代码hello.c到可执行文件hello，需要经过hello.i、hello.s、hello.o，最后才得到hello：</p>
<p><img data-src="/../images/compile/compile.png"></p>
<p>gcc编译命令的格式：<code>gcc [flags] &lt;source files&gt; -o &lt;output file&gt;</code></p>
<ul>
<li>预处理，处理源代码中的预处理命令，包括头文件展开、宏定义替换、条件编译等：<br><code>gcc -E hello.c –o hello.i</code></li>
<li>编译，将预处理得到的文件翻译转换为汇编代码文件：<code>gcc -S hello.i -o hello.s</code></li>
<li>汇编，将汇编代码翻译成机器码得到目标文件：<code>gcc -c hello.s -o hello.o</code></li>
<li>链接，将多个目标文件和所需的库文件链接成可执行文件：<code>gcc hello.o -o hello</code><br>上述编译过程可以简化为：<code>gcc hello.c -o hello</code></li>
</ul>
<h1 id="1-启动gdb"><a href="#1-启动gdb" class="headerlink" title="1 启动gdb"></a>1 启动gdb</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -g hello.c -o hello  # 使用-g编译，生成可执行文件</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动方法1</span></span><br><span class="line">gdb hello</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动方法2</span></span><br><span class="line">gdb</span><br><span class="line">... # 进入调试器</span><br><span class="line">(gdb) file hello</span><br></pre></td></tr></table></figure>

<h1 id="2-使用gdb调试"><a href="#2-使用gdb调试" class="headerlink" title="2 使用gdb调试"></a>2 使用gdb调试</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(gdb) help &lt;command&gt;  # 获取&lt;command&gt;的用法</span><br><span class="line"></span><br><span class="line">(gdb) set args [...]  # 设置main运行参数；后面的参数为空，相当于撤销参数设置</span><br><span class="line"></span><br><span class="line">(gdb) run [...]     # 运行程序，[...]里放置参数（如果为空则用args的参数）。没有断点会运行至出错或者结束</span><br><span class="line">(gdb) start [...]   # 启动程序，[...]里放置参数，在main函数的第一行语句处停止执行</span><br><span class="line"></span><br><span class="line">(gdb) break &lt;location&gt;                 # 打断点，程序运行到断点后暂停运行，e.g.,</span><br><span class="line">(gdb) break 10</span><br><span class="line">(gdb) break hello.c:10</span><br><span class="line">(gdb) break func</span><br><span class="line">(gdb) break hello.c:func</span><br><span class="line"></span><br><span class="line">(gdb) break &lt;location&gt; if &lt;condition&gt;  # 条件断点，只有在条件满足时才在该点break</span><br><span class="line">(gdb) condtion &lt;N&gt; [condition]         # 修改breakpoint N的条件，不指定condition则删除对应的条件</span><br><span class="line"></span><br><span class="line">(gdb) disable breakpoint &lt;N&gt;  # 禁用断点N</span><br><span class="line">(gdb) ignore &lt;N&gt; &lt;COUNT&gt;      # 指定断点N失效的次数</span><br><span class="line">(gdb) enable breakpoint &lt;N&gt;   # 允许断点N</span><br><span class="line">(gdb) delete breakpoint &lt;N&gt;   # 删除断点N</span><br><span class="line">(gdb) delete                  # 删除所有断点</span><br><span class="line"></span><br><span class="line">(gdb) step [N]      # 单步执行，如果遇到函数调用，则进入函数中，N指定执行的代码行数</span><br><span class="line">(gdb) next [N]      # 单步执行，遇到函数执行不进入函数中，N指定执行的代码行数</span><br><span class="line">(gdb) continue [N]  # 继续运行，直到遇到下一个断点。N指定跳过遇到断点的次数</span><br><span class="line">(gdb) finish        # 继续运行直到当前函数执行完成</span><br><span class="line"></span><br><span class="line">(gdb) backtrace [N]  # 输出当前调试环境中所有的栈帧信息，N指定打印最里（正数）或最外（负数）N个栈帧的信息</span><br><span class="line">(gdb) backtrace </span><br><span class="line"></span><br><span class="line">(gdb) frame &lt;N&gt;  # 输出栈帧N的信息</span><br><span class="line"></span><br><span class="line">(gdb) print &lt;EXPRESSION&gt;        # 输出表达式的值</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">e.g.,</span></span><br><span class="line">(gdb) print array[0]@2          # 查看第0，1个元素</span><br><span class="line">(gdb) print file::variable</span><br><span class="line">(gdb) print function::variable</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(gdb) watch &lt;EXPRESSION&gt;   # 监控表达式，一旦变化程序就停止运行</span><br><span class="line">(gdb) rwatch &lt;EXPRESSION&gt;  # 只要读取目标表达式的值，程序就停止运行</span><br><span class="line">(gdb) awatch &lt;EXPRESSION&gt;  # 只要读取目标表达式的值或者改变值的操作，程序就会停止运行</span><br><span class="line">(gdb) watch -l &lt;ADDRESS&gt;   # 监控地址，一旦该地址对应的内存发生变化，程序就停止运行</span><br><span class="line"></span><br><span class="line">(gdb) info breakpoint &lt;N&gt;     # 查看断点N的信息</span><br><span class="line">(gdb) info reg                # 查看寄存器的信息</span><br><span class="line"></span><br><span class="line">(gdb) list &lt;LINENUM&gt;               # 列出指定行数上下十行的代码</span><br><span class="line">(gdb) list &lt;LINENUM1&gt;, &lt;LINENUM2&gt;  # 列出指定行数之间的代码</span><br><span class="line">(gdb) list &lt;FUNCTION&gt;              # 查看特定函数的代码</span><br></pre></td></tr></table></figure>

<h1 id="3-在qemu中使用gdb"><a href="#3-在qemu中使用gdb" class="headerlink" title="3 在qemu中使用gdb"></a>3 在qemu中使用gdb</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># step 1.</span></span><br><span class="line">make qemu-gdb</span><br><span class="line"><span class="comment"># qemu-system-riscv64 -machine virt -bios none -kernel kernel/kernel -m 128M -smp 3 -nographic -drive file=fs.img,if=none,format=raw,id=x0 -device virtio-blk-device,drive=x0,bus=virtio-mmio-bus.0 -S -gdb tcp::26000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># step 2. 根据提示，在另一个shell中运行gdb</span></span><br><span class="line">riscv64-unknown-elf-gdb  <span class="comment"># xv6的ISA是riscv，所以需要指定riscv调试器。如果默认是riscv调试器，直接输 gdb 也可以</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># step 3. 加载可执行文件，e.g.,</span></span><br><span class="line">(gdb) file user/_[execname]</span><br><span class="line">(gdb) file kernel/kernel</span><br><span class="line"></span><br><span class="line"><span class="comment"># step 4. 通过gdb程序的远程调试功能和qemu的远程gdb调试接口来调试程序</span></span><br><span class="line">(gdb) target remote localhost:26000</span><br><span class="line"></span><br><span class="line"><span class="comment"># step 5. 打断点</span></span><br><span class="line">(gdb) b [...]</span><br><span class="line"></span><br><span class="line"><span class="comment"># step 6. 在第一个shell中运行虚拟机</span></span><br><span class="line"><span class="comment"># 第一个shell的虚拟机运行到打了断点的部分时，第二个shell的gdb会输出对应信息。</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>gdb</tag>
      </tags>
  </entry>
  <entry>
    <title>Git初学笔记</title>
    <url>/2022/22760/</url>
    <content><![CDATA[<blockquote>
<p>为了便于日常的查询和使用，将一些git命令总结这篇博客中。</p>
</blockquote>
<p>参考资料：</p>
<ul>
<li>用可视化的方法学习git：<a href="https://learngitbranching.js.org/?locale=zh_CN">https://learngitbranching.js.org/?locale=zh_CN</a></li>
<li>官方文档：<a href="https://git-scm.com/docs/gittutorial">https://git-scm.com/docs/gittutorial</a></li>
</ul>
<span id="more"></span>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">branch可以指代当前分支的最新commit</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">commit^ 表示某个commit的父节点</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">~n表示当前节点的n代父母节点</span></span><br><span class="line"></span><br><span class="line">git help &lt;command&gt;                 # 获取关于某个命令的帮助</span><br><span class="line">git status                         # 输出当前分支的信息</span><br><span class="line">git log                            # 显示git的历史纪录</span><br><span class="line">git diff &lt;file&gt;                    # 输出当前文件与暂存区中文件的区别</span><br><span class="line"></span><br><span class="line">git init                           # 将当前文件夹创建为git repo</span><br><span class="line">git add &lt;file&gt;                     # 将文件添加到暂存区</span><br><span class="line">git commit -m &lt;msg&gt;                # 提交当前分支至remote repo，只有在暂存区中的文件才会被commit</span><br><span class="line">git branch &lt;branch&gt;                # 创建新分支</span><br><span class="line">git branch -f &lt;branch&gt; &lt;commit&gt;    # 将某个分支强制移动到指定的commit节点</span><br><span class="line"></span><br><span class="line">git checkout &lt;branch&gt;              # 切换当前分支</span><br><span class="line">git checkout -b &lt;branch&gt;           # 切换当前分支，若分支不存在则创建</span><br><span class="line"></span><br><span class="line">git reset HEAD^                    # 所有内容回退到HEAD的父节点</span><br><span class="line">git reset HEAD^ &lt;filename&gt;         # 将某个文件回退到HEAD的父节点版本</span><br><span class="line">git reset &lt;commit&gt;                 # 所有内容回退到指定的commit节点</span><br><span class="line"></span><br><span class="line">git revert &lt;commit&gt;                # 撤销指定的commit</span><br><span class="line"></span><br><span class="line">git merge &lt;branch&gt;                 # 将指定分支与当前分支合并，产生一个新的commit节点</span><br><span class="line">git cherry-pick &lt;commit&gt;...        # 将指定commit节点复制到当前分支下</span><br><span class="line">git rebase -i &lt;commit&gt;             # 打开交互页面，显示哪些commit节点会放到指定commit节点下</span><br><span class="line"></span><br><span class="line">git tag &lt;tagname&gt; &lt;commit&gt;         # 在指定commit节点创建tag，可以使用tag指代commit</span><br><span class="line">git describe                       # 返回当前节点的最近tag、距离和节点hash</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">local</span> repo有个“remote repo”，用于描述remote repo的情况（上次同步后的状态，不一定是最新的）</span></span><br><span class="line">git fetch &lt;remote&gt;                 # 更新remote repo的所有分支</span><br><span class="line">git fetch &lt;remote&gt; &lt;branch&gt;        # 更新remote repo的指定分支</span><br><span class="line"></span><br><span class="line">git pull &lt;remote&gt;                  # 获取remote repo中与当前分支对应的分支，并与当前分支合并，等价于：</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">git fetch &lt;remote&gt;</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">git merge origin/&lt;current-branch&gt;</span></span><br><span class="line">git pull &lt;remote&gt; &lt;branch&gt;</span><br><span class="line"></span><br><span class="line">git push &lt;remote&gt; &lt;src-local-branch&gt;:&lt;dst-remote-branch&gt;       # 将本地分支推送到远程</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果不指明src，则是删除对应的remote-branch</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果不指明dst，则是更新到remote repo对应的分支</span></span><br><span class="line"></span><br><span class="line">git fetch &lt;remote&gt; &lt;src-local-branch&gt;:&lt;dst-remote-branch&gt;      # 将远程分支拉取到本地</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果不指明src，则是在<span class="built_in">local</span> repo增加对应的分支</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果不指明dst，则是拉取到<span class="built_in">local</span> repo对应的分支</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>makefile初学笔记</title>
    <url>/2022/60804/</url>
    <content><![CDATA[<p>参考资料：</p>
<ul>
<li><a href="https://makefiletutorial.com/#static-pattern-rules">https://makefiletutorial.com/#static-pattern-rules</a></li>
<li><a href="https://blog.csdn.net/oqqHuTu12345678/article/details/125617988">https://blog.csdn.net/oqqHuTu12345678/article/details/125617988</a><span id="more"></span></li>
</ul>
<h1 id="1-Basic-Rules"><a href="#1-Basic-Rules" class="headerlink" title="1 Basic Rules"></a>1 Basic Rules</h1><p>一个makefile由多条规则组成，每条规则一般像这样：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">targets: prerequisites</span></span><br><span class="line">	command</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line"><span class="comment"># e.g.,</span></span><br><span class="line"><span class="section">blah: blah.c</span></span><br><span class="line">	cc blah.c -o blah</span><br></pre></td></tr></table></figure>

<p>当运行<code>make</code>时，会先找到第一个target，然后判断是否需要重新运行command以重新生成targets。只有当targets不存在，或者prerequisites有更新才会重新运行。Make的逻辑是：先找到第一个target，看这个target的prerequisites是否满足；如果不满足，就会在makefile中查找生成prerequisites的rule，递归执行直到某个rule的prerequisites已经满足，就开始执行command。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">blah: blah.o</span></span><br><span class="line">	cc blah.o -o blah <span class="comment"># Runs third</span></span><br><span class="line"></span><br><span class="line"><span class="section">blah.o: blah.c</span></span><br><span class="line">	cc -c blah.c -o blah.o <span class="comment"># Runs second</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Typically blah.c would already exist, but I want to limit any additional required files</span></span><br><span class="line"><span class="section">blah.c:</span></span><br><span class="line">	echo <span class="string">&quot;int main() &#123; return 0; &#125;&quot;</span> &gt; blah.c <span class="comment"># Runs first</span></span><br></pre></td></tr></table></figure>
<p><code>make</code>命令可以配合可选项实现多种选择，例如，<code>-f</code>指定makefile文件，<code>-I</code>指定include路径，指定<code>targets</code>为<code>cleam</code>清除数据（即<code>make clean</code>）：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">some_file: </span></span><br><span class="line">	touch some_file</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -f some_file</span><br></pre></td></tr></table></figure>

<h1 id="2-Variables"><a href="#2-Variables" class="headerlink" title="2 Variables"></a>2 Variables</h1><ul>
<li>通过<code>:=</code>、<code>=</code>或者<code>?=</code>定义变量：<ul>
<li><code>=</code>，以递归的形式展开变量，即赋值的变量只有在被引用&#x2F;使用时才会展开，即延迟展开（不常用）</li>
<li><code>:=</code>，直接展开式赋值</li>
<li><code>?=</code>，使用<code>?=</code>赋值时，只有变量未被赋值过时才有效</li>
</ul>
</li>
<li><code>+=</code>：append</li>
<li>对于Make来说，所有的变量都是string，单引号或者双引号是没有意义的</li>
<li>通过<code>$(VAR)</code>或<code>$&#123;VAR&#125;</code>使用变量<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">files := file1 file2</span><br><span class="line"><span class="section">some_file: <span class="variable">$(files)</span></span></span><br><span class="line">	echo <span class="string">&quot;Look at this variable: &quot;</span> <span class="variable">$(files)</span></span><br><span class="line">	touch some_file</span><br><span class="line"></span><br><span class="line"><span class="section">file1:</span></span><br><span class="line">	touch file1</span><br><span class="line"><span class="section">file2:</span></span><br><span class="line">	touch file2</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -f file1 file2 some_file</span><br></pre></td></tr></table></figure></li>
<li>可以给指定target设置变量，从而其他的target都无法使用：<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">all: one = cool</span></span><br><span class="line"></span><br><span class="line"><span class="section">all: </span></span><br><span class="line">	echo one is defined: <span class="variable">$(one)</span></span><br><span class="line"></span><br><span class="line"><span class="section">other:</span></span><br><span class="line">	echo one is nothing: <span class="variable">$(one)</span></span><br></pre></td></tr></table></figure></li>
<li>也可以给符号特定pattern的target赋变量：<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">%.c: one = cool</span></span><br><span class="line"></span><br><span class="line"><span class="section">blah.c: </span></span><br><span class="line">	echo one is defined: <span class="variable">$(one)</span></span><br><span class="line"></span><br><span class="line"><span class="section">other:</span></span><br><span class="line">	echo one is nothing: <span class="variable">$(one)</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="3-Targets"><a href="#3-Targets" class="headerlink" title="3 Targets"></a>3 Targets</h1><ul>
<li>通过指定<code>all</code>target，可以使<code>all</code>target的所有prerequisites都被执行，e.g.,<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="section">f1.o:</span></span><br><span class="line">	echo f1.o</span><br><span class="line"><span class="section">f2.o:</span></span><br><span class="line">    echo f2.o</span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以合并rules，e.g.,</span></span><br><span class="line"><span class="section">all: f1.o f2.o</span></span><br><span class="line">f1.o f2.o:</span><br><span class="line">	echo <span class="variable">$@</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="3-Automatic-Variables-and-Wildcards"><a href="#3-Automatic-Variables-and-Wildcards" class="headerlink" title="3 Automatic Variables and Wildcards"></a>3 Automatic Variables and Wildcards</h1><ul>
<li><code>*</code>：匹配任意个字符，可用于搜索文件系统中匹配的文件名。注意它在targets和prerequisites中只能在作为变量时起作用，否则就是一个string</li>
<li><code>%</code>：匹配任意个字符，和<code>*</code>的区别在于，<code>*</code>应用在系统中，<code>%</code>应用在这个makefile文件中<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Print out file information about every .c file</span></span><br><span class="line"><span class="section">print: $(wildcard *.c)</span></span><br><span class="line">	ls -la  <span class="variable">$?</span></span><br><span class="line"></span><br><span class="line">thing_wrong := *.o <span class="comment"># Don&#x27;t do this! &#x27;*&#x27; will not get expanded</span></span><br><span class="line">thing_right := <span class="variable">$(<span class="built_in">wildcard</span> *.o)</span></span><br><span class="line"></span><br><span class="line"><span class="section">all: one two three four</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Fails, because $(thing_wrong) is the string &quot;*.o&quot;</span></span><br><span class="line"><span class="section">one: <span class="variable">$(thing_wrong)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Stays as *.o if there are no files that match this pattern :(</span></span><br><span class="line"><span class="section">two: *.o </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Works as you would expect! In this case, it does nothing.</span></span><br><span class="line"><span class="section">three: <span class="variable">$(thing_right)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Same as rule three</span></span><br><span class="line"><span class="section">four: $(wildcard *.o)</span></span><br></pre></td></tr></table></figure></li>
<li><code>$@</code>：表示target name</li>
<li><code>$?</code>：表示比target要新的prerequisites</li>
<li><code>$^</code>：表示所有不重复的rerequisites，以空格分开</li>
<li><code>$&lt;</code>：表示第一个prerequisites</li>
</ul>
<h1 id="4-Implicit-Rules-and-Static-Pattern-Rules"><a href="#4-Implicit-Rules-and-Static-Pattern-Rules" class="headerlink" title="4 Implicit Rules and Static Pattern Rules"></a>4 Implicit Rules and Static Pattern Rules</h1><ul>
<li>这两种规则都可以减少写makefile文件的工作量，但是对应地，makefile文件的可读性会下降<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ======== Implicit Rules ========</span></span><br><span class="line"><span class="comment"># CC: Program for compiling C programs; default cc</span></span><br><span class="line"><span class="comment"># CXX: Program for compiling C++ programs; default g++</span></span><br><span class="line"><span class="comment"># CFLAGS: Extra flags to give to the C compiler</span></span><br><span class="line"><span class="comment"># CXXFLAGS: Extra flags to give to the C++ compiler</span></span><br><span class="line"><span class="comment"># CPPFLAGS: Extra flags to give to the C preprocessor</span></span><br><span class="line"><span class="comment"># LDFLAGS: Extra flags to give to compilers when they are supposed to invoke the linker</span></span><br><span class="line">CC = gcc <span class="comment"># Flag for implicit rules</span></span><br><span class="line">CFLAGS = -g <span class="comment"># Flag for implicit rules. Turn on debug info</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Implicit rule #1: blah is built via the C linker implicit rule</span></span><br><span class="line"><span class="comment"># Implicit rule #2: blah.o is built via the C compilation implicit rule, because blah.c exists</span></span><br><span class="line"><span class="section">blah: blah.o</span></span><br><span class="line"></span><br><span class="line"><span class="section">blah.c:</span></span><br><span class="line">	echo <span class="string">&quot;int main() &#123; return 0; &#125;&quot;</span> &gt; blah.c</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -f blah*</span><br><span class="line"></span><br><span class="line"><span class="comment"># ======== Static Pattern Rules ========</span></span><br><span class="line"><span class="section">targets...: target-pattern: prereq-patterns ...</span></span><br><span class="line">   commands</span><br><span class="line"></span><br><span class="line">objects = foo.o bar.o all.o</span><br><span class="line"><span class="section">all: <span class="variable">$(objects)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment"># These files compile via implicit rules</span></span><br><span class="line"><span class="comment"># Syntax - targets ...: target-pattern: prereq-patterns ...</span></span><br><span class="line"><span class="comment"># In the case of the first target, foo.o, the target-pattern matches foo.o and sets the &quot;stem&quot; to be &quot;foo&quot;.</span></span><br><span class="line"><span class="comment"># It then replaces the &#x27;%&#x27; in prereq-patterns with that stem</span></span><br><span class="line"><span class="variable">$(objects)</span>: %.o: %.c</span><br><span class="line"></span><br><span class="line"><span class="section">all.c:</span></span><br><span class="line">	echo <span class="string">&quot;int main() &#123; return 0; &#125;&quot;</span> &gt; all.c</span><br><span class="line"></span><br><span class="line"><span class="section">%.c:</span></span><br><span class="line">	touch <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -f *.c *.o all</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="5-Commands-and-Exection"><a href="#5-Commands-and-Exection" class="headerlink" title="5 Commands and Exection"></a>5 Commands and Exection</h1><ul>
<li><code>-</code>：command前加<code>-</code>，即使该条命令出错，也不影响后续命令的执行</li>
<li><code>@</code>：在commands开头加上<code>@</code>可以令其不输出内容，e.g.,<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">all: </span></span><br><span class="line">	@echo <span class="string">&quot;This make line will not be printed&quot;</span></span><br><span class="line">	echo <span class="string">&quot;But this will&quot;</span></span><br></pre></td></tr></table></figure></li>
<li><code>$$</code>：command里用<code>$$</code>可以输出<code>$</code>符号，然后在makefile文件里就可以引用shell中的变量，例如：<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">all:</span></span><br><span class="line">	<span class="comment"># Same as running &quot;sh_var=&#x27;I am a shell variable&#x27;; echo $sh_var&quot; in the shell</span></span><br><span class="line">	sh_var=&#x27;I am a shell variable&#x27;; echo $$sh_var</span><br></pre></td></tr></table></figure></li>
<li>通过修改<code>SHELL</code>变量，可以修改默认的shell（默认是<code>/bin/sh</code>）<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">SHELL=/bin/bash</span><br><span class="line"><span class="section">cool:</span></span><br><span class="line">	echo <span class="string">&quot;Hello from bash&quot;</span></span><br></pre></td></tr></table></figure></li>
<li><code>-k</code>：<code>make</code>命令添加可选项<code>-k</code>，使得在遇到错误时仍然能继续执行，即如果某个target出错，依赖这个target的rule都不执行，其它rule执行</li>
<li><code>-i</code>：<code>make</code>命令添加可选项<code>-i</code>，忽略一切命令的出错，执行所有生成规则</li>
<li><code>-s</code>：<code>make</code>命令添加可选项<code>-s</code>，不输出任何内容，相当于在每个command前加<code>@</code></li>
<li><code>export</code>：将某个变量设置为shell变量，e.g.,<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">shell_env_var=Shell env var, created inside of Make</span><br><span class="line"><span class="keyword">export</span> shell_env_var</span><br><span class="line"><span class="section">all:</span></span><br><span class="line">	echo <span class="variable">$(shell_env_var)</span></span><br><span class="line">	echo $$shell_env_var</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="6-Conditional-Makefiles"><a href="#6-Conditional-Makefiles" class="headerlink" title="6 Conditional Makefiles"></a>6 Conditional Makefiles</h1><ul>
<li><p><code>ifeq/else</code>：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">foo = ok</span><br><span class="line"></span><br><span class="line"><span class="section">all:</span></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(foo)</span>, ok)</span><br><span class="line">	echo <span class="string">&quot;foo equals ok&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	echo <span class="string">&quot;nope&quot;</span></span><br><span class="line"><span class="keyword">endif</span> </span><br><span class="line"></span><br><span class="line"><span class="comment"># ======== Check if a variable is empty ========</span></span><br><span class="line">nullstring =</span><br><span class="line">foo = <span class="variable">$(nullstring)</span> <span class="comment"># end of line; there is a space here</span></span><br><span class="line"></span><br><span class="line"><span class="section">all:</span></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(<span class="built_in">strip</span> <span class="variable">$(foo)</span>)</span>,)</span><br><span class="line">	echo <span class="string">&quot;foo is empty after being stripped&quot;</span></span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(nullstring)</span>,)</span><br><span class="line">	echo <span class="string">&quot;nullstring doesn&#x27;t even have spaces&quot;</span></span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>ifdef/ifndef</code>：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">bar =</span><br><span class="line">foo = <span class="variable">$(bar)</span></span><br><span class="line"></span><br><span class="line"><span class="section">all:</span></span><br><span class="line"><span class="keyword">ifdef</span> foo</span><br><span class="line">	echo <span class="string">&quot;foo is defined&quot;</span></span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"><span class="keyword">ifndef</span> bar</span><br><span class="line">	echo <span class="string">&quot;but bar is not&quot;</span></span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ======== $(makeflags)可以用于给make命令添加可选项 ========</span></span><br><span class="line">bar =</span><br><span class="line">foo = <span class="variable">$(bar)</span></span><br><span class="line"></span><br><span class="line"><span class="section">all:</span></span><br><span class="line"><span class="comment"># Search for the &quot;-i&quot; flag. MAKEFLAGS is just a list of single characters, one per flag. So look for &quot;i&quot; in this case.</span></span><br><span class="line"><span class="keyword">ifneq</span> (,<span class="variable">$(<span class="built_in">findstring</span> i, <span class="variable">$(MAKEFLAGS)</span>)</span>)</span><br><span class="line">	echo <span class="string">&quot;i was passed to MAKEFLAGS&quot;</span></span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="7-Functions"><a href="#7-Functions" class="headerlink" title="7 Functions"></a>7 Functions</h1><ul>
<li><code>findstring</code>：<code>$(findstring &lt;find&gt;,&lt;in&gt;)</code></li>
<li><code>subst</code>：<code>$(subst &lt;from&gt;,&lt;to&gt;,&lt;text&gt;)</code>，注意逗号之间不要有空格</li>
<li><code>patsubst</code>：<code>$(patsubst &lt;pattern&gt;,&lt;replacement&gt;,&lt;text&gt;)</code>，注意逗号之间不要有空格</li>
<li><code>strip</code>：<code>$(strip &lt;string&gt;)</code></li>
<li><code>fileter</code>：<code>$(filter &lt;pattern&gt;,&lt;text&gt;)</code></li>
<li><code>foreach</code>：<code>$(foreach &lt;var&gt;,&lt;list&gt;,&lt;text&gt;)</code></li>
<li><code>if</code>：<code>$(if &lt;condition&gt;,&lt;then-part&gt;)或(if&lt;condition&gt;,&lt;then-part&gt;,&lt;else-part&gt;)</code></li>
</ul>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>makefile</tag>
      </tags>
  </entry>
  <entry>
    <title>MIT 6.S081 Lab1 Utilities</title>
    <url>/2022/35075/</url>
    <content><![CDATA[<p>参考资料：</p>
<ul>
<li>课程官方网页：<a href="https://pdos.csail.mit.edu/6.S081/2021/index.html">https://pdos.csail.mit.edu/6.S081/2021/index.html</a></li>
<li>xv6 book：<a href="https://pdos.csail.mit.edu/6.S081/2021/xv6/book-riscv-rev2.pdf">https://pdos.csail.mit.edu/6.S081/2021/xv6/book-riscv-rev2.pdf</a></li>
<li>xv6手册中文版：<a href="http://xv6.dgs.zone/">http://xv6.dgs.zone/</a></li>
<li>参考代码：<a href="http://doraemonzzz.com/tags/6-S081/">http://doraemonzzz.com/tags/6-S081/</a>，以下代码主要参考该工作。<span id="more"></span></li>
</ul>
<h1 id="0-配置实验环境"><a href="#0-配置实验环境" class="headerlink" title="0 配置实验环境"></a>0 配置实验环境</h1><ol>
<li>根据<a href="https://pdos.csail.mit.edu/6.S081/2021/tools.html">Tools Used in 6.S081</a>安装环境。</li>
<li>安装好后，在shell运行<code>make qemu</code>进入qemu环境。</li>
<li>同时按住<code>ctrl+a</code>然后松开这两个键，再按<code>x</code>可以退出qemu环境。</li>
</ol>
<h1 id="1-Boot-xv6-easy"><a href="#1-Boot-xv6-easy" class="headerlink" title="1 Boot xv6 (easy)"></a>1 Boot xv6 (easy)</h1><p>根据实验指示逐步执行即可：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> git://g.csail.mit.edu/xv6-labs-2021</span><br><span class="line">Cloning into <span class="string">&#x27;xv6-labs-2021&#x27;</span>...</span><br><span class="line">...</span><br><span class="line">$ <span class="built_in">cd</span> xv6-labs-2021</span><br><span class="line">$ git checkout util  <span class="comment"># 这里我的默认分支下是空的，需要签出分支后才能看到代码</span></span><br><span class="line">$ make qemu <span class="comment"># 进入qemu环境，并启动xv6系统</span></span><br></pre></td></tr></table></figure>

<h1 id="2-sleep-easy"><a href="#2-sleep-easy" class="headerlink" title="2 sleep (easy)"></a>2 sleep (easy)</h1><p>按照xv6教材和实验指示逐步执行即可。</p>
<h1 id="3-pingpong-easy"><a href="#3-pingpong-easy" class="headerlink" title="3 pingpong (easy)"></a>3 pingpong (easy)</h1><p>这个实验的意思是，child进程通过pipe给parent进程发一个字符，parent进程输出字符。同样的，parent进程也要给child进程发一个字符，child进程输出字符。</p>
<p>要注意的是，父子进程是通过同一个pipe通信的，因此要避免两个进程同时读或者同时写，并且parent必须等child进程结束后才能读，否则可能读到自己写的字符，因此需要先让parent进程写、child进程读，然后反过来：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> p[<span class="number">2</span>];</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">2</span>];</span><br><span class="line">    pipe(p);</span><br><span class="line">    <span class="type">int</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123; <span class="comment">// child</span></span><br><span class="line">        <span class="keyword">if</span> (read(p[<span class="number">0</span>], buf, <span class="number">1</span>) != <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Can&#x27;t read from parent!\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        close(p[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">1</span>, <span class="string">&quot;child receive: %c\n&quot;</span>, buf[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">1</span>, <span class="string">&quot;%d: received ping\n&quot;</span>, getpid());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (write(p[<span class="number">1</span>], <span class="string">&quot;b&quot;</span>, <span class="number">1</span>) != <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Can&#x27;t write to parent!\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        close(p[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;  <span class="comment">// parent</span></span><br><span class="line">        <span class="keyword">if</span> (write(p[<span class="number">1</span>], <span class="string">&quot;a&quot;</span>, <span class="number">1</span>) != <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Can&#x27;t write to child!\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        close(p[<span class="number">1</span>]);  </span><br><span class="line"></span><br><span class="line">        wait(<span class="number">0</span>); <span class="comment">// 如果不等待子进程结束，可能读的是&quot;a&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (read(p[<span class="number">0</span>], buf, <span class="number">1</span>) != <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Can&#x27;t read from child!\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        close(p[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">1</span>, <span class="string">&quot;parent receive: %c\n&quot;</span>, buf[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">1</span>, <span class="string">&quot;%d: received pong\n&quot;</span>, getpid());</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4-primes-moderate-x2F-hard"><a href="#4-primes-moderate-x2F-hard" class="headerlink" title="4 primes (moderate)&#x2F;(hard)"></a>4 primes (moderate)&#x2F;(hard)</h1><p>这个题的意思写一个并发版本的素数筛子，令多个筛子可以同时筛数。仔细看下图，这个图说明：如果某个数字在上一个筛子中没有被筛掉，并且这个数字是当前剩余数字中最小的那个，那么该数字是prime，需要输出，并且作为一个新的筛子。为了并行实现，可以通过fork产生子进程，父进程根据当前筛子向子进程输入数据，子进程则负责新的剩余数据，也就是说，实现父进程写和子进程读同时进行：<br><img data-src="/../images/sieve.gif"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">primes</span><span class="params">(<span class="type">int</span> *fd)</span> &#123;</span><br><span class="line">    <span class="type">int</span> p, d;</span><br><span class="line">    close(fd[<span class="number">1</span>]);  <span class="comment">// 由于fork时也复制了文件描述符，因此不需要的文件描述符应该关闭，以避免不可控的事情</span></span><br><span class="line">    <span class="keyword">if</span> (read(fd[<span class="number">0</span>], (<span class="type">void</span>*)&amp;p, <span class="keyword">sizeof</span>(p)) != <span class="keyword">sizeof</span>(p)) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Read fail!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;prime %d\n&quot;</span>, p);</span><br><span class="line">    <span class="keyword">if</span> (read(fd[<span class="number">0</span>], (<span class="type">void</span>*) &amp;d, <span class="keyword">sizeof</span>(d))) &#123;</span><br><span class="line">        <span class="type">int</span> fd1[<span class="number">2</span>];</span><br><span class="line">        pipe(fd1);</span><br><span class="line">        <span class="keyword">if</span> (fork() == <span class="number">0</span>) &#123;</span><br><span class="line">            primes(fd1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            close(fd1[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (d % p != <span class="number">0</span>) &#123;</span><br><span class="line">                    write(fd1[<span class="number">1</span>], (<span class="type">void</span>*) &amp;d, <span class="keyword">sizeof</span>(d));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">while</span> (read(fd[<span class="number">0</span>], (<span class="type">void</span>*)&amp;d, <span class="keyword">sizeof</span>(d)));</span><br><span class="line">            close(fd[<span class="number">0</span>]);</span><br><span class="line">            close(fd1[<span class="number">1</span>]);</span><br><span class="line">            wait(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> fd[<span class="number">2</span>];  <span class="comment">// fd[0]: read fd, fd[1]: write fd</span></span><br><span class="line">    <span class="type">int</span> start = <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> end = <span class="number">35</span>;</span><br><span class="line">    pipe(fd);</span><br><span class="line">    <span class="keyword">if</span> (fork() == <span class="number">0</span>) &#123;  <span class="comment">// 子进程</span></span><br><span class="line">        primes(fd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;  <span class="comment">// 父进程</span></span><br><span class="line">        close(fd[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt;= end; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (write(fd[<span class="number">1</span>], (<span class="type">void</span>*) &amp;i, <span class="keyword">sizeof</span>(i)) != <span class="number">4</span>) &#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Write fail!\n&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        close(fd[<span class="number">1</span>]);</span><br><span class="line">        wait(<span class="number">0</span>);  <span class="comment">// 防止出现孤儿进程</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="5-find-moderate"><a href="#5-find-moderate" class="headerlink" title="5 find (moderate)"></a>5 find (moderate)</h1><p>这个题要求实现给定目录和目标文件，输出给定目录及其子目录下的所有目标文件。仔细阅读<code>user/ls.c</code>：<code>fmtname</code>函数的功能是将输入<code>path</code>中最后一个<code>&#39;\&#39;</code>之后的内容截取出来，<code>ls</code>函数先将<code>fd</code>定向到<code>path</code>，用于后续读取<code>path</code>对应的文件或目录，<code>fstat</code>函数是读入fd指向文件的更具体的info，然后判断指向文件是什么类型，并进一步处理。对比<code>ls</code>和<code>find</code>的区别，可以发现<code>find</code>多了一个目标文件，并且<code>find</code>的<code>path</code>一定是一个目录。因此，<code>find</code>多了是否为目录的判断，以及文件名比对：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/fs.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span>*</span><br><span class="line"><span class="title function_">fmtname</span><span class="params">(<span class="type">char</span> *path)</span>  <span class="comment">// 获取path中最后一个‘/’之后的内容</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">char</span> buf[DIRSIZ+<span class="number">1</span>];</span><br><span class="line">  <span class="type">char</span> *p;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Find first character after last slash.</span></span><br><span class="line">  <span class="keyword">for</span>(p=path+<span class="built_in">strlen</span>(path); p &gt;= path &amp;&amp; *p != <span class="string">&#x27;/&#x27;</span>; p--)</span><br><span class="line">    ;</span><br><span class="line">  p++;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return blank-padded name.</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">strlen</span>(p) &gt;= DIRSIZ)</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">  memmove(buf, p, <span class="built_in">strlen</span>(p));</span><br><span class="line">  <span class="built_in">memset</span>(buf+<span class="built_in">strlen</span>(p), <span class="string">&#x27; &#x27;</span>, DIRSIZ-<span class="built_in">strlen</span>(p));</span><br><span class="line">  <span class="keyword">return</span> buf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">find</span><span class="params">(<span class="type">char</span> *path, <span class="type">char</span> *target_file)</span> &#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">512</span>], *p;</span><br><span class="line">  <span class="type">int</span> fd;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> <span class="title">de</span>;</span>  <span class="comment">// 目录信息</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span>  <span class="comment">// </span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((fd = open(path, <span class="number">0</span>)) &lt; <span class="number">0</span>)&#123;  <span class="comment">// 将fd定向到path</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;find: cannot open %s\n&quot;</span>, path);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(fstat(fd, &amp;st) &lt; <span class="number">0</span>)&#123;  <span class="comment">// 读入fd指向的文件info</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;find: cannot stat %s\n&quot;</span>, path);</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (read(fd, &amp;de, <span class="keyword">sizeof</span>(de)) != <span class="keyword">sizeof</span>(de)) &#123;  <span class="comment">// 判断能否读入fd指向的文件</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;find, cannot read %s\n&quot;</span>, path);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span>(st.type)&#123;</span><br><span class="line">  <span class="keyword">case</span> T_FILE:</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(de.name, target_file) == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%s/%s\n&quot;</span>, path, target_file);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> T_DIR:</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strlen</span>(path) + <span class="number">1</span> + DIRSIZ + <span class="number">1</span> &gt; <span class="keyword">sizeof</span> buf)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;ls: path too long\n&quot;</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">strcpy</span>(buf, path);</span><br><span class="line">    p = buf+<span class="built_in">strlen</span>(buf);</span><br><span class="line">    *p++ = <span class="string">&#x27;/&#x27;</span>;  <span class="comment">// buf下一层文路径</span></span><br><span class="line">    <span class="keyword">while</span>(read(fd, &amp;de, <span class="keyword">sizeof</span>(de)) == <span class="keyword">sizeof</span>(de))&#123;  <span class="comment">// 读取fd指向的文件</span></span><br><span class="line">      <span class="keyword">if</span>((de.inum == <span class="number">0</span>) || (<span class="built_in">strcmp</span>(de.name, <span class="string">&quot;.&quot;</span>) == <span class="number">0</span>) || (<span class="built_in">strcmp</span>(de.name, <span class="string">&quot;..&quot;</span>) == <span class="number">0</span>))&#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      memmove(p, de.name, DIRSIZ);</span><br><span class="line">      p[DIRSIZ] = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span>(stat(buf, &amp;st) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;find: cannot stat %s\n&quot;</span>, buf);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (st.type == T_FILE) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(de.name, target_file) == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, buf);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (st.type == T_DIR) find(buf, target_file);  <span class="comment">// 如果当前是目录，需要递归比对</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  close(fd);    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Usage: find [dir] [target_file]&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        find(argv[<span class="number">1</span>], argv[<span class="number">2</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="6-xargs-moderate"><a href="#6-xargs-moderate" class="headerlink" title="6 xargs (moderate)"></a>6 xargs (moderate)</h1><p>这个实验要求实现的功能是实现<code>xargs</code>命令的简化版本。主要思路是先根据<code>\n</code>确定一条命令，然后根据空格分辨出命令和它的参数。本题比较麻烦的是指针和字符数组的处理，需要特别小心：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/param.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLEN 1024</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">copy</span><span class="params">(<span class="type">char</span> **p1, <span class="type">char</span> *p2)</span> &#123;</span><br><span class="line">    *p1 = <span class="built_in">malloc</span>(<span class="built_in">strlen</span>(p2) + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(*p1, p2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">readLine</span><span class="params">(<span class="type">char</span> **pars, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="type">char</span> buf[MAXLEN];</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (read(<span class="number">0</span>, buf + j, <span class="number">1</span>)) &#123;  <span class="comment">// 每次读取一个字符，直到遇到\n，即读取一条命令</span></span><br><span class="line">        <span class="keyword">if</span> (buf[j] == <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">            buf[j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ++j;</span><br><span class="line">        <span class="keyword">if</span> (j == MAXLEN) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Parameters are too long!\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;  <span class="comment">// 没有读取到内容，即已经到pars的结尾</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (k &lt; j) &#123;  <span class="comment">// 一条命令可能有多个参数，每个参数保存在pars[i]中</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt; MAXARG) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Too much parameters!\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> ((k &lt; j) &amp;&amp; (buf[k] == <span class="string">&#x27; &#x27;</span>)) &#123;  <span class="comment">// 去掉命令的前导空格</span></span><br><span class="line">            ++k;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> l = k;</span><br><span class="line">        <span class="keyword">while</span> ((k &lt; j) &amp;&amp; (buf[k] != <span class="string">&#x27; &#x27;</span>)) &#123;</span><br><span class="line">            ++k;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        buf[k++] = <span class="number">0</span>;</span><br><span class="line">        copy(&amp;pars[i], buf + l);</span><br><span class="line">        ++i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Please enter more parameters!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *pars[MAXARG];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; argc; ++i) &#123;</span><br><span class="line">        copy(&amp;pars[i<span class="number">-1</span>], argv[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> e;</span><br><span class="line">    <span class="keyword">while</span> ((e = readLine(pars, argc - <span class="number">1</span>)) != <span class="number">-1</span>) &#123;</span><br><span class="line">        pars[e] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (fork() == <span class="number">0</span>) &#123;  <span class="comment">// 子进程执行命令</span></span><br><span class="line">            exec(pars[<span class="number">0</span>], pars);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            wait(<span class="number">0</span>);  <span class="comment">// 父进程等待子进程完成</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>MIT 6.S081</tag>
      </tags>
  </entry>
  <entry>
    <title>MIT 6.S081 Lab2 System Calls</title>
    <url>/2022/35594/</url>
    <content><![CDATA[<p>参考资料：</p>
<ul>
<li>课程官方网页：<a href="https://pdos.csail.mit.edu/6.S081/2021/index.html">https://pdos.csail.mit.edu/6.S081/2021/index.html</a></li>
<li>xv6 book：<a href="https://pdos.csail.mit.edu/6.S081/2021/xv6/book-riscv-rev2.pdf">https://pdos.csail.mit.edu/6.S081/2021/xv6/book-riscv-rev2.pdf</a></li>
<li>xv6手册中文版：<a href="http://xv6.dgs.zone/">http://xv6.dgs.zone/</a></li>
<li>参考代码：<a href="https://github.com/PKUFlyingPig/MIT6.S081-2020fall">https://github.com/PKUFlyingPig/MIT6.S081-2020fall</a></li>
</ul>
<span id="more"></span>

<h1 id="1-System-call-tracing-moderate"><a href="#1-System-call-tracing-moderate" class="headerlink" title="1 System call tracing (moderate)"></a>1 System call tracing (moderate)</h1><h2 id="1-1-题意"><a href="#1-1-题意" class="headerlink" title="1.1 题意"></a>1.1 题意</h2><p>这个题目的意思是，修改xv6系统的kernel，使得可以用<code>trace</code>跟踪系统调用输出<code>process id</code>，<code>system call name</code>和<code>return value</code>，并且<code>trace</code>调用需要保证可以跟踪调用进程及其子进程。<code>trace.c</code>已经实现了在user-level实现了trace的功能，我们只需要在kernel-level补充相关实现。</p>
<h2 id="1-2-实现步骤"><a href="#1-2-实现步骤" class="headerlink" title="1.2 实现步骤"></a>1.2 实现步骤</h2><p>根据题目提示，首先是在<code>user/user.h</code>增加trace函数的声明，在<code>user/usys.pl</code>增加trace函数的stub,<code>kernel/syscall.h</code>增加syscall number，这是为了使得xv6系统能通过编译：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// `user/user.h`</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">trace</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// user/usys.pl</span></span><br><span class="line">entry(<span class="string">&quot;trace&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// kernel/syscall.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_trace  22</span></span><br></pre></td></tr></table></figure>
<p>后两步的目的在于，将trace函数声明为syscall函数，使得<code>trace.c</code>的第17行调用trace函数时会自动调用系统函数。</p>
<p>然而，trace函数实际上在kernel-level并没有被实现。为了实现这一目标，根据题目提示，<code>kernel/proc.h</code>的进程结构中需要增加一个变量mask，用于记住调用trace syscall时所需的参数。<code>kernel/sysproc.c</code>中需要实现sys_trace()函数，该函数可以用于获取用户输入的变量mask，将其保存到进程中：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/proc.h</span></span><br><span class="line"><span class="type">int</span> mask;                    <span class="comment">// trace mask</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// kernel/sysproc.c</span></span><br><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_trace</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="type">int</span> mask;</span><br><span class="line">  <span class="keyword">if</span>(argint(<span class="number">0</span>, &amp;mask) &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  myproc()-&gt;mask = mask;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时，由于trace需要能跟踪子进程，因此需要修改<code>kernel/proc.c</code>中的fork()函数，使得trace mask可以复制到child process中：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/proc.c</span></span><br><span class="line">np-&gt;mask = p-&gt;mask;  <span class="comment">// copy mask from parent to child</span></span><br></pre></td></tr></table></figure>

<p>上述步骤实际上是实现trace的准备工作，为了实际实现trace功能，需要修改<code>kernel/syscall.c</code>的syscall()函数，用于打印trace的输出：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/syscall.c</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_trace</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="title function_">uint64</span> <span class="params">(*syscalls[])</span><span class="params">(<span class="type">void</span>)</span> = &#123;</span><br><span class="line">  ...</span><br><span class="line">  [SYS_trace]   sys_trace,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* sysnames[] = &#123;</span><br><span class="line">  <span class="string">&quot;fork&quot;</span>, <span class="string">&quot;exit&quot;</span>, <span class="string">&quot;wait&quot;</span>, <span class="string">&quot;pipe&quot;</span>, <span class="string">&quot;read&quot;</span>, <span class="string">&quot;kill&quot;</span>, <span class="string">&quot;exec&quot;</span>, <span class="string">&quot;fstat&quot;</span>, </span><br><span class="line">  <span class="string">&quot;chdir&quot;</span>, <span class="string">&quot;dup&quot;</span>, <span class="string">&quot;getpid&quot;</span>, <span class="string">&quot;sbrk&quot;</span>, <span class="string">&quot;sleep&quot;</span>, <span class="string">&quot;uptime&quot;</span>, <span class="string">&quot;open&quot;</span>, <span class="string">&quot;write&quot;</span>, </span><br><span class="line">  <span class="string">&quot;mknod&quot;</span>, <span class="string">&quot;unlink&quot;</span>, <span class="string">&quot;link&quot;</span>, <span class="string">&quot;mkdir&quot;</span>,<span class="string">&quot;close&quot;</span>,<span class="string">&quot;trace&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">syscall</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> num;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  num = p-&gt;trapframe-&gt;a7;  <span class="comment">// syscall number</span></span><br><span class="line">  <span class="keyword">if</span>(num &gt; <span class="number">0</span> &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123;</span><br><span class="line">    p-&gt;trapframe-&gt;a0 = syscalls[num]();  <span class="comment">// return value</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (p-&gt;mask &amp; (<span class="number">1</span> &lt;&lt; num))  <span class="comment">// syscall必须在mask中指定才能有输出</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d: syscall %s -&gt; %d\n&quot;</span>, p-&gt;pid, sysnames[num<span class="number">-1</span>], p-&gt;trapframe-&gt;a0);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %s: unknown sys call %d\n&quot;</span>,</span><br><span class="line">            p-&gt;pid, p-&gt;name, num);</span><br><span class="line">    p-&gt;trapframe-&gt;a0 = <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="1-3-总结"><a href="#1-3-总结" class="headerlink" title="1.3 总结"></a>1.3 总结</h1><ul>
<li><blockquote>
<p>在最开始，我们设置了一个perl脚本，Makefile会调用<code>user/usys.pl</code>，生成一个<code>user/usys.S</code>，这个文件就像一个switch语句一样，当你使用一个系统调用的时候，比如read，OS会查询<code>user/usys.S</code>中对应的标签target来执行相应的语句。</p>
</blockquote>
</li>
<li>注意看<code>user/usys.pl</code>中<code>print &quot; li a7, SYS_$&#123;name&#125;\n&quot;;</code>把被调用syscall名称放入寄存器a7，而在<code>kernel/syscall.c</code>中，syscall的编号也是在寄存器a7中获取的。</li>
<li>syscall的通用注册和实现流程：<ul>
<li><code>user/user.h</code>中声明该函数</li>
<li><code>user/usys.pl</code>中增加对应的syscall name</li>
<li><code>kernel/syscall.h</code>中增加syscall number</li>
<li><code>kernel/syscall.c</code>中增加指向新的系统函数的指针，并且可以修改<code>syscall</code>函数以配合sys_*的功能</li>
<li><code>kernel/proc.h</code>的<strong>process</strong>结构中增加该syscall需要的变量</li>
<li><code>kernel/sysproc.c</code>中实现sys_*函数，该函数用于处理调用sys_*后需要做的事情</li>
<li><code>kernel/proc.c</code>中可以处理sys_*涉及到的变量在<strong>process</strong>中的使用</li>
</ul>
</li>
<li>myproc可以用于获取当前正在运行的process</li>
</ul>
<h1 id="2-Sysinfo-moderate"><a href="#2-Sysinfo-moderate" class="headerlink" title="2 Sysinfo (moderate)"></a>2 Sysinfo (moderate)</h1><h2 id="2-1-题意"><a href="#2-1-题意" class="headerlink" title="2.1 题意"></a>2.1 题意</h2><p>本题要求增加系统调用<code>sysinfo</code>用于收集running system的信息，该系统调用函数使用一个指向<code>struct sysinfo</code>的指针作为输入。结构体字段包括freemem字段应该设置为空闲内存的字节数，nproc字段应该设置成状态不是UNUSED的进程数。</p>
<h2 id="2-2-实现步骤"><a href="#2-2-实现步骤" class="headerlink" title="2.2 实现步骤"></a>2.2 实现步骤</h2><p>根据题目提示，首先类似1.2注册sysinfo这个系统调用，并且需要在<code>user/user.h</code>中预声明<code>struct sysinfo</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// `user/user.h`</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sysinfo</span>;</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sysinfo</span><span class="params">(<span class="keyword">struct</span> sysinfo*)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// user/usys.pl</span></span><br><span class="line">entry(<span class="string">&quot;sysinfo&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// kernel/syscall.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_sysinfo  23</span></span><br></pre></td></tr></table></figure>

<p>然后，在<code>kernel/sysproc.c</code>中实现sys_sysinfo函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/sysproc.c</span></span><br><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_sysinfo</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 p;  <span class="comment">// pointer to struct sysinfo address</span></span><br><span class="line">  <span class="keyword">if</span>(argaddr(<span class="number">0</span>, &amp;p) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sysinfo</span> <span class="title">info</span>;</span></span><br><span class="line">  info.freemem = freemem();  <span class="comment">// get free memory</span></span><br><span class="line">  info.nproc = nproc();  <span class="comment">// get used proc</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span>* <span class="title">curproc</span> =</span> myproc();</span><br><span class="line">  <span class="comment">// copyout: curprocess pagetable, dst, src, size</span></span><br><span class="line">  <span class="keyword">if</span> (copyout(curproc-&gt;pagetable, p, (<span class="type">char</span>*)&amp;info, <span class="keyword">sizeof</span>(info)) &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据题目提示，freemem函数在<code>kernel/kalloc.c</code>中实现，nproc函数在<code>kernel/proc.c</code>中实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/kalloc.c</span></span><br><span class="line">uint64 <span class="title function_">freemem</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line">  uint64 sz = <span class="number">0</span>;</span><br><span class="line">  acquire(&amp;kmem.lock);</span><br><span class="line">  r = kmem.freelist;  <span class="comment">// freelist是第一个未被使用的页的地址</span></span><br><span class="line">  <span class="keyword">while</span> (r) &#123;</span><br><span class="line">    sz += <span class="number">1</span>;</span><br><span class="line">    r = r -&gt; next;</span><br><span class="line">  &#125;</span><br><span class="line">  sz = sz * PGSIZE;</span><br><span class="line">  release(&amp;kmem.lock);</span><br><span class="line">  <span class="keyword">return</span> sz;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// kernel/proc.c</span></span><br><span class="line">uint64 <span class="title function_">nproc</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  uint64 cnt = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NPROC; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (proc[i].state != UNUSED) ++cnt;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>MIT 6.S081</tag>
      </tags>
  </entry>
  <entry>
    <title>MIT 6.S081 Lab3 Page Tables</title>
    <url>/2022/29909/</url>
    <content><![CDATA[<p>参考资料：</p>
<ul>
<li>课程官方网页：<a href="https://pdos.csail.mit.edu/6.S081/2021/index.html">https://pdos.csail.mit.edu/6.S081/2021/index.html</a></li>
<li>xv6 book：<a href="https://pdos.csail.mit.edu/6.S081/2021/xv6/book-riscv-rev2.pdf">https://pdos.csail.mit.edu/6.S081/2021/xv6/book-riscv-rev2.pdf</a></li>
<li>xv6手册中文版：<a href="http://xv6.dgs.zone/">http://xv6.dgs.zone/</a></li>
<li>参考代码：<a href="https://blog.csdn.net/qq_33894666/article/details/121625097">https://blog.csdn.net/qq_33894666/article/details/121625097</a><span id="more"></span></li>
</ul>
<h1 id="1-Speed-up-system-calls-easy"><a href="#1-Speed-up-system-calls-easy" class="headerlink" title="1 Speed up system calls (easy)"></a>1 Speed up system calls (easy)</h1><h2 id="1-1-题意"><a href="#1-1-题意" class="headerlink" title="1.1 题意"></a>1.1 题意</h2><p>第一个任务是实现对系统调用<code>getpid</code>的优化。具体地说，当每个进程创建时，都映射一个read-only的页到<code>USYSCALL</code>（定义在<code>kernel/memlayout.h</code>中的<strong>虚拟地址</strong>），这个页的开头是一个<code>struct usyscall</code>，并将当前进程的pid保存在其中。</p>
<h2 id="1-2-实验步骤"><a href="#1-2-实验步骤" class="headerlink" title="1.2 实验步骤"></a>1.2 实验步骤</h2><p>根据提示，需要把一个结构体<code>struct usyscall</code>映射到<code>kernel/memlayout.h</code>中的<code>USYSCALL</code>地址。映射过程在<code>kernel/proc.c</code>中的<code>proc_pagetable</code>函数中执行，映射过程中需要用到<code>mappages</code>函数，且在使用<code>mappages</code>函数时设定给userspace只读权限的permission bits。此外需要在<code>allocproc</code>中分配和初始化页，以及确保在<code>freeproc</code>中初始化内存。在完成以上步骤后，就可以通过直接读取<code>USYSCALL</code>，获取进程id，而无需通过系统调用<code>getpid</code>获取进程id。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernal/proc.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">usyscall</span> *<span class="title">usysc</span>;</span>      <span class="comment">// 在进程结构体中添加保存映射信息的部分</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// kernal/proc.c</span></span><br><span class="line"><span class="type">pagetable_t</span></span><br><span class="line"><span class="title function_">proc_pagetable</span><span class="params">(<span class="keyword">struct</span> proc *p)</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将USYSCALL映射到进程的usysc</span></span><br><span class="line">  <span class="keyword">if</span> (mappages(pagetable, USYSCALL, PGSIZE, (uint64)(p-&gt;usysc), PTE_U | PTE_R) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    uvmfree(pagetable, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// kernal/proc.c</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> proc*</span><br><span class="line"><span class="title function_">allocproc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 给进程的usysc分配空间</span></span><br><span class="line">  <span class="keyword">if</span> ((p-&gt;usysc = (<span class="keyword">struct</span> usyscall *)kalloc()) == <span class="number">0</span>) &#123;</span><br><span class="line">    freeproc(p);</span><br><span class="line">    release(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  p-&gt;usysc-&gt;pid = p-&gt;pid;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// kernal/proc.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">freeproc</span><span class="params">(<span class="keyword">struct</span> proc *p)</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(p-&gt;usysc)</span><br><span class="line">    kfree((<span class="type">void</span>*)p-&gt;usysc);</span><br><span class="line">  p-&gt;usysc = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// kernal/proc.c</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">proc_freepagetable</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 sz)</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  uvmunmap(pagetable, USYSCALL, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="2-Print-a-page-table-easy"><a href="#2-Print-a-page-table-easy" class="headerlink" title="2 Print a page table (easy)"></a>2 Print a page table (easy)</h1><h2 id="2-1-题意"><a href="#2-1-题意" class="headerlink" title="2.1 题意"></a>2.1 题意</h2><p>本题要求实现函数<code>vmprint</code>，输入是<code>pagetable_t</code>，标准输出页表内容：page-table page，pte bits，physical address，不输出无效的pte。</p>
<h2 id="2-2-实验步骤"><a href="#2-2-实验步骤" class="headerlink" title="2.2 实验步骤"></a>2.2 实验步骤</h2><p>根据提示，首先在<code>exec.c</code>中添加<code>vmprint</code>调用语句<code>if(p-&gt;pid==1) vmprint(p-&gt;pagetable)</code>，并且在<code>kernel/defs.h</code>中添加<code>vmprint</code>函数的声明。接着，仔细阅读<code>kernel/vm.c</code>中的<code>freewalk</code>，并参照该函数实现<code>vmprint</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// exec.c</span></span><br><span class="line"><span class="keyword">if</span> (p-&gt;pid == <span class="number">1</span>) vmprint(p-&gt;pagetable);</span><br><span class="line"></span><br><span class="line"><span class="comment">// kernel/defs.h</span></span><br><span class="line"><span class="type">void</span>            <span class="title function_">vmprint</span><span class="params">(<span class="type">pagetable_t</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// kernel/vm.c</span></span><br><span class="line"><span class="type">void</span> __vmprint(<span class="type">pagetable_t</span> pagetable, <span class="type">int</span> level) &#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">512</span>; i++)&#123;</span><br><span class="line">    <span class="type">pte_t</span> pte = pagetable[i];</span><br><span class="line">    <span class="keyword">if</span>((pte &amp; PTE_V) &amp;&amp; (pte &amp; (PTE_R|PTE_W|PTE_X)) == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="comment">// this PTE points to a lower-level page table.</span></span><br><span class="line">      uint64 child = PTE2PA(pte);</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= level; ++j) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;..&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (j + <span class="number">1</span> &lt;= level) <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d: pte %p pa %p\n&quot;</span>, i, pte, child);</span><br><span class="line">      __vmprint((<span class="type">pagetable_t</span>)child, level + <span class="number">1</span>);  </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pte &amp; PTE_V)&#123;  <span class="comment">// leaf pte</span></span><br><span class="line">      uint64 child = PTE2PA(pte);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;.. .. ..%d: pte %p pa %p\n&quot;</span>, i, pte, child);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">vmprint</span><span class="params">(<span class="type">pagetable_t</span> p)</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;page table %p\n&quot;</span>, p);</span><br><span class="line">  __vmprint(p, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-Detecting-which-pages-have-been-accessed-hard"><a href="#3-Detecting-which-pages-have-been-accessed-hard" class="headerlink" title="3 Detecting which pages have been accessed (hard)"></a>3 Detecting which pages have been accessed (hard)</h1><h2 id="3-1-题意"><a href="#3-1-题意" class="headerlink" title="3.1 题意"></a>3.1 题意</h2><p>题目要求实现函数<code>pgaccess</code>，该函数用于报告哪个页被访问过。该函数包括三个输入参数：首先是待检查的第一个user page的虚拟地址（virtual address, va）；第二，是要检查的页的数量；第三，保存结果的结构体，该结构体以bitmask的形式保存页表是否被访问过，其中最低位对应第一个页。</p>
<h2 id="3-2-实现步骤"><a href="#3-2-实现步骤" class="headerlink" title="3.2 实现步骤"></a>3.2 实现步骤</h2><p>根据<code>user/pgtbltest.c</code>中的<code>pgaccess_test</code>函数，<code>pgaccess</code>有三个输入参数：<code>buf</code>、32和<code>&amp;abits</code>。<code>buf</code>是新申请的内存，大小为32个页，在当前进程的页表中有指向这些页的pte，我们只要获取最终指向这些页的pte，就可以知道这些页是否被访问过。我们可以根据<code>buf</code>的va为索引在当前进程的页表中找到这些pte，<code>buf</code>本身就是va。32表示页数。<code>abits</code>用于保存这32个页是否被访问过的结果，<code>&amp;abits</code>使得<code>pgaccess</code>函数可以直接修改<code>abits</code>。</p>
<p>RISC-V在硬件上已经实现了将page是否被访问过保存在pte的flags中，本题要做的只是把flags中的内容提取出来。<code>pageaccess</code>已经在userspace层面实现，所以只需要在kernel level实现<code>sys_pgaccess</code>函数即可。根据提示，需要在<code>kernel/riscv.h</code>中定义<code>PTE_A</code>，即判断一个页是否被访问过的bit（类似<code>PTE_U</code>，<code>PTE_R</code>等），根据<a href="https://pdos.csail.mit.edu/6.S081/2021/xv6/book-riscv-rev2.pdf">xv6 book</a>的Fig 3.2可知，<code>PTE_A</code>应该是每个PTE的右起第6个bit：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/riscv.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_A (1L &lt;&lt; 6) <span class="comment">// accessed</span></span></span><br></pre></td></tr></table></figure>

<p>在<code>sys_pgaccess</code>函数中，首先需要获取保存在寄存器中的参数，这和Lab2是一样的。然后，就可以根据va（再次强调，<code>buf</code>本身就是va）在当前进程的页表中索引到对应的<code>pte</code>，索引过程可以参考<code>kernel/vm.c</code>中的<code>walk</code>函数。最后，将这些<code>pte</code>的<code>PTE_A</code>截取出来保存到输出结果中，并且重置<code>PTE_A</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">sys_pgaccess</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// lab pgtbl: your code here.</span></span><br><span class="line">  uint64 va;           <span class="comment">// va保存待检查的page数组的虚拟地址</span></span><br><span class="line">  <span class="type">int</span> page_num;        <span class="comment">// 要核验的page数</span></span><br><span class="line">  uint64 abits_addr;   <span class="comment">// abits从低到高记录page是否被访问过，abits_addr保存abits的地址</span></span><br><span class="line">  <span class="keyword">if</span> (argaddr(<span class="number">0</span>, &amp;va) &lt; <span class="number">0</span> || argint(<span class="number">1</span>, &amp;page_num) &lt; <span class="number">0</span> || argaddr(<span class="number">2</span>, &amp;abits_addr) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(va &gt;= MAXVA)</span><br><span class="line">    panic(<span class="string">&quot;walk&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">pagetable_t</span> pagetable = myproc() -&gt; pagetable;</span><br><span class="line">  uint mask = <span class="number">0</span>;  <span class="comment">// 内核数据</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; page_num; ++i, va += PGSIZE) &#123;</span><br><span class="line">    <span class="type">pte_t</span> *pte = <span class="number">0</span>;</span><br><span class="line">    <span class="type">pagetable_t</span> p = pagetable;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> level = <span class="number">2</span>; level &gt;= <span class="number">0</span>; --level) &#123;</span><br><span class="line">      <span class="comment">// PX根据level提取va对应的9bit的L0/L1/L2，即64bits只有最右9bit起作用，可以索引pagetable不越界</span></span><br><span class="line">      pte = &amp;p[PX(level, va)];  <span class="comment">// 根据L0/L1/L2获取页表中对应的pte，并取其地址</span></span><br><span class="line">      <span class="keyword">if</span>(*pte &amp; PTE_V)  <span class="comment">// 如果该PTE有效</span></span><br><span class="line">        p = (<span class="type">pagetable_t</span>)PTE2PA(*pte);  <span class="comment">// 找到次一级页表</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (*pte&amp;PTE_V &amp;&amp; *pte&amp;PTE_A) &#123;</span><br><span class="line">      mask = mask | (<span class="number">1L</span> &lt;&lt; i); </span><br><span class="line">      *pte &amp;= ~PTE_A;  <span class="comment">// 重置pte的PTE_A</span></span><br><span class="line">    &#125;    </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (copyout(pagetable, abits_addr, (<span class="type">char</span>*)&amp;mask, <span class="keyword">sizeof</span>(uint64)) &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-3-总结"><a href="#3-3-总结" class="headerlink" title="3.3 总结"></a>3.3 总结</h2><p>在做这个实验时，我一直没搞明白<code>buf</code>到底指什么：它是pte？还是pagetable。后来读了参考代码才搞清楚，buf实际上就是大小为32个页的内存，当前进程的页表里有指向这些页的pte。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>MIT 6.S081</tag>
      </tags>
  </entry>
  <entry>
    <title>MIT 6.S081 Lab3 Page Tables</title>
    <url>/2022/52217/</url>
    <content><![CDATA[<p>参考资料：</p>
<ul>
<li>课程官方网页：<a href="https://pdos.csail.mit.edu/6.S081/2021/index.html">https://pdos.csail.mit.edu/6.S081/2021/index.html</a></li>
<li>xv6 book：<a href="https://pdos.csail.mit.edu/6.S081/2021/xv6/book-riscv-rev2.pdf">https://pdos.csail.mit.edu/6.S081/2021/xv6/book-riscv-rev2.pdf</a></li>
<li>xv6手册中文版：<a href="http://xv6.dgs.zone/">http://xv6.dgs.zone/</a></li>
<li>RISC-V unprivileged instructions：<a href="https://github.com/riscv/riscv-isa-manual/releases/download/draft-20200727-8088ba4/riscv-spec.pdf">https://github.com/riscv/riscv-isa-manual/releases/download/draft-20200727-8088ba4/riscv-spec.pdf</a></li>
<li>RISC-V privileged instructions：<a href="https://github.com/riscv/riscv-isa-manual/releases/download/draft-20200727-8088ba4/riscv-privileged.pdf">https://github.com/riscv/riscv-isa-manual/releases/download/draft-20200727-8088ba4/riscv-privileged.pdf</a></li>
<li>参考代码：<a href="https://blog.csdn.net/zwl1584671413/article/details/108379520">https://blog.csdn.net/zwl1584671413/article/details/108379520</a></li>
<li>其他参考链接：<ul>
<li>RISC-V 32位指令集介绍：<a href="https://blog.csdn.net/weixin_40377195/article/details/123647133">https://blog.csdn.net/weixin_40377195/article/details/123647133</a><span id="more"></span></li>
</ul>
</li>
</ul>
<h1 id="1-RISC-V-assembly-easy"><a href="#1-RISC-V-assembly-easy" class="headerlink" title="1 RISC-V assembly (easy)"></a>1 RISC-V assembly (easy)</h1><ul>
<li><code>auipc rd, immediate</code>：将32位立即数的高20位作为高位、低12位置0，然后与当前的PC值相加，将结果写入指定寄存器</li>
<li><code>jal rd, offset</code>：直接跳转指令。该指令将下一条指令的地址<code>PC+4</code>存入<code>rd</code>寄存器（以备跳回），然后把PC设为当前值加上<code>offset</code>符号扩展的值（跳转地址），即对20位立即数<code>offset</code>做符号扩展，并左移一位，产生32bit的有符号，其跳转范围在±1MB</li>
<li><code>jalr rd, offset(rs1)</code>：间接跳转指令。该指令将其后的指令地址<code>PC+4</code>存入目标寄存器中，然后其携带的12位立即数与寄存器<code>rs1</code>中的值相加，把计算出的地址的最低有效位置为0，存入PC寄存器（跳转的地址），其跳转范围为±2KB</li>
<li>big-endian vs. little-endian：<br>big-endian将数据的高位存在低地址，例如，考虑一个32bit的16进制数字0x00001234（每个数位占用4bit，两个数位占用1Byte），它的低位数将会存在高地址，高位会存在低地址（所谓big-endian）。与之相反，little-endian是低位数存在低位，高位数存在高位（所谓little-endian）<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">big-endian   little-endian</span><br><span class="line">  high           high</span><br><span class="line"> | 34 |         | 00 |  </span><br><span class="line"> | 12 |         | 00 |</span><br><span class="line"> | 00 |         | 12 |        </span><br><span class="line"> | 00 |         | 34 |</span><br><span class="line">  low            low</span><br></pre></td></tr></table></figure></li>
</ul>
<p>读<code>call.asm</code>代码可以得到答案：</p>
<ol>
<li>Which registers contain arguments to functions? For example, which register holds 13 in main’s call to printf?</li>
</ol>
<ul>
<li>根据<a href="https://github.com/riscv/riscv-isa-manual/releases/download/draft-20200727-8088ba4/riscv-spec.pdf">RISC-V unprivileged instructions</a> Table 25.1，寄存器<code>a0-a7</code>用于保存函数的参数。在<code>call.asm</code>中，寄存器<code>a2</code>保存了参数<code>13</code></li>
</ul>
<ol start="2">
<li>Where is the call to function f in the assembly code for main? Where is the call to g? (Hint: the compiler may inline functions.)</li>
</ol>
<ul>
<li>没有具体的调用，编译器将f和g处理为inline function，直接产生函数调用的结果</li>
</ul>
<ol start="3">
<li>At what address is the function printf located?</li>
</ol>
<ul>
<li>根据第50行<code>34: 5f8080e7    jalr 1528(ra) # 628 &lt;printf&gt;</code>可知为0x628。也可以算出来：第49行<code>30:	00000097    auipc ra,0x0</code>将PC的值写入ra，即ra的值为<code>0x30</code>，与1528相加后得到跳转地址为<code>0x628</code>，再查询<code>call.asm</code>可知0x628是prinft的地址</li>
</ul>
<ol start="4">
<li>What value is in the register ra just after the jalr to printf in main?</li>
</ol>
<ul>
<li>PC+4</li>
</ul>
<ol start="5">
<li>Run the following code.<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0x00646c72</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;H%x Wo%s&quot;</span>, <span class="number">57616</span>, &amp;i);</span><br><span class="line">```      </span><br><span class="line">What is the output? Here<span class="number">&#x27;</span>s an ASCII table that maps bytes to characters.</span><br><span class="line">The output depends on that fact that the RISC-V is little-endian. If the RISC-V were instead big-endian what would you <span class="built_in">set</span> i to in order to yield the same output? Would you need to change <span class="number">57616</span> to a different value?</span><br><span class="line">- `<span class="number">57616</span>`对应<span class="number">16</span>进制数`<span class="number">0xe110</span>`，因此前半段输出`He110`。`<span class="type">unsigned</span> <span class="type">int</span>`是<span class="number">32b</span>it，相当于<span class="number">4</span>个<span class="type">char</span>字符，对照ASCII表，`<span class="number">0x64</span>`对应`d`，`<span class="number">0x6c</span>`对应`l`，`<span class="number">72</span>`对应`r`，同时考虑到RISC-V是little-endian，即低地址保存低位数据，所以后半段输出`World`。如果RISC-V是big-endian，那么`i=<span class="number">0x726c6400</span>`</span><br><span class="line"></span><br><span class="line"><span class="number">6.</span> In the following code, what is going to be printed after <span class="string">&#x27;y=&#x27;</span>? (note: the answer is not a specific value.) Why does this happen?</span><br><span class="line">```c</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;x=%d y=%d&quot;</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li><code>y=%d</code>中的<code>%d</code>会替换为a2寄存器中的值，当前a2寄存器中值不明确，所以答案不确定</li>
</ul>
<h1 id="2-Backtrace-moderate"><a href="#2-Backtrace-moderate" class="headerlink" title="2 Backtrace (moderate)"></a>2 Backtrace (moderate)</h1><p>任务要求实现<code>backtrace</code>函数，可以输出当前的函数调用栈。根据提示，首先在<code>kernel/defs.h</code>中添加函数声明，从而可以在<code>sys_sleep</code>中调用backtrace：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/defs.h</span></span><br><span class="line"><span class="type">void</span>            <span class="title function_">backtrace</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>然后在<code>kernel/riscv.h</code>中添加in-line assembly代码，用于将s0寄存器中的值读入到变量<code>x</code>中，s0寄存器就是fp寄存器：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/riscv.h</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> uint64</span><br><span class="line"><span class="title function_">r_fp</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 x;</span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;mv %0, s0&quot;</span> : <span class="string">&quot;=r&quot;</span> (x) )</span>;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，在<code>kernel/printf.c</code>中实现backtrace函数：根据 <a href="https://pdos.csail.mit.edu/6.828/2021/lec/l-riscv-slides.pdf">lecture notes</a> 中的提示，栈帧的返回地址是<code>*(fp-8)</code>，新栈帧的fp为<code>*(fp-16)</code>，xv6会在内核中为每个栈自动分配一个page，该page位于PAGE-aligned address，可以使用<code>PGROUNDDOWN(fp)</code>和<code>PGROUNDUP(fp)</code>计算栈的底部和顶部地址（栈帧回溯的终止条件）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/printf.c</span></span><br><span class="line"><span class="type">void</span>  <span class="title function_">backtrace</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;backtrace:\n&quot;</span>);</span><br><span class="line">  uint64 fp = r_fp();</span><br><span class="line">  uint64 high = PGROUNDUP(fp);</span><br><span class="line">  <span class="keyword">while</span> (fp &lt; high) &#123;</span><br><span class="line">    uint64 ra = *(uint64 *)(fp<span class="number">-8</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, ra);</span><br><span class="line">    fp = *(uint64 *)(fp<span class="number">-16</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，根据要求，从<code>kernel/printf.c</code>中的panic函数和<code>kernel/sysproc.c</code>中的<code>sys_sleep</code>函数调用backtrace，以输出函数栈信息。</p>
<h1 id="3-Alarm-hard"><a href="#3-Alarm-hard" class="headerlink" title="3 Alarm (hard)"></a>3 Alarm (hard)</h1><p>任务要求给xv6增加一个新功能：当进程使用CPU时，会收到周期性的警告。具体地说，需要新增<code>sigalarm(interval, handler)</code>系统调用。当应用调用<code>sigalarm</code>时，每当该应用使用<code>n</code>个CPU时间后，内核都需要将CPU控制权转给handler；当handler执行完毕后，CPU控制权转回原应用。特别地，当应用调用<code>sigalarm(0,0)</code>时，内核应该终止周期性的警告。</p>
<p>首先，类似lab2在对应文件中添加内容以支持新的系统调用<code>sigalarm</code>和<code>sigreturn</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// user/usys.pl</span></span><br><span class="line">entry(<span class="string">&quot;sigalarm&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;sigreturn&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// user/user.h</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigalarm</span><span class="params">(<span class="type">int</span> ticks, <span class="type">void</span> (*handler)())</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sigreturn</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// kernel/syscall.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_sigalarm  22</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_sigreturn 23</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// kernel/syscall.c</span></span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_sigalarm</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_sigreturn</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="title function_">uint64</span> <span class="params">(*syscalls[])</span><span class="params">(<span class="type">void</span>)</span> = &#123;</span><br><span class="line">...</span><br><span class="line">[SYS_sigalarm] sys_sigalarm,</span><br><span class="line">[SYS_sigreturn] sys_sigreturn,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然后根据提示，在<code>struct proc</code>中添加如下信息并初始化：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/proc.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="type">int</span> interval;                <span class="comment">// alarm interval</span></span><br><span class="line">  <span class="type">void</span> (*handler) ();          <span class="comment">// pointer to the handler function</span></span><br><span class="line">  </span><br><span class="line">  <span class="type">int</span> passed_ticks;            <span class="comment">// ticks have passed since the last call to a process&#x27;s alarm handler</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> *<span class="title">saved_info</span>;</span>  <span class="comment">// save the trapframe before running the handler function</span></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> on_alarm;               <span class="comment">// whether CPU executes alarm function</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// kernel/proc.c</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> proc*</span><br><span class="line"><span class="title function_">allocproc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span>((p-&gt;saved_info = (<span class="keyword">struct</span> trapframe *)kalloc()) == <span class="number">0</span>)&#123;</span><br><span class="line">    freeproc(p);</span><br><span class="line">    release(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  p-&gt;interval = <span class="number">0</span>;</span><br><span class="line">  p-&gt;passed_ticks = <span class="number">0</span>;</span><br><span class="line">  p-&gt;on_alarm = <span class="number">0</span>;</span><br><span class="line">  p-&gt;interval = <span class="number">0</span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类似lab3，进程申请了<code>trapframe</code>，结束时要在<code>freeproc</code>初始化内存：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/proc.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">freeproc</span><span class="params">(<span class="keyword">struct</span> proc *p)</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;saved_info)</span><br><span class="line">    kfree((<span class="type">void</span>*)p-&gt;saved_info);</span><br><span class="line">  p-&gt;saved_info = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  p-&gt;interval = <span class="number">0</span>;</span><br><span class="line">  p-&gt;passed_ticks = <span class="number">0</span>;</span><br><span class="line">  p-&gt;on_alarm = <span class="number">0</span>;</span><br><span class="line">  p-&gt;interval = <span class="number">0</span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第三步，是在<code>sys_sigalarm</code>和<code>sys_sigreturn</code>中实现参数读取：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/sysproc.c</span></span><br><span class="line">uint64 <span class="title function_">sys_sigalarm</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="type">int</span> interval;</span><br><span class="line">  uint64 handler;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (argint(<span class="number">0</span>, &amp;interval) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span> (argaddr(<span class="number">1</span>, &amp;handler) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  p-&gt;interval = interval;</span><br><span class="line">  p-&gt;handler = handler;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uint64 <span class="title function_">sys_sigreturn</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  *(p-&gt;trapframe) = *(p-&gt;saved_info);</span><br><span class="line">  p-&gt;on_alarm = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后一步，在<code>kernel/trap.c</code>中修改<code>trap</code>函数，使其能响应时钟中断：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">usertrap</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>((which_dev = devintr()) != <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// ok</span></span><br><span class="line">    <span class="keyword">if</span> (which_dev == <span class="number">2</span>) &#123;  <span class="comment">// timer interrupt</span></span><br><span class="line">      <span class="keyword">if</span> (p-&gt;passed_ticks == p-&gt;interval &amp;&amp; p-&gt;on_alarm == <span class="number">0</span>) &#123;</span><br><span class="line">        p-&gt;passed_ticks = <span class="number">0</span>;</span><br><span class="line">        *(p-&gt;saved_info) = *(p-&gt;trapframe);</span><br><span class="line">        <span class="comment">// 这里令p-&gt;trapframe-&gt;epc指向handler函数，</span></span><br><span class="line">        <span class="comment">// 使得trap结束后，程序计数器pc被p-&gt;trapframe-epc覆盖，执行的就是handler函数</span></span><br><span class="line">        p-&gt;trapframe-&gt;epc = (uint64)p-&gt;handler;</span><br><span class="line">        p-&gt;on_alarm = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      p-&gt;passed_ticks += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个实验中，<code>sys_sigalarm</code>的工作只是保存好interval和handler的值，<code>trap</code>函数中才真正地切换了当前占用CPU的函数，并且<code>sys_sigreturn</code>中则是恢复旧trapframe的值，使得pc可以按照原来的函数继续往下执行（注意在handler函数中一定要使用sigreturn函数返回，否则无法回到原函数继续执行）。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>MIT 6.S081</tag>
      </tags>
  </entry>
  <entry>
    <title>MIT 6.S081 学习总结（updating）</title>
    <url>/2022/45755/</url>
    <content><![CDATA[<p>参考资料：</p>
<ul>
<li>课程官方网页：<a href="https://pdos.csail.mit.edu/6.S081/2021/index.html">https://pdos.csail.mit.edu/6.S081/2021/index.html</a></li>
<li>xv6 book：<a href="https://pdos.csail.mit.edu/6.S081/2021/xv6/book-riscv-rev2.pdf">https://pdos.csail.mit.edu/6.S081/2021/xv6/book-riscv-rev2.pdf</a></li>
<li>xv6手册中文版：<a href="http://xv6.dgs.zone/">http://xv6.dgs.zone/</a></li>
<li>参考代码：<a href="https://blog.csdn.net/qq_33894666/article/details/121625097">https://blog.csdn.net/qq_33894666/article/details/121625097</a></li>
<li>参考书：《UNIX环境高级编程（第3版）》<span id="more"></span></li>
</ul>
<h1 id="1-Operating-system-interfaces"><a href="#1-Operating-system-interfaces" class="headerlink" title="1 Operating system interfaces"></a>1 Operating system interfaces</h1><h2 id="1-1-Processes-and-memory"><a href="#1-1-Processes-and-memory" class="headerlink" title="1.1 Processes and memory"></a>1.1 Processes and memory</h2><ul>
<li><code>int fork()</code>：创建子进程，在父进程中的返回值是子进程的PID，在子进程中的返回值是0。<ul>
<li><code>fork</code>函数创建新的子进程后，在很多情况下，子进程需要调用<code>exec</code>函数以执行另一个程序。</li>
</ul>
</li>
<li><code>void exit(int status)</code>：终止当前进程，其操作包括调用各终止处理程序，然后关闭所有标准I&#x2F;O流等），<code>status</code>指示该进程是如何退出的，通常0指示正常退出的情况，1指示非正常退出的情况。<ul>
<li>无论是否正常退出，终止该进程的父进程都能调用<code>wait</code>或<code>waitpid</code>函数取得其终止状态。</li>
<li><code>_exit(int status)</code>：为进程提供无需运行终止处理程序或信号处理程序而最终只的方法。对标准I&#x2F;O流是否进行冲洗取决于实现。</li>
<li>在<code>main</code>函数内执行<code>return</code>语句，等效于调用<code>exit</code>。</li>
</ul>
</li>
<li><code>int wait(int *status)</code>：返回当前进程的已退出（或已杀死）子进程的PID，并将子进程的退出状态复制到传递给<code>wait</code>的地址。<ul>
<li>如果调用方的子进程都没有退出，那么<code>wait</code>等待一个子进程退出；如果调用者没有子进程，<code>wait</code>立即返回-1。如果父进程不关心子进程的退出状态，它可以传递一个0地址给<code>wait</code>，即父进程中使用<code>wait(0)</code>。</li>
<li>如果父进程在子进程之前停止，则子进程的父进程变为<code>init</code>状态（“这些进程由<code>init</code>进程收养”）。其操作过程大致是，在一个进程终止时，内核逐个检查所有活动进程，以判断它是否是正要终止进程的子进程。</li>
<li>内核为每个终止子进程保存了一定量的信息，这些信息至少包括进程PID、该进程的终止状态以及该进程使用的CPU时间总量，当终止进程的父进程调用<code>wait</code>或者<code>waitpid</code>时，可以得到这些信息。一个已经终止，但是其父进程尚未对其进行善后处理（获取终止子进程的有关信息、释放它仍占用的资源）的进程被称为<strong>僵死进程</strong>。</li>
</ul>
</li>
<li><code>int getpid()</code>：返回当前进程的PID。<ul>
<li>Lab3-Speed up system calls (easy)中实现了对<code>getpid</code>方法的优化，使得进程可以在用户态就获取到自身的PID。简单地说，是给在进程的开始给进程分配了一个read-only的页，用于保存进程的PID，需要时就从这个页读取PID。</li>
</ul>
</li>
<li><code>int sleep(int n)</code>：暂停当前进程，<code>n</code>指示暂停的时长。<ul>
<li>Lab1-sleep (easy)涉及了该函数的用法</li>
</ul>
</li>
<li><code>int exec(char *file, char *argv[])</code>：加载并执行可执行文件，<code>args</code>作为执行参数。<ul>
<li>当进程调用<code>exec</code>函数时，该进程执行的程序完全替换为新程序，而新程序则从其main函数开始执行。</li>
<li>调用<code>exec</code>并不创建新进程，所以调用前后进程的PID并不改变。</li>
<li>在UNIX系统种有7种不同的<code>exec</code>函数可供使用，而xv6系统为了简便，统一为<code>exec</code>函数。</li>
</ul>
</li>
</ul>
<h2 id="1-2-I-x2F-O-and-File-descriptors"><a href="#1-2-I-x2F-O-and-File-descriptors" class="headerlink" title="1.2 I&#x2F;O and File descriptors"></a>1.2 I&#x2F;O and File descriptors</h2><ul>
<li>文件描述符（file descriptors）：文件描述符是一个非负整数，表示进程可以读取或写入的、由内核管理的对象。进程可以通过打开一个<strong>文件</strong>、<strong>目录</strong>、<strong>设备</strong>，或创建一个<strong>管道</strong>，或复制一个已存在的描述符来获得一个文件描述符。<ul>
<li>文件描述符接口将文件、管道和设备之间的差异抽象出来，使它们看起来都像字节流。</li>
<li>进程从文件描述符0读取（标准输入），将输出写入文件描述符1（标准输出），并将错误消息写入文件描述符2（标准错误）。</li>
<li><code>fork</code>复制进程后，父子进程在开始时拥有完全相同的打开文件和<strong>文件偏移量</strong>，并且父子进程之间<strong>共享</strong>文件偏移量。</li>
<li><code>exec</code>替换了调用进程的内存，但保留其文件表。</li>
<li><code>fork</code>和<code>exec</code>分离的用处之一在于，在这两个调用之间有机会对子进程进行I&#x2F;O重定向，而不会干扰父进程的I&#x2F;O设置。</li>
</ul>
</li>
<li><code>int open(char *file, int flags)</code>：打开一个文件，<code>flags</code>指定打开的方式（例如：<code>O_RDONLY</code>, <code>O_WRONLY</code>等）。<ul>
<li>由<code>open</code>函数返回的文件描述符一定是最小的可用描述符。</li>
</ul>
</li>
<li><code>int read(int fd, char *buf, int n)</code>：从文件描述符fd读取最多n字节，将它们复制到buf，并返回读取的字节数。<ul>
<li>从当前<strong>文件偏移量</strong>开始读取数据，然后将该偏移量前进读取的字节数。</li>
<li>当没有更多的字节可读时，read返回0来表示文件的结束。</li>
</ul>
</li>
<li><code>int write(int fd, char *buf, int n)</code>：将buf中的n字节写入文件描述符，并返回写入的字节数。<ul>
<li>从当前<strong>文件偏移量</strong>开始写入数据，然后将该偏移量向前推进写入的字节数。</li>
<li>只有发生错误时才会写入小于n字节的数据。</li>
</ul>
</li>
<li><code>int lseek(int fd, int offset, int whence)</code>：为一个打开的文件显式设置文件偏移量。</li>
<li><code>int close(int fd)</code>：关闭一个打开文件。当一个进程终止时，内核将自动关闭它所有的打开文件。</li>
<li><code>int dup(int fd)</code>：复制一个现有的文件描述符，返回当前可用文件描述符中的最小数值。两个文件描述符<strong>共享文件偏移量</strong>。<ul>
<li><code>int dup2(int fd, int fd2)</code>：可以用<code>fd2</code>参数指定新描述符的值，返回新的文件描述符。如果<code>fd2</code>已经打开，在先将其关闭。如果<code>fd</code>等于<code>fd2</code>，则<code>dup2</code>返回<code>fd2</code>，而不是关闭它。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将hello world输出到fd指定的对象</span></span><br><span class="line">fd = dup(<span class="number">1</span>);</span><br><span class="line">write(<span class="number">1</span>, <span class="string">&quot;hello &quot;</span>, <span class="number">6</span>);</span><br><span class="line">write(fd, <span class="string">&quot;world\n&quot;</span>, <span class="number">6</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="1-3-Pipes"><a href="#1-3-Pipes" class="headerlink" title="1.3 Pipes"></a>1.3 Pipes</h2><ul>
<li><code>int pipe(int fd[2])</code>：调用<code>pipe</code>函数可以创建一个新的管道，数组<code>fd</code>记录读写文件描述符。<ul>
<li>一般而言，<code>fd[0]</code>为读入端的文件描述符，<code>fd[1]</code>为写入端的文件描述符，<code>fd[1]</code>的输出时<code>fd[0]</code>的输入。</li>
<li>如果没有可用的数据，则管道上的读入端将进入等待，直到有新数据写入或所有指向写入端的文件描述符都被关闭。</li>
<li>当所有指向写入端的文件描述符都被关闭时，读入端将返回0，就像到达数据文件的末尾一样。</li>
<li>管道只能在具有公共祖先的两个进程之间使用。通常，进程先调用<code>pipe</code>，接着调用<code>fork</code>，从而创建父子进程之间的IPC通道。</li>
</ul>
</li>
</ul>
<h2 id="1-4-File-system"><a href="#1-4-File-system" class="headerlink" title="1.4 File system"></a>1.4 File system</h2><p>文件本身和文件的名字是不同的：同一个底层文件（叫做inode，索引结点）可以有多个名字（叫做link，链接）。每个链接都由目录中的一个条目组成，该条目包含一个文件名和一个对inode的引用。inode保存关于文件的元数据（metadata），包括其类型（文件&#x2F;目录&#x2F;设备…）、长度、文件内容在磁盘上的位置以及指向文件的链接数。每个inode由唯一的inode编号标识。</p>
<ul>
<li><code>int stat(char *file, struct stat *st)</code>：根据<strong>文件的完全路径</strong>，获取有关信息保存在<code>st</code>中。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> T_DIR     1   <span class="comment">// Directory</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T_FILE    2   <span class="comment">// File</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T_DEVICE  3   <span class="comment">// Device</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> dev;     <span class="comment">// File system&#x27;s disk device</span></span><br><span class="line">  uint ino;    <span class="comment">// Inode number</span></span><br><span class="line">  <span class="type">short</span> type;  <span class="comment">// Type of file</span></span><br><span class="line">  <span class="type">short</span> nlink; <span class="comment">// Number of links to file</span></span><br><span class="line">  uint64 size; <span class="comment">// Size of file in bytes</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><code>int fstat(int fd, struct stat *st)</code>：<code>fstat</code>与<code>stat</code>的不同在于，<code>fstat</code>获的参数是<strong>文件描述符</strong>。<ul>
<li>Lab1-find (moderate)中，<code>fstat</code>函数是读入fd指向文件的更具体的info，然后判断指向文件是什么类型，并进一步处理。</li>
</ul>
</li>
<li><code>int link(char *file1, char *file2)</code>：创建新文件名<code>file2</code>，指向与现有文件名<code>file1</code>相同的inode。<ul>
<li>通过<code>fstat</code>获取<code>ino</code>，可以知道<code>file1</code>和<code>file2</code>引用相同的底层内容，同时<code>nlink</code>计数将被置为2。</li>
</ul>
</li>
<li><code>int unlink(char *file)</code>：删除链接。<ul>
<li>只有当文件的链接数为零且没有文件描述符引用时，文件的inode和包含其内容的磁盘空间才会被释放。</li>
</ul>
</li>
<li><code>int chdir(char *dir)</code>更改当前工作目录</li>
<li><code>int mkdir(char *dir)</code>：创建一个新目录</li>
<li><code>int mknod(char *file, int, int)</code>：创建一个引用设备的特殊文件。<ul>
<li>与设备文件相关联的是主设备号和次设备号(mknod的两个参数)，它们唯一地标识了一个内核设备。</li>
<li>当进程稍后打开设备文件时，内核将使用内核设备实现read和write系统调用，而不是使用文件系统。</li>
</ul>
</li>
</ul>
<h1 id="2-Operating-system-organization"><a href="#2-Operating-system-organization" class="headerlink" title="2 Operating system organization"></a>2 Operating system organization</h1><h2 id="2-1-Abstracting-physical-resources"><a href="#2-1-Abstracting-physical-resources" class="headerlink" title="2.1 Abstracting physical resources"></a>2.1 Abstracting physical resources</h2><ul>
<li>为什么需要operating system<ul>
<li>为了简化开发，需要提供一套能将资源抽象化的方法</li>
<li>库函数方案的问题在于，当有多个应用程序运行时，这些程序必须<strong>可靠</strong>且<strong>运行良好</strong>：需要适时放弃处理资源、并且程序不要出bug（一旦出bug就可能影响到其他程序的运行）。人们通常希望提供比合作方案更强的隔离</li>
<li>基于上述原因，人们需要操作系统用于为应用程序分配资源，因此应用程序只需考虑自身，不需要关注底层的硬件或者其他的应用程序</li>
</ul>
</li>
</ul>
<h2 id="2-2-User-mode-supervisor-mode-and-system-calls"><a href="#2-2-User-mode-supervisor-mode-and-system-calls" class="headerlink" title="2.2 User mode, supervisor mode, and system calls"></a>2.2 User mode, supervisor mode, and system calls</h2><ul>
<li>强隔离要求在操作系统和应用程序之间有硬边界，才能保证应用程序不能修改（甚至读取）操作系统的数据结构和指令，以及应用程序不能访问其他进程的内存。</li>
<li>RISC-V有三种<strong>CPU可以执行指令的模式</strong>：机器模式（machine mode）、管理模式（supervisor mode）和用户模式（user mode），其权限由高到低。<ul>
<li>在机器模式下执行的指令具有完全特权；CPU在机器模式下启动。机器模式主要用于配置计算机。</li>
<li>在管理模式下，CPU被允许执行特权指令，例如启用和禁用中断等。管理模式下的程序称为在<strong>内核空间</strong>中运行。在内核空间（或管理模式）中运行的程序被称为<strong>内核</strong>。</li>
<li>应用程序一般只能运行用户模式的指令，并称其为在<strong>用户空间</strong>中运行。如果应用程序需要使用内核函数（如<code>read</code>系统调用），CPU必须先切换管理模式，再由内核验证系统调用的参数，决定是否执行该指令。</li>
</ul>
</li>
</ul>
<h2 id="2-3-Kernel-organization"><a href="#2-3-Kernel-organization" class="headerlink" title="2.3 Kernel organization"></a>2.3 Kernel organization</h2><ul>
<li>宏内核：整个操作系统都驻留在内核中，这样所有系统调用的实现都以管理模式运行。</li>
<li>微内核：最大限度地减少在管理模式下运行的操作系统代码量，并在用户模式下执行大部分操作系统</li>
</ul>
<h2 id="2-4-Process-overview"><a href="#2-4-Process-overview" class="headerlink" title="2.4 Process overview"></a>2.4 Process overview</h2><ul>
<li>进程是操作系统中资源分配的最小单位，线程是操作系统中调度的最小单位，线程之间共享进程资源。</li>
<li>进程有两个栈区：用户栈区和内核栈区。当进程进入内核（由于系统调用或者中断）时，内核代码在内核栈上执行，此时它的用户栈仍然包含保存的数据，只是不处于活动状态。</li>
<li>进程可以通过<code>ecall</code>提高硬件特权级别、进行系统调用，程序计数器（PC）更改为内核定义的入口点，入口点的代码切换到内核栈。系统调用完成时，切回用户栈，并通过调用<code>sret</code>指令返回用户空间，该指令降低了硬件特权级别，并在系统调用指令刚结束时恢复执行用户指令。</li>
</ul>
<h1 id="3-Page-tables"><a href="#3-Page-tables" class="headerlink" title="3 Page tables"></a>3 Page tables</h1><h2 id="3-1-Paging-hardware"><a href="#3-1-Paging-hardware" class="headerlink" title="3.1 Paging hardware"></a>3.1 Paging hardware</h2><ul>
<li><code>satp</code>寄存器：存放根页表在物理内存中的地址。每个RISC-V CPU都有自己的<code>satp</code>寄存器（在运行时切换指向的内存地址），一个CPU可以使用自己的<code>satp</code>指向的页表转换后续指令生成的所有地址。不同的CPU可以运行不同的进程，每个进程都有自己的页表描述的私有地址空间。</li>
</ul>
<p><img data-src="/../images/xv6book/va.png"></p>
<h2 id="3-2-Kernel-address-space"><a href="#3-2-Kernel-address-space" class="headerlink" title="3.2 Kernel address space"></a>3.2 Kernel address space</h2><p>QEMU模拟了一台计算机，QEMU将设备接口作为<em>内存映射</em>控制寄存器（<em>memory-mapped</em> control registers）暴露给应用，这些寄存器位于物理地址空间0x80000000以下。内核可以通过读取&#x2F;写入这些特殊的物理地址与设备交互；这种读取和写入与设备硬件而不是RAM通信。内核使用<strong>直接映射</strong>获取<strong>内存</strong>和<strong>内存映射设备寄存器</strong>（PHYSTOP以下的地址都是直接映射），即将资源映射到等于物理地址的虚拟地址。例如：</p>
<ul>
<li>内核本身在虚拟地址空间和物理内存中都位于<code>KERNBASE=0x80000000</code>。</li>
<li>当<code>fork</code>为子进程分配用户内存时，分配器返回该内存的物理地址。</li>
</ul>
<p>有几个内核虚拟地址不是直接映射：</p>
<ul>
<li>The trampoline page：该page在虚拟地址空间的顶部。但是对应的物理页面在虚拟地址空间中映射了两次：一次在虚拟地址空间的顶部，一次直接映射。</li>
<li>The kernel stack pages：每个进程都有自己的内核栈，进程之间的内核栈会被映射到偏高一些的位置，从而留下guard page的空间。guard page是保护页，当某个进程发生内核栈溢出时，保护其他进程的内核栈不被影响。注意，guard page不会浪费物理内存，它只是占据了虚拟地址空间的一段靠后的地址，但是并不映射到物理地址空间。<br><img data-src="/../images/xv6book/kernel_space.png"></li>
</ul>
<h2 id="3-3-Process-address-space"><a href="#3-3-Process-address-space" class="headerlink" title="3.3 Process address space"></a>3.3 Process address space</h2><p>一个进程的用户内存从虚拟地址0开始，可以增长到<code>MAXVA</code>，原则上允许一个进程内存寻址空间为256G。如果需要更多的用户内存，xv6首先使用<code>kalloc</code>分配物理页面，然后将对应的PTE加到进程页表中，使得进程可以通过PTE使用这个物理页面。</p>
<p>下图展示了一个C程序的存储空间布局：</p>
<ul>
<li>text：由CPU执行的机器指令部分，通常是只读的，以防程序由于意外而修改指令</li>
<li>initialized data：通常将此段称为数据段，存放了程序中明确地赋初值的普通全局变量和静态变量</li>
<li>uninitialized data：又称BSS段（block started by symbol），存放了未明确赋初值的普通全局变量和静态变量。在程序未开始之前，内核将此段中的数据初始化为0或者空指针</li>
<li>stack：自动变量以及每次函数调用时所需保存的的信息都存放在此段中。每次发生函数调用时，其返回地址以及调用者的调用环境（例如某些机器寄存器的值）都存在此段中。然后，最近被调用的函数在栈上为其自动和临时变量分配存储空间。每个函数使用的栈空间视为一个栈帧（stack frame），所有的栈帧就构成了这个程序完整的栈</li>
<li>heap：通常在堆中进行动态存储分配，由程序员编写代码申请和释放<br><img data-src="/../images/xv6book/user_space2.png"></li>
</ul>
<p>在linux中，虚拟地址范围为0<del>4G，其中地址最高的1G分给内核使用，称为<strong>内核空间</strong>，较低的0</del>3G给用户进程使用，称为<strong>用户空间</strong>。最高的1GB虚拟内核空间为所有进程以及内核程序共享。内核空间和用户空间一般通过系统调用进行通信。</p>
<h1 id="4-Traps-and-system-calls"><a href="#4-Traps-and-system-calls" class="headerlink" title="4 Traps and system calls"></a>4 Traps and system calls</h1><h2 id="4-1-RISC-V-trap-machinery"><a href="#4-1-RISC-V-trap-machinery" class="headerlink" title="4.1 RISC-V trap machinery"></a>4.1 RISC-V trap machinery</h2><p>内核通过向控制寄存器写入内容来告诉CPU如何处理trap，以下是最重要的一些寄存器概述。</p>
<ul>
<li><code>stvec</code>：内核在这里写入其trap处理程序的地址</li>
<li><code>sepc</code>：trap发生时，用于保存程序计数器pc，pc本身则被<code>stvec</code>覆盖</li>
<li><code>scause</code>：放置描述trap原因的数字</li>
<li><code>sscratch</code>：内核在这里放置一个值，这个值在trap处理程序一开始就会派上用场</li>
<li><code>sstatus</code>：<code>sstatus</code>中的SIE位控制设备中断是否启用。SPP位指示trap是来自用户模式还是管理模式</li>
</ul>
<h2 id="4-2-Traps-from-user-space"><a href="#4-2-Traps-from-user-space" class="headerlink" title="4.2 Traps from user space"></a>4.2 Traps from user space</h2><p>如果应用程序发出系统调用（<code>ecall</code>指令），或者做了非法的事情，或者设备产生终端（读写磁盘），那么在用户空间中执行时就可能产生trap。来自用户空间的trap的高级路径是：uservec（kernel&#x2F;trampoline.S:16），然后是usertrap（kernel&#x2F;trap.c:37）；返回时，先是usertrapret（kernel&#x2F;trap.c:90），然后是userret（kernel&#x2F;trampoline.S:16）。</p>
<!--
- `uservec`是`stvec`指向的一段trap向量指令。由于RISC-V硬件本身不会主动切换页表，所以`uservec`这段指令必须在用户页表中能找到映射。这段指令需要能把`satp`从用户进程根页表切换到内核根页表、保存32个user registers中的内容。在进入用户空间之前，`sscratch`就被设置为指向当前进程的`trapframe`（每个进程都有独立的`trapframe`），该`trapframe`有足够的空间保存32个user registers。当创建一个进程时，xv6为每个进程的`trapframe`分配一个page，并安排它始终映射在用户虚拟地址`TRAPFRAME`（`TRAPFRAME`是一个地址，`trapframe`是一个帧）。因此在交换`a0`和`sscratch`之后，`a0`持有指向当前进程trap帧的指针。`trapframe`包含指向当前进程内核栈的指针、当前CPU的`hartid`、`usertrap`的地址和内核页表的地址。`uservec`取得这些值，将`satp`切换到内核页表，并调用`usertrap`。
- `usertrap`的任务是确定trap的原因、处理并返回。
- `uservec`
- trampoline page可以解决上述问题。xv6将trampoline page映射到内核页表和每个用户页表中相同的虚拟地址（即`TRAMPOLINE`）。-->

<h2 id="4-3-Traps-from-kernel-space"><a href="#4-3-Traps-from-kernel-space" class="headerlink" title="4.3 Traps from kernel space"></a>4.3 Traps from kernel space</h2><p>xv6根据执行的是用户代码还是内核代码，对CPU的trap寄存器的配置有所不同。当在CPU上执行内核时，内核将<code>stvec</code>指向<code>kernelvec</code>(kernel&#x2F;kernelvec.S:10)的汇编代码。由于xv6已经在内核中，<code>kernelvec</code>可以依赖于设置为内核页表的<code>satp</code>，以及指向有效内核栈的栈指针。<code>kernelvec</code>保存所有寄存器，以便被中断的代码最终可以不受干扰地恢复。</p>
<h2 id="4-4-Page-fault-exceptions"><a href="#4-4-Page-fault-exceptions" class="headerlink" title="4.4 Page-fault exceptions"></a>4.4 Page-fault exceptions</h2><ul>
<li>copy on write (COW) fork：<code>fork</code>之后的父子进程共享所有物理页面（只读权限），只有在需要写入时，才为父子进程分配新的、权限为读写的物理页面。<ul>
<li>RISC-V有三种不同的页面错误: 加载页面错误（当加载指令无法转换其虚拟地址时），存储页面错误（当存储指令无法转换其虚拟地址时）和指令页面错误（当指令的地址无法转换时）。<code>scause</code>寄存器中的值指示页面错误的类型，<code>stval</code>寄存器包含无法翻译的地址。</li>
<li>当子级或父级执行存储指令时，RISC-V CPU引发页面错误异常。为了响应此异常，内核复制包含错误地址的页面。它在子级的地址空间中映射一个权限为读&#x2F;写的副本，在父级的地址空间中映射另一个权限为读&#x2F;写的副本。</li>
</ul>
</li>
<li>lazy allocation：内核仅在应用程序实际使用内存时才分配。</li>
<li>利用页面故障的另一个广泛使用的功能是从磁盘分页。当进程读取到存在磁盘上的页时，会产生页面错误，然后内核会检查磁盘上是否有这个页面，如果有就将其读入内存。</li>
</ul>
<h1 id="5-Interrupts-and-device-drivers"><a href="#5-Interrupts-and-device-drivers" class="headerlink" title="5 Interrupts and device drivers"></a>5 Interrupts and device drivers</h1><ul>
<li>中断（interrupt）：是为了device与CPU之间的通信，比如时钟中断，硬盘读写服务请求中断等。</li>
<li>异常（exception）：CPU执行时出错，发出中断（也可称为内部中断），是被动发生中断事件。</li>
<li>陷入（trap）：CPU跳转使程序主动进入某一条指令流。</li>
</ul>
<h2 id="5-1-Concurrency-in-drivers"><a href="#5-1-Concurrency-in-drivers" class="headerlink" title="5.1 Concurrency in drivers"></a>5.1 Concurrency in drivers</h2><p>xv6的main函数调用<code>consoleinit</code>（kernel&#x2F;console.c:184）来初始化UART硬件。UART硬件在应用程序中被视为一组内存映射的控制寄存器。xv6的shell通过<code>init.c</code> (user&#x2F;init.c:19)中打开的文件描述符从控制台读取输入。当用户输入一个字符时，UART硬件要求RISC-V发出一个中断，从而激活xv6的trap处理程序。如果是UART导致的中断，devintr将调用<code>uartintr</code>（kernel&#x2F;uart.c:180）从UART硬件读取所有等待输入的字符，并将它们交给<code>consoleintr</code>（consoleintr的工作是在cons.buf中积累输入字符）。当换行符到达时，<code>consoleintr</code>唤醒一个等待的<code>consoleread</code>（若有）。一旦被唤醒，<code>consoleread</code>将监视cons.buf中的一整行，将其复制到用户空间，并返回（通过系统调用机制）给用户空间。对<code>read</code>的调用实现了从内核流向<code>consoleread</code>（kernel&#x2F;console.c:82）的数据通路。</p>
<p>这里有3个并发风险：来自不同CPU的两个进程可能同时调用<code>consoleread</code>；硬件可能会在<code>consoleread</code>正在执行时要求CPU传递控制台中断；硬件可能在当前CPU正在执行consoleread时向其他CPU传递控制台中断。锁（Lock）可以用于解决上述问题（chapter 6）。此外，还可能出现的情形是，某个进程正在等待来自设备的输入，但是输入的中断信号恰好在另一个进程运行时到达。为了解决该问题，中断处理程序不被允许考虑那些已经中断的进程或代码。中断处理程序通常做相对较少的工作，并唤醒上半部分代码来完成其余工作。</p>
<h2 id="5-2-Timer-interrupts"><a href="#5-2-Timer-interrupts" class="headerlink" title="5.2 Timer interrupts"></a>5.2 Timer interrupts</h2><p>RISC-V要求定时器中断在机器模式（而非管理模式）进行。RISC-V机器模式无需分页即可执行，并且有一组单独的控制寄存器，因此在机器模式下运行普通的xv6内核代码是不实际的。xv6处理定时器中断完全不同于trap机制。相关代码在<code>kernel/start.c</code>，基本处理过程为：进行CLINT（core-local interruptor）硬件编程，以便在特定延迟后生成中断；设置一个scratch区域，类似trapframe，用于保存user registers和CLINT寄存器的地址。start将mtvec设置为timervec，并enable定时器中断。</p>
<p>有一个问题是，计时器中断可能发生在用户或内核代码正在执行的任何时候，但是内核又无法在临界区操作期间禁用计时器中断。为了解决这个问题，基本策略是计时器中断处理程序要求RISC-V发出software interrupt，然后立即返回。接着，RISC-V用普通陷阱机制将software interrupt传递给内核，并允许内核禁用它们。</p>
<h1 id="6-Locking"><a href="#6-Locking" class="headerlink" title="6 Locking"></a>6 Locking</h1><h2 id="6-1-Race-conditions-and-locks"><a href="#6-1-Race-conditions-and-locks" class="headerlink" title="6.1 Race conditions and locks"></a>6.1 Race conditions and locks</h2><p>Race conditions是指多个进程同时读写某些共享数据（至少有一个写入）的情况。race通常包含bug：要么丢失更新，要么读取未完成更新的数据结构。race的结果取决于进程运行时处理器的状态。避免竞争的通常方法是使用锁。</p>
<ul>
<li>spinlocks：循环询问以获取锁。</li>
</ul>
<p>在某些情况下，某个进程可能长时间占有锁（例如在磁盘上读写文件内容时保持文件锁定）。如果有其他进程想获得锁，就需要长时间保持spinlock询问，这会导致进程在获取锁时浪费大量CPU资源进行自旋询问。此外，一个进程在持有spinlock的同时不能让出（yield）CPU，但是人们又希望持有锁的进程等待磁盘I&#x2F;O时，其他进程可以使用CPU。在持有spinlock时让出CPU是非法的：如果其他进程试图获取spinlock，可能会导致deadlock（deadlock是指两个进程互相等待对方释放资源的情形）。</p>
<ul>
<li>sleep-locks：询问获取锁，失败后进入休眠状态。</li>
</ul>
<h2 id="6-2-Locks-and-interrupt-handlers"><a href="#6-2-Locks-and-interrupt-handlers" class="headerlink" title="6.2 Locks and interrupt handlers"></a>6.2 Locks and interrupt handlers</h2><p>spinlock和中断的交互引起了潜在危险：令<code>sys_sleep</code>持有锁<code>tickslock</code>，且它的CPU被计时器中断；<code>clockintr</code>会尝试获取<code>tickslock</code>，但是因为<code>tickslock</code>被<code>sys_sleep</code>持有，所以<code>clockintr</code>会被阻塞；而<code>sys_sleep</code>只有在<code>clockintr</code>返回后才能继续运行；因此会导致deadlock。为了避免上述情况，必须保证：如果一个spinlock被某个中断处理程序所使用，那么CPU必须保证在启用中断的情况下永远也不能持有该锁。<code>acquire</code>使用<code>push_off</code>、<code>release</code>使用<code>pop_off</code>来跟踪当前CPU上lock的嵌套级别。注意，<code>push_off</code>必须在上锁之前调用，<code>pop_off</code>必须在解锁之后调用，以避免出现CPU持有锁又允许启用中断的窗口期。</p>
<p>此外，在使用<code>acquire</code>和<code>release</code>时，必须保证编译器不会重排指令。为此，可以使用<code>__sync_synchronize()</code>，告诉编译器和CPU不要跨障碍重新排序<code>load</code>或<code>store</code>指令。</p>
<h1 id="7-Scheduling"><a href="#7-Scheduling" class="headerlink" title="7 Scheduling"></a>7 Scheduling</h1><h1 id="8-File-system"><a href="#8-File-system" class="headerlink" title="8 File system"></a>8 File system</h1>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>MIT 6.S081</tag>
      </tags>
  </entry>
  <entry>
    <title>如何在电脑上操作手机</title>
    <url>/2022/8240/</url>
    <content><![CDATA[<blockquote>
<p>手机进了水，能开机，想把手机上的资料都备份一下。但是因为屏幕花了看得很吃力、不方便，所以打算在电脑上操作手机。</p>
</blockquote>
<p>参考1：<a href="https://www.zhihu.com/question/46795475/answer/869985800">如何在电脑上控制手机上所有的app软件操作？ - 张脑湿的回答 - 知乎</a></p>
<span id="more"></span>
<p>参考2：<a href="https://jingyan.baidu.com/article/08b6a591a3658955a80922ad.html">小米手机开发者模式怎么打开</a><br>参考3：<a href="https://blog.csdn.net/qq_50082325/article/details/121696514">Scrcpy投屏神器基本使用</a></p>
<h1 id="1-开启小米手机的开发者模式"><a href="#1-开启小米手机的开发者模式" class="headerlink" title="1 开启小米手机的开发者模式"></a>1 开启小米手机的开发者模式</h1><ul>
<li>设置 -&gt; 我的设备 -&gt; 全部参数 -&gt; MIUI 版本</li>
<li>连续点击“MIUI 版本”，直到弹出提示“您现在处于开发者模式”</li>
<li>设置 -&gt; 更多设置 -&gt; 开发者选项，允许“USB调试”和“USB调试（安全设置）”</li>
</ul>
<h1 id="2-下载scrcpy"><a href="#2-下载scrcpy" class="headerlink" title="2 下载scrcpy"></a>2 下载scrcpy</h1><ul>
<li>scrcpy是一款开源免费投屏控制软件，项目地址见scrcpy</li>
</ul>
<h1 id="3-将手机投屏到电脑"><a href="#3-将手机投屏到电脑" class="headerlink" title="3 将手机投屏到电脑"></a>3 将手机投屏到电脑</h1><ul>
<li>电脑开热点，然后手机连接电脑的热点，此时在电脑上可以看到手机的ip，等会需要用到这个ip。</li>
<li>手机通过USB连接到电脑，在USB配置弹窗中选择“文件传输”</li>
<li>在scrcpy目录中打开终端</li>
<li>终端中执行命令adb tcpip [端口号]，例如adb tcpip 5555</li>
<li>断开USB连接</li>
<li>终端中执行命令adb connect [ip]: [端口号]，例如adb connect 192.168.137.10: 5555</li>
<li>终端中执行命令scrcpy运行scrcpy软件</li>
</ul>
]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>tips</tag>
      </tags>
  </entry>
  <entry>
    <title>用树莓派3b搭建个人网盘</title>
    <url>/2022/15837/</url>
    <content><![CDATA[<blockquote>
<p>在淘宝上花10块钱搞了一大堆电子书，打算用树莓派3b搞个个人网盘存起来。虽然网口速度不行，但是一本书也就2MB左右，问题不大。</p>
</blockquote>
<p>参考1：<a href="https://blog.csdn.net/lz_quiet/article/details/103651730">私有云搭建-owncloud</a></p>
<span id="more"></span> 
<p>参考2：<a href="https://central.owncloud.org/t/access-denied-to-mariadb-any-suggestions/2783/3">Access denied to MariaDB. Any suggestions?</a></p>
<p>参考3：<a href="https://blog.chongyeye.com/?id=6">树莓派owncloud私有云挂载NTFS本地存储</a></p>
<h1 id="1-更换软件源"><a href="#1-更换软件源" class="headerlink" title="1 更换软件源"></a>1 更换软件源</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo nano /etc/apt/sources.list</span><br><span class="line"></span><br><span class="line"># 注释掉原来的源</span><br><span class="line"># deb http://raspbian.raspberrypi.org/raspbian/ buster main contrib non-free rpi</span><br><span class="line"># Uncomment line below then &#x27;apt-get update&#x27; to enable &#x27;apt-get source&#x27;</span><br><span class="line"># deb-src http://raspbian.raspberrypi.org/raspbian/ buster main contrib non-free rpi</span><br><span class="line"></span><br><span class="line"># 添加清华源</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ stretch main contrib non-free rpi</span><br><span class="line"></span><br><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure>

<h1 id="2-安装php"><a href="#2-安装php" class="headerlink" title="2 安装php"></a>2 安装php</h1><p>这里安装php不指明具体版本，直接安装默认版本，避免找不到对应版本的错误。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install php</span><br><span class="line">sudo apt-get install php-mysql php-zip php-xml php-intl php-mbstring php-gd php-curl</span><br></pre></td></tr></table></figure>

<h1 id="3-安装apache2"><a href="#3-安装apache2" class="headerlink" title="3 安装apache2"></a>3 安装apache2</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install apache2</span><br><span class="line"></span><br><span class="line"># 启动apache2</span><br><span class="line">systemctl restart apache2</span><br></pre></td></tr></table></figure>

<h1 id="4-安装mariadb"><a href="#4-安装mariadb" class="headerlink" title="4 安装mariadb"></a>4 安装mariadb</h1><p>不知道为什么搜索不到mysql-server的源，按<a href="https://blog.csdn.net/lz_quiet/article/details/103651730">参考1</a>装了mariadb-server。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install mariadb-server</span><br></pre></td></tr></table></figure>

<h1 id="5-数据库管理"><a href="#5-数据库管理" class="headerlink" title="5 数据库管理"></a>5 数据库管理</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo mysql -uroot -p</span><br><span class="line"></span><br><span class="line">CREATE DATABASE IF NOT EXISTS owncloud;</span><br><span class="line">GRANT ALL PRIVILEGES ON owncloud.* TO &#x27;owncloudUser&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;123123&#x27;;</span><br></pre></td></tr></table></figure>
<p>在mariadb执行完以上命令后，需要刷新再退出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FLUSH PRIVILEGES;</span><br><span class="line">exit</span><br><span class="line"></span><br><span class="line"># 退出后重启服务</span><br><span class="line">systemctl restart mariadb</span><br></pre></td></tr></table></figure>

<h1 id="6-安装owncloud"><a href="#6-安装owncloud" class="headerlink" title="6 安装owncloud"></a>6 安装owncloud</h1><p>按照<a href="https://blog.csdn.net/lz_quiet/article/details/103651730">参考1</a>执行。</p>
<h1 id="7-挂载机械硬盘"><a href="#7-挂载机械硬盘" class="headerlink" title="7 挂载机械硬盘"></a>7 挂载机械硬盘</h1><p>主要参考了<a href="https://blog.chongyeye.com/?id=6">树莓派owncloud私有云挂载NTFS本地存储</a>。以下操作针对NTFS硬盘格式。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 安装NTFS-3G</span><br><span class="line">sudo apt-get install ntfs-3g</span><br><span class="line"></span><br><span class="line"># 查看硬盘是否被检测到</span><br><span class="line">fdisk -l</span><br><span class="line"></span><br><span class="line"># 创建目录，挂载硬盘</span><br><span class="line">sudo mkdir -p /media/owncloudData</span><br><span class="line">sudo mount -t ntfs-3g  /dev/sda1 /media/owncloudData</span><br><span class="line"></span><br><span class="line"># 在owncloud中开启本地存储</span><br><span class="line">sudo nano /var/www/html/owncloud/config/config.php</span><br><span class="line"></span><br><span class="line"># 在文档中添加一句</span><br><span class="line">&#x27;files_external_allow_create_new_local&#x27; =&gt; &#x27;true&#x27;,</span><br></pre></td></tr></table></figure>
<p>之后，在owncloud的管理员setting中启用外置存储，完成。</p>
<h1 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h1><ul>
<li>树莓派直接给机械硬盘供电很吃力。</li>
<li>没有公共IP，设备只有和树莓派处于同一个子网时才能访问。</li>
</ul>
]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>树莓派</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL语句速成</title>
    <url>/2022/63903/</url>
    <content><![CDATA[<blockquote>
<p>工作中时不时要用到SQL语句，根据SQL经典50题复习下SQL语句的用法。</p>
</blockquote>
<p>参考资料：</p>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/38354000">图解SQL面试题：经典50题</a></li>
<li><a href="https://blog.csdn.net/m0_56869501/article/details/121011304">inner join 、left join 、right join 和full join的区别</a><span id="more"></span></li>
</ul>
<h1 id="1-创建表和添加数据"><a href="#1-创建表和添加数据" class="headerlink" title="1 创建表和添加数据"></a>1 创建表和添加数据</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> [tableName]([fieldName] [fieldType]...);</span><br><span class="line"><span class="comment">-- e.g.,</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> student(学号 <span class="type">VARCHAR</span>(<span class="number">255</span>), 姓名 <span class="type">VARCHAR</span>(<span class="number">255</span>), 出生日期 DATETIME(<span class="number">6</span>), 性别 <span class="type">VARCHAR</span>(<span class="number">255</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> [tableName] <span class="keyword">VALUES</span>(...);</span><br><span class="line"><span class="comment">-- e.g.,</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Student <span class="keyword">VALUES</span>(<span class="string">&#x27;01&#x27;</span> , <span class="string">&#x27;赵雷&#x27;</span> , <span class="string">&#x27;1990-01-01&#x27;</span> , <span class="string">&#x27;男&#x27;</span>);</span><br></pre></td></tr></table></figure>
<h1 id="2-查询"><a href="#2-查询" class="headerlink" title="2 查询"></a>2 查询</h1><h2 id="2-1-简单查询"><a href="#2-1-简单查询" class="headerlink" title="2.1 简单查询"></a>2.1 简单查询</h2><p>只涉及一张表的简单查询，<code>SELECT</code>指定查询目标；<code>FROM</code>指定查询对象；<code>WHERE</code>指定查询条件：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询姓王的学生的信息</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> student</span><br><span class="line"><span class="keyword">WHERE</span> 姓名 <span class="keyword">LIKE</span> <span class="string">&#x27;王%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询姓王的学生的个数</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(学号)</span><br><span class="line"><span class="keyword">FROM</span> student</span><br><span class="line"><span class="keyword">WHERE</span> 姓名 <span class="keyword">LIKE</span> <span class="string">&#x27;王%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h2 id="2-2-分组查询"><a href="#2-2-分组查询" class="headerlink" title="2.2 分组查询"></a>2.2 分组查询</h2><p><code>GROUP BY</code>指定分组字段，即根据哪个字段分组；<code>HAVING</code>对<code>GROUP BY</code>得到的结果作出限制；<code>ORDER BY</code>对最终结果进行排序，其中<code>DESC</code>为降序，<code>ASC</code>为升序；<code>LIMIT i, n</code>从查询结果中取出指定行，<code>i</code>指定从哪一行开始取数据，<code>n</code>指定取多少条数据，当<code>i=0</code>时可以省略指定<code>i</code>：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询每门课程选修的学生数</span></span><br><span class="line"><span class="keyword">SELECT</span> 课程号, <span class="built_in">COUNT</span>(学号)</span><br><span class="line"><span class="keyword">FROM</span> score</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> 课程号;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询平均成绩大于60分学生的学号和平均成绩</span></span><br><span class="line"><span class="keyword">SELECT</span> 学号, <span class="built_in">AVG</span>(成绩)</span><br><span class="line"><span class="keyword">FROM</span> score</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> 学号</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">AVG</span>(成绩)<span class="operator">&gt;</span><span class="number">60</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询总成绩排名前3的学生的学号</span></span><br><span class="line"><span class="keyword">SELECT</span> 学号</span><br><span class="line"><span class="keyword">FROM</span> score</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> 学号</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="built_in">SUM</span>(成绩) <span class="keyword">DESC</span></span><br><span class="line">LIMIT <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<h2 id="2-3-复杂查询"><a href="#2-3-复杂查询" class="headerlink" title="2.3 复杂查询"></a>2.3 复杂查询</h2><p>涉及到至少两张表的查询，也是平时工作中较常见的情况。</p>
<h3 id="2-3-1-子查询"><a href="#2-3-1-子查询" class="headerlink" title="2.3.1 子查询"></a>2.3.1 子查询</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询所有课程成绩小于60分学生的学号、姓名</span></span><br><span class="line"><span class="keyword">SELECT</span> s.学号, s.姓名</span><br><span class="line"><span class="keyword">FROM</span> student s</span><br><span class="line"><span class="keyword">WHERE</span> s.学号 <span class="keyword">IN</span> (</span><br><span class="line">  <span class="keyword">SELECT</span> 学号</span><br><span class="line">  <span class="keyword">FROM</span> score</span><br><span class="line">  <span class="keyword">GROUP</span> <span class="keyword">BY</span> 学号</span><br><span class="line">  <span class="keyword">HAVING</span> <span class="built_in">MAX</span>(成绩)<span class="operator">&lt;</span><span class="number">60</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h3 id="2-3-2-多表查询"><a href="#2-3-2-多表查询" class="headerlink" title="2.3.2 多表查询"></a>2.3.2 多表查询</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询所有学生的学号、姓名、选课数、总成绩</span></span><br><span class="line"><span class="keyword">SELECT</span> stu.学号, stu.姓名, <span class="built_in">COUNT</span>(sc.课程号) <span class="keyword">AS</span> 选课数, <span class="built_in">SUM</span>(sc.成绩) <span class="keyword">AS</span> 总成绩</span><br><span class="line"><span class="keyword">FROM</span> student <span class="keyword">AS</span> stu <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> score <span class="keyword">AS</span> sc</span><br><span class="line"><span class="keyword">ON</span> stu.学号 <span class="operator">=</span> sc.学号</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> stu.学号</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询平均成绩大于85的所有学生的学号、姓名和平均成绩</span></span><br><span class="line"><span class="keyword">SELECT</span> stu.学号, stu.姓名, <span class="built_in">AVG</span>(sc.成绩) <span class="keyword">AS</span> 平均成绩</span><br><span class="line"><span class="keyword">FROM</span> student <span class="keyword">AS</span> stu <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> score <span class="keyword">AS</span> sc</span><br><span class="line"><span class="keyword">ON</span> stu.学号 <span class="operator">=</span> sc.学号</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> stu.学号</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">AVG</span>(sc.成绩)<span class="operator">&gt;</span><span class="number">85</span>;</span><br></pre></td></tr></table></figure>
<p>多表查询涉及到表联结，包括<code>INNOR JOIN</code> &#x2F; <code>JOIN</code>，<code>LEFT JOIN</code>，<code>RIGHT JOIN</code>，<code>FULL JOIN</code>，<code>CROSS JOIN</code>：</p>
<ul>
<li><code>INNOR JOIN</code> &#x2F; <code>JOIN</code>：返回左右表完全符合匹配条件时的数据</li>
</ul>
<p><img data-src="/../images/sql/inner_join.png" alt="`INNOR JOIN`"></p>
<ul>
<li><code>LEFT JOIN</code>：基于左表去匹配右表，结果左表全部行都显示，右表判断列与左边一致才有数据</li>
</ul>
<p><img data-src="/../images/sql/left_join.png" alt="`LEFT JOIN`"></p>
<ul>
<li><code>RIGHT JOIN</code>：基于右表去匹左表，结果右表全部行都显示，左表判断列与右表一致才有数据</li>
</ul>
<p><img data-src="/../images/sql/right_join.png" alt="`RIGHT JOIN`"></p>
<ul>
<li><code>FULL JOIN</code>：左右表格的行全部都有，左右表格判断一致的在同一行，不一致的单独一行。注意MYSQL数据库不支持<code>FULL JOIN</code>，可以通过同时使用<code>LEFT JOIN</code>和<code>RIGHT JOIN</code>，再使用<code>UNION</code>合并二者结果来实现。</li>
</ul>
<p><img data-src="/../images/sql/full_join.png" alt="`FULL JOIN`"></p>
<ul>
<li><code>CROSS JOIN</code>：返回的是左右表的笛卡尔乘积</li>
</ul>
<h3 id="2-3-3-CASE表达式"><a href="#2-3-3-CASE表达式" class="headerlink" title="2.3.3 CASE表达式"></a>2.3.3 CASE表达式</h3><p>根据数据转换为不同结果：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询各分数段的人数、课程号和课程名称</span></span><br><span class="line"><span class="keyword">SELECT</span> sc.课程号, c.课程名称,</span><br><span class="line">  <span class="built_in">SUM</span>(<span class="keyword">CASE</span></span><br><span class="line">        <span class="keyword">WHEN</span> 成绩 <span class="keyword">BETWEEN</span> <span class="number">80</span> <span class="keyword">AND</span> <span class="number">100</span> <span class="keyword">THEN</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">ELSE</span> <span class="number">0</span> <span class="keyword">END</span></span><br><span class="line">      ) <span class="keyword">AS</span> <span class="string">&#x27;[100-80]&#x27;</span>,</span><br><span class="line">  <span class="built_in">SUM</span>(<span class="keyword">CASE</span></span><br><span class="line">        <span class="keyword">WHEN</span> 成绩<span class="operator">&gt;=</span><span class="number">60</span> <span class="keyword">AND</span> 成绩<span class="operator">&lt;</span><span class="number">80</span> <span class="keyword">THEN</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">ELSE</span> <span class="number">0</span> <span class="keyword">END</span></span><br><span class="line">      ) <span class="keyword">AS</span> <span class="string">&#x27;[80-60]&#x27;</span>,</span><br><span class="line">  <span class="built_in">SUM</span>(<span class="keyword">CASE</span></span><br><span class="line">        <span class="keyword">WHEN</span> 成绩<span class="operator">&lt;</span><span class="number">60</span> <span class="keyword">THEN</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">ELSE</span> <span class="number">0</span> <span class="keyword">END</span></span><br><span class="line">      ) <span class="keyword">AS</span> <span class="string">&#x27;[&lt;60]&#x27;</span></span><br><span class="line"><span class="keyword">FROM</span> score <span class="keyword">AS</span> sc <span class="keyword">JOIN</span> course <span class="keyword">AS</span> c</span><br><span class="line"><span class="keyword">ON</span> sc.课程号 <span class="operator">=</span> c.课程号</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> sc.课程号, c.课程名称;</span><br></pre></td></tr></table></figure>

<h1 id="3-修改数据和数据表"><a href="#3-修改数据和数据表" class="headerlink" title="3 修改数据和数据表"></a>3 修改数据和数据表</h1><p>基本的<code>UPDATE</code>语句由三部分组成：要更新的表，列名和它们的新值，确定要更新哪些行的过滤条件：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> [tableName]</span><br><span class="line"><span class="keyword">SET</span> [field]</span><br><span class="line"><span class="keyword">WHERE</span> [<span class="keyword">condition</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">-- e.g.,</span></span><br><span class="line"><span class="keyword">UPDATE</span> student</span><br><span class="line"><span class="keyword">SET</span> 姓名<span class="operator">=</span><span class="string">&#x27;赵五&#x27;</span></span><br><span class="line"><span class="keyword">WHERE</span> 学号<span class="operator">=</span><span class="string">&#x27;11&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h1 id="4-删除数据和数据表"><a href="#4-删除数据和数据表" class="headerlink" title="4 删除数据和数据表"></a>4 删除数据和数据表</h1><h2 id="4-1-DELETE"><a href="#4-1-DELETE" class="headerlink" title="4.1 DELETE"></a>4.1 DELETE</h2><p>用于删除表中的特定数据：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> [tableName] <span class="keyword">WHERE</span> [codition];</span><br></pre></td></tr></table></figure>

<h2 id="4-2-DROP"><a href="#4-2-DROP" class="headerlink" title="4.2 DROP"></a>4.2 DROP</h2><p>删除整张表，包括表数据和表结构：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> [tableName];</span><br></pre></td></tr></table></figure>

<h2 id="4-3-TRUNCATE"><a href="#4-3-TRUNCATE" class="headerlink" title="4.3 TRUNCATE"></a>4.3 TRUNCATE</h2><p>清空表中数据：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> [tableName];</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> [查询目标]    <span class="comment">-- 指定要输出的结果</span></span><br><span class="line"><span class="keyword">FROM</span> [查询对象]      <span class="comment">-- 指定查哪些表，可以使用表联结：LEFT JOIN/INNER JOIN等</span></span><br><span class="line"><span class="keyword">WHERE</span> [查询条件]     <span class="comment">-- 可以使用子查询：IN/NOT IN</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> [分组字段]</span><br><span class="line"><span class="keyword">HAVING</span> [分组条件]    <span class="comment">-- 去掉不符合条件的分组，可以使用子查询：IN/NOT IN</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> [排序字段]  <span class="comment">-- 对分组结果进行排序</span></span><br><span class="line">LIMIT [i, n];</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Vim初学笔记（基于vimtutor）</title>
    <url>/2022/19295/</url>
    <content><![CDATA[<blockquote>
<p>之前一直觉得vim难用，远远比不上vscode之类的编辑器好用。最近在学Java后端开发，敲代码的时候居然感觉vim编辑器好像是方便一些，所以打算再复习一下。以下笔记仅供查阅。</p>
</blockquote>
<span id="more"></span>
<h1 id="1-基本操作"><a href="#1-基本操作" class="headerlink" title="1 基本操作"></a>1 基本操作</h1><h2 id="1-1-移动光标"><a href="#1-1-移动光标" class="headerlink" title="1.1 移动光标"></a>1.1 移动光标</h2><ul>
<li>h 左移</li>
<li>l 右移</li>
<li>j 下移</li>
<li>k 上移</li>
</ul>
<h2 id="1-2-删除、插入和添加"><a href="#1-2-删除、插入和添加" class="headerlink" title="1.2 删除、插入和添加"></a>1.2 删除、插入和添加</h2><ul>
<li>x 删除</li>
<li>a 在光标后插入</li>
<li>A 行尾插入</li>
<li>i 在光标前插入</li>
<li>I 在行首插入</li>
</ul>
<h1 id="2-组合命令"><a href="#2-组合命令" class="headerlink" title="2 组合命令"></a>2 组合命令</h1><h2 id="2-1-删除操作和相关命令"><a href="#2-1-删除操作和相关命令" class="headerlink" title="2.1 删除操作和相关命令"></a>2.1 删除操作和相关命令</h2><ul>
<li>de 删除当前字符到单词末尾</li>
<li>dw 删除当前光标到下个单词之前的内容 </li>
<li>d$ 删除本行光标之后的所有字符（包括光标指向的字符）</li>
<li>dd 删除整行（实际上相当于剪切）</li>
</ul>
<h2 id="2-2-关于命令和对象"><a href="#2-2-关于命令和对象" class="headerlink" title="2.2 关于命令和对象"></a>2.2 关于命令和对象</h2><ul>
<li>许多改变文本的命令都是由一个操作和一个对象构成：例如<code>d</code>表示delete，<code>w</code>表示<code>word</code>。</li>
<li>在命令前加数字可以表示该命令重复的次数，例如<code>2dw</code>表示执行两次<code>dw</code>。</li>
</ul>
<h2 id="2-4-撤销类命令"><a href="#2-4-撤销类命令" class="headerlink" title="2.4 撤销类命令"></a>2.4 撤销类命令</h2><ul>
<li>u 撤销最后执行的命令</li>
<li>U 撤销对整行的修改</li>
</ul>
<h1 id="3-剪贴和修改"><a href="#3-剪贴和修改" class="headerlink" title="3 剪贴和修改"></a>3 剪贴和修改</h1><h2 id="3-1-剪贴"><a href="#3-1-剪贴" class="headerlink" title="3.1 剪贴"></a>3.1 剪贴</h2><ul>
<li>dd 剪切整行</li>
<li>p 粘贴</li>
</ul>
<h2 id="3-2-修改"><a href="#3-2-修改" class="headerlink" title="3.2 修改"></a>3.2 修改</h2><ul>
<li>r 替换光标所在位置的字符</li>
<li>cw 修改至单词末尾的文本</li>
<li>ce 同上</li>
<li>c$ 修改至行末的文本</li>
</ul>
<h1 id="4-定位、搜索和替换"><a href="#4-定位、搜索和替换" class="headerlink" title="4 定位、搜索和替换"></a>4 定位、搜索和替换</h1><h2 id="4-1-定位及文件状态"><a href="#4-1-定位及文件状态" class="headerlink" title="4.1 定位及文件状态"></a>4.1 定位及文件状态</h2><ul>
<li>&lt;ctrl&gt;+g&#x2F;G 显示当前编辑的文件名和光标所在位置</li>
<li>G 跳转到文件最后一行</li>
<li>gg 跳转到文件第一行</li>
<li>#n G 跳转到第n行</li>
</ul>
<h2 id="4-2-搜索"><a href="#4-2-搜索" class="headerlink" title="4.2 搜索"></a>4.2 搜索</h2><ul>
<li>&#x2F;[target] 从前往后找</li>
<li>?[target] 从后往前找</li>
<li>n 下一个</li>
<li>N 上一个</li>
<li>% 将光标放在括号处，查找匹配的另一半括号</li>
</ul>
<h2 id="4-3-替换"><a href="#4-3-替换" class="headerlink" title="4.3 替换"></a>4.3 替换</h2><ul>
<li>:s&#x2F;[old]&#x2F;[new] 只替换第一个匹配到的串</li>
<li>:s&#x2F;[old]&#x2F;[new]&#x2F;g 替换全行的匹配串</li>
<li>:#,#s&#x2F;[old]&#x2F;[new]&#x2F;g 替换指定两行之间出现的每个匹配串，其中#,#代表的是替换操作的若干行中首尾两行的行号。</li>
<li>:%s&#x2F;[old]&#x2F;[new]&#x2F;g 替换整个文件中的每个匹配串</li>
<li>:%s&#x2F;[old]&#x2F;[new]&#x2F;gc 找到个文件中的每个匹配串，并且对每个匹配串提示是否进行替换</li>
</ul>
<h1 id="5-执行外部命令和保存"><a href="#5-执行外部命令和保存" class="headerlink" title="5 执行外部命令和保存"></a>5 执行外部命令和保存</h1><h2 id="5-1-执行外部命令"><a href="#5-1-执行外部命令" class="headerlink" title="5.1 执行外部命令"></a>5.1 执行外部命令</h2><ul>
<li>:![command] 可以执行外部命令，如<code>:!ls</code></li>
</ul>
<h2 id="5-2-保存和导入"><a href="#5-2-保存和导入" class="headerlink" title="5.2 保存和导入"></a>5.2 保存和导入</h2><ul>
<li>:w [filename] 保存文件</li>
<li>v进入visual模式，移动光标可以高亮部分文本，<code>:w [filename]</code>选择性保存文件</li>
<li>:r [filename] 导入指定文件</li>
</ul>
<h1 id="6-更多的编辑命令"><a href="#6-更多的编辑命令" class="headerlink" title="6 更多的编辑命令"></a>6 更多的编辑命令</h1><h2 id="6-1-插入"><a href="#6-1-插入" class="headerlink" title="6.1 插入"></a>6.1 插入</h2><ul>
<li>o 在光标的下方打开新的一行，并进入插入模式</li>
<li>R 可连续替换多个字符</li>
</ul>
<h2 id="6-2-复制"><a href="#6-2-复制" class="headerlink" title="6.2 复制"></a>6.2 复制</h2><ul>
<li>y 复制文本，使用这条命令要先用v进入visual模式，然后按y选中部分文本，最后按p粘贴文本</li>
</ul>
<h2 id="6-3-设置类命令"><a href="#6-3-设置类命令" class="headerlink" title="6.3 设置类命令"></a>6.3 设置类命令</h2><ul>
<li>:set ic 忽略搜索target的大小写</li>
<li>:set hls is 高亮搜索，输入的同时显示效果</li>
<li>:set noic 禁用忽略大小写</li>
<li>:nohlsearch 移除匹配项的高亮显示</li>
<li>&#x2F;[target]\c 仅在一次查找时忽略大小写</li>
</ul>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Vim</tag>
      </tags>
  </entry>
</search>
