<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hexo + NexT 搭建个人博客</title>
    <url>/2022/63969/</url>
    <content><![CDATA[<h1 id="1-主要安装步骤"><a href="#1-主要安装步骤" class="headerlink" title="1 主要安装步骤"></a>1 主要安装步骤</h1><h2 id="1-1-创建github仓库"><a href="#1-1-创建github仓库" class="headerlink" title="1.1 创建github仓库"></a>1.1 创建github仓库</h2><p>仓库命名：[username].github.io</p>
<h2 id="1-2-安装博客框架Hexo"><a href="#1-2-安装博客框架Hexo" class="headerlink" title="1.2 安装博客框架Hexo"></a>1.2 安装博客框架Hexo</h2><p><a href="https://hexo.io/zh-cn/docs/">Hexo安装文档</a>。在站点配置文件中，deploy字段修改为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: git@github.com:[username]/[username].github.io.git</span><br><span class="line">  branch: main</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>url字段修改为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://[username].github.io</span><br></pre></td></tr></table></figure>

<p>根据需要修改博客信息：author，title，subtitle等字段。</p>
<h2 id="1-3-下载博客主题NexT"><a href="#1-3-下载博客主题NexT" class="headerlink" title="1.3 下载博客主题NexT"></a>1.3 下载博客主题NexT</h2><p><a href="https://github.com/theme-next/hexo-theme-next">NexT安装</a><br>下载完成后，打开站点配置文件，找到theme字段，并将其值更改为next。在官方文档里有对使用NexT的教程，虽然这个教程似乎很久没更新过，但是基本步骤还是差不多的。</p>
<p>完成以上步骤后，hexo cl &amp;&amp; hexo g &amp;&amp; hexo s三连生成页面并在本地预览，hexo d将页面发布到[username].github.io.</p>
<h1 id="2-功能配置"><a href="#2-功能配置" class="headerlink" title="2 功能配置"></a>2 功能配置</h1><p>以下为可选功能，不是必须。</p>
<h2 id="2-1-评论功能"><a href="#2-1-评论功能" class="headerlink" title="2.1 评论功能"></a>2.1 评论功能</h2><p>gitment似乎不能用了，但是好在NexT已经支持gitalk，问题不大。教程详见gitalk评论系统。</p>
<h2 id="2-2-站内搜索功能"><a href="#2-2-站内搜索功能" class="headerlink" title="2.2 站内搜索功能"></a>2.2 站内搜索功能</h2><p>详见<a href="https://theme-next.iissnan.com/third-party-services.html#search-system">第三方服务集成</a>中Local Search部分。</p>
<h2 id="2-3-数学公式"><a href="#2-3-数学公式" class="headerlink" title="2.3 数学公式"></a>2.3 数学公式</h2><p><a href="https://blog.csdn.net/ssjdoudou/article/details/103318019">Hexo-next主题支持数学公式</a></p>
<h2 id="2-4-版权信息"><a href="#2-4-版权信息" class="headerlink" title="2.4 版权信息"></a>2.4 版权信息</h2><p>在<code>主题配置文件</code>中修改：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">creative_commons:</span><br><span class="line">  license: by-nc-sa</span><br><span class="line">  sidebar: false</span><br><span class="line">  post: true</span><br></pre></td></tr></table></figure>

<h2 id="2-5-永久链接"><a href="#2-5-永久链接" class="headerlink" title="2.5 永久链接"></a>2.5 永久链接</h2><p><a href="https://www.jianshu.com/p/c7de2ae59975">Hexo-abbrlink生成唯一永久文章链接</a>。但是按照这个教程修改站点配置文件的permalink字段好像没用，我按下面修改是有用的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">permalink: :year/:abbrlink/</span><br></pre></td></tr></table></figure>

<h2 id="2-6-统计信息"><a href="#2-6-统计信息" class="headerlink" title="2.6 统计信息"></a>2.6 统计信息</h2><p>我用的是不蒜子，优势是不需要注册，提供博客阅读量和访问人数数据。在主题配置文件里找到busuanzi字段，直接修改即可。</p>
<h2 id="2-7-搜索引擎抓取"><a href="#2-7-搜索引擎抓取" class="headerlink" title="2.7 搜索引擎抓取"></a>2.7 搜索引擎抓取</h2><p>可以参考这篇<a href="https://blog.csdn.net/fzhhsa/article/details/89839885">hexo个人博客收录谷歌</a>。</p>
]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>NexT</tag>
      </tags>
  </entry>
  <entry>
    <title>Git初学笔记</title>
    <url>/2022/22760/</url>
    <content><![CDATA[<blockquote>
<p>为了便于日常的查询和使用，将一些命令总结这篇博客中。</p>
</blockquote>
<p>用可视化的方法学习git：<a href="https://learngitbranching.js.org/?locale=zh_CN">https://learngitbranching.js.org/?locale=zh_CN</a></p>
<span id="more"></span>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">branch可以指代当前分支的最新commit</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">commit^ 表示某个commit的父节点</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">~n表示当前节点的n代父母节点</span></span><br><span class="line"></span><br><span class="line">git help &lt;command&gt;                 # 获取关于某个命令的帮助</span><br><span class="line">git status                         # 输出当前分支的信息</span><br><span class="line">git log                            # 显示git的历史纪录</span><br><span class="line">git diff &lt;file&gt;                    # 输出当前文件与暂存区中文件的区别</span><br><span class="line"></span><br><span class="line">git init                           # 将当前文件夹创建为git repo</span><br><span class="line">git add &lt;file&gt;                     # 将文件添加到暂存区</span><br><span class="line">git commit -m &lt;msg&gt;                # 提交当前分支至remote repo，只有在暂存区中的文件才会被commit</span><br><span class="line">git branch &lt;branch&gt;                # 创建新分支</span><br><span class="line">git branch -f &lt;branch&gt; &lt;commit&gt;    # 将某个分支强制移动到指定的commit节点</span><br><span class="line"></span><br><span class="line">git checkout &lt;branch&gt;              # 切换当前分支</span><br><span class="line">git checkout -b &lt;branch&gt;           # 切换当前分支，若分支不存在则创建</span><br><span class="line"></span><br><span class="line">git reset HEAD^                    # 所有内容回退到HEAD的父节点</span><br><span class="line">git reset HEAD^ &lt;filename&gt;         # 将某个文件回退到HEAD的父节点版本</span><br><span class="line">git reset &lt;commit&gt;                 # 所有内容回退到指定的commit节点</span><br><span class="line"></span><br><span class="line">git revert &lt;commit&gt;                # 撤销指定的commit</span><br><span class="line"></span><br><span class="line">git merge &lt;branch&gt;                 # 将指定分支与当前分支合并，产生一个新的commit节点</span><br><span class="line">git cherry-pick &lt;commit&gt;...        # 将指定commit节点复制到当前分支下</span><br><span class="line">git rebase -i &lt;commit&gt;             # 打开交互页面，显示哪些commit节点会放到指定commit节点下</span><br><span class="line"></span><br><span class="line">git tag &lt;tagname&gt; &lt;commit&gt;         # 在指定commit节点创建tag，可以使用tag指代commit</span><br><span class="line">git describe                       # 返回当前节点的最近tag、距离和节点hash</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">local</span> repo有个“remote repo”，用于描述remote repo的情况（上次同步后的状态，不一定是最新的）</span></span><br><span class="line">git fetch &lt;remote&gt;                 # 更新remote repo的所有分支</span><br><span class="line">git fetch &lt;remote&gt; &lt;branch&gt;        # 更新remote repo的指定分支</span><br><span class="line"></span><br><span class="line">git pull &lt;remote&gt;                  # 获取remote repo中与当前分支对应的分支，并与当前分支合并，等价于：</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">git fetch &lt;remote&gt;</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">git merge origin/&lt;current-branch&gt;</span></span><br><span class="line">git pull &lt;remote&gt; &lt;branch&gt;</span><br><span class="line"></span><br><span class="line">git push &lt;remote&gt; &lt;src-local-branch&gt;:&lt;dst-remote-branch&gt;       # 将本地分支推送到远程</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果不指明src，则是删除对应的remote-branch</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果不指明dst，则是更新到remote repo对应的分支</span></span><br><span class="line"></span><br><span class="line">git fetch &lt;remote&gt; &lt;src-local-branch&gt;:&lt;dst-remote-branch&gt;      # 将远程分支拉取到本地</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果不指明src，则是在<span class="built_in">local</span> repo增加对应的分支</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果不指明dst，则是拉取到<span class="built_in">local</span> repo对应的分支</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>MIT 6.S081 Lab1 Utilities</title>
    <url>/2022/35075/</url>
    <content><![CDATA[<p>参考资料：</p>
<ul>
<li>课程官方网页：<a href="https://pdos.csail.mit.edu/6.S081/2021/index.html">https://pdos.csail.mit.edu/6.S081/2021/index.html</a></li>
<li>教材：<a href="https://pdos.csail.mit.edu/6.S081/2021/xv6/book-riscv-rev2.pdf">https://pdos.csail.mit.edu/6.S081/2021/xv6/book-riscv-rev2.pdf</a></li>
<li>参考代码：<a href="http://doraemonzzz.com/tags/6-S081/">http://doraemonzzz.com/tags/6-S081/</a>，以下代码主要参考该工作。<span id="more"></span></li>
</ul>
<h1 id="0-配置实验环境"><a href="#0-配置实验环境" class="headerlink" title="0 配置实验环境"></a>0 配置实验环境</h1><ol>
<li>根据<a href="https://pdos.csail.mit.edu/6.S081/2021/tools.html">Tools Used in 6.S081</a>安装环境。</li>
<li>安装好后，在shell运行<code>make qemu</code>进入qemu环境。</li>
<li>同时按住<code>ctrl+a</code>然后松开这两个键，再按<code>x</code>可以退出qemu环境。</li>
</ol>
<h1 id="1-Boot-xv6-easy"><a href="#1-Boot-xv6-easy" class="headerlink" title="1 Boot xv6 (easy)"></a>1 Boot xv6 (easy)</h1><p>根据实验指示逐步执行即可：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> git://g.csail.mit.edu/xv6-labs-2021</span><br><span class="line">Cloning into <span class="string">&#x27;xv6-labs-2021&#x27;</span>...</span><br><span class="line">...</span><br><span class="line">$ <span class="built_in">cd</span> xv6-labs-2021</span><br><span class="line">$ git checkout util  <span class="comment"># 这里我的默认分支下是空的，需要签出分支后才能看到代码</span></span><br><span class="line">$ make qemu <span class="comment"># 进入qemu环境，并启动xv6系统</span></span><br></pre></td></tr></table></figure>

<h1 id="2-sleep-easy"><a href="#2-sleep-easy" class="headerlink" title="2 sleep (easy)"></a>2 sleep (easy)</h1><p>按照xv6教材和实验指示逐步执行即可。</p>
<h1 id="3-pingpong-easy"><a href="#3-pingpong-easy" class="headerlink" title="3 pingpong (easy)"></a>3 pingpong (easy)</h1><p>这个实验的意思是，child进程通过pipe给parent进程发一个字符，parent进程输出字符。同样的，parent进程也要给child进程发一个字符，child进程输出字符。</p>
<p>要注意的是，父子进程是通过同一个pipe通信的，因此要避免两个进程同时读或者同时写，并且parent必须等child进程结束后才能读，否则可能读到自己写的字符，因此需要先让parent进程写、child进程读，然后反过来：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> p[<span class="number">2</span>];</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">2</span>];</span><br><span class="line">    pipe(p);</span><br><span class="line">    <span class="type">int</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123; <span class="comment">// child</span></span><br><span class="line">        <span class="keyword">if</span> (read(p[<span class="number">0</span>], buf, <span class="number">1</span>) != <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Can&#x27;t read from parent!\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        close(p[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">1</span>, <span class="string">&quot;child receive: %c\n&quot;</span>, buf[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">1</span>, <span class="string">&quot;%d: received ping\n&quot;</span>, getpid());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (write(p[<span class="number">1</span>], <span class="string">&quot;b&quot;</span>, <span class="number">1</span>) != <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Can&#x27;t write to parent!\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        close(p[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;  <span class="comment">// parent</span></span><br><span class="line">        <span class="keyword">if</span> (write(p[<span class="number">1</span>], <span class="string">&quot;a&quot;</span>, <span class="number">1</span>) != <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Can&#x27;t write to child!\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        close(p[<span class="number">1</span>]);  </span><br><span class="line"></span><br><span class="line">        wait(<span class="number">0</span>); <span class="comment">// 如果不等待子进程结束，可能读的是&quot;a&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (read(p[<span class="number">0</span>], buf, <span class="number">1</span>) != <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Can&#x27;t read from child!\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        close(p[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">1</span>, <span class="string">&quot;parent receive: %c\n&quot;</span>, buf[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">1</span>, <span class="string">&quot;%d: received pong\n&quot;</span>, getpid());</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4-primes-moderate-x2F-hard"><a href="#4-primes-moderate-x2F-hard" class="headerlink" title="4 primes (moderate)&#x2F;(hard)"></a>4 primes (moderate)&#x2F;(hard)</h1><p>这个题的意思写一个并发版本的素数筛子，令多个筛子可以同时筛数。仔细看下图，这个图说明：如果某个数字在上一个筛子中没有被筛掉，并且这个数字是当前剩余数字中最小的那个，那么该数字是prime，需要输出，并且作为一个新的筛子。为了并行实现，可以通过fork产生子进程，父进程根据当前筛子向子进程输入数据，子进程则负责新的剩余数据，也就是说，实现父进程写和子进程读同时进行：<br><img data-src="/../images/sieve.gif"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">primes</span><span class="params">(<span class="type">int</span> *fd)</span> &#123;</span><br><span class="line">    <span class="type">int</span> p, d;</span><br><span class="line">    close(fd[<span class="number">1</span>]);  <span class="comment">// 由于fork时也复制了文件描述符，因此不需要的文件描述符应该关闭，以避免不可控的事情</span></span><br><span class="line">    <span class="keyword">if</span> (read(fd[<span class="number">0</span>], (<span class="type">void</span>*)&amp;p, <span class="keyword">sizeof</span>(p)) != <span class="keyword">sizeof</span>(p)) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Read fail!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;prime %d\n&quot;</span>, p);</span><br><span class="line">    <span class="keyword">if</span> (read(fd[<span class="number">0</span>], (<span class="type">void</span>*) &amp;d, <span class="keyword">sizeof</span>(d))) &#123;</span><br><span class="line">        <span class="type">int</span> fd1[<span class="number">2</span>];</span><br><span class="line">        pipe(fd1);</span><br><span class="line">        <span class="keyword">if</span> (fork() == <span class="number">0</span>) &#123;</span><br><span class="line">            primes(fd1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            close(fd1[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (d % p != <span class="number">0</span>) &#123;</span><br><span class="line">                    write(fd1[<span class="number">1</span>], (<span class="type">void</span>*) &amp;d, <span class="keyword">sizeof</span>(d));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">while</span> (read(fd[<span class="number">0</span>], (<span class="type">void</span>*)&amp;d, <span class="keyword">sizeof</span>(d)));</span><br><span class="line">            close(fd[<span class="number">0</span>]);</span><br><span class="line">            close(fd1[<span class="number">1</span>]);</span><br><span class="line">            wait(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> fd[<span class="number">2</span>];  <span class="comment">// fd[0]: read fd, fd[1]: write fd</span></span><br><span class="line">    <span class="type">int</span> start = <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> end = <span class="number">35</span>;</span><br><span class="line">    pipe(fd);</span><br><span class="line">    <span class="keyword">if</span> (fork() == <span class="number">0</span>) &#123;  <span class="comment">// 子进程</span></span><br><span class="line">        primes(fd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;  <span class="comment">// 父进程</span></span><br><span class="line">        close(fd[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt;= end; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (write(fd[<span class="number">1</span>], (<span class="type">void</span>*) &amp;i, <span class="keyword">sizeof</span>(i)) != <span class="number">4</span>) &#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Write fail!\n&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        close(fd[<span class="number">1</span>]);</span><br><span class="line">        wait(<span class="number">0</span>);  <span class="comment">// 防止出现孤儿进程</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="5-find-moderate"><a href="#5-find-moderate" class="headerlink" title="5 find (moderate)"></a>5 find (moderate)</h1><p>这个题要求实现给定目录和目标文件，输出给定目录及其子目录下的所有目标文件。仔细阅读<code>user/ls.c</code>：<code>fmtname</code>函数的功能是将输入<code>path</code>中最后一个<code>&#39;\&#39;</code>之后的内容截取出来，<code>ls</code>函数先将<code>fd</code>定向到<code>path</code>，用于后续读取<code>path</code>对应的文件或目录，<code>fstat</code>函数是读入fd指向文件的更具体的info，然后判断指向文件是什么类型，并进一步处理。对比<code>ls</code>和<code>find</code>的区别，可以发现<code>find</code>多了一个目标文件，并且<code>find</code>的<code>path</code>一定是一个目录。因此，<code>find</code>多了是否为目录的判断，以及文件名比对：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/fs.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span>*</span><br><span class="line"><span class="title function_">fmtname</span><span class="params">(<span class="type">char</span> *path)</span>  <span class="comment">// 获取path中最后一个‘/’之后的内容</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">char</span> buf[DIRSIZ+<span class="number">1</span>];</span><br><span class="line">  <span class="type">char</span> *p;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Find first character after last slash.</span></span><br><span class="line">  <span class="keyword">for</span>(p=path+<span class="built_in">strlen</span>(path); p &gt;= path &amp;&amp; *p != <span class="string">&#x27;/&#x27;</span>; p--)</span><br><span class="line">    ;</span><br><span class="line">  p++;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return blank-padded name.</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">strlen</span>(p) &gt;= DIRSIZ)</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">  memmove(buf, p, <span class="built_in">strlen</span>(p));</span><br><span class="line">  <span class="built_in">memset</span>(buf+<span class="built_in">strlen</span>(p), <span class="string">&#x27; &#x27;</span>, DIRSIZ-<span class="built_in">strlen</span>(p));</span><br><span class="line">  <span class="keyword">return</span> buf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">find</span><span class="params">(<span class="type">char</span> *path, <span class="type">char</span> *target_file)</span> &#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">512</span>], *p;</span><br><span class="line">  <span class="type">int</span> fd;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> <span class="title">de</span>;</span>  <span class="comment">// 目录信息</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span>  <span class="comment">// </span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((fd = open(path, <span class="number">0</span>)) &lt; <span class="number">0</span>)&#123;  <span class="comment">// 将fd定向到path</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;find: cannot open %s\n&quot;</span>, path);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(fstat(fd, &amp;st) &lt; <span class="number">0</span>)&#123;  <span class="comment">// 读入fd指向的文件info</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;find: cannot stat %s\n&quot;</span>, path);</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (read(fd, &amp;de, <span class="keyword">sizeof</span>(de)) != <span class="keyword">sizeof</span>(de)) &#123;  <span class="comment">// 判断能否读入fd指向的文件</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;find, cannot read %s\n&quot;</span>, path);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span>(st.type)&#123;</span><br><span class="line">  <span class="keyword">case</span> T_FILE:</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(de.name, target_file) == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%s/%s\n&quot;</span>, path, target_file);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> T_DIR:</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strlen</span>(path) + <span class="number">1</span> + DIRSIZ + <span class="number">1</span> &gt; <span class="keyword">sizeof</span> buf)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;ls: path too long\n&quot;</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">strcpy</span>(buf, path);</span><br><span class="line">    p = buf+<span class="built_in">strlen</span>(buf);</span><br><span class="line">    *p++ = <span class="string">&#x27;/&#x27;</span>;  <span class="comment">// buf下一层文路径</span></span><br><span class="line">    <span class="keyword">while</span>(read(fd, &amp;de, <span class="keyword">sizeof</span>(de)) == <span class="keyword">sizeof</span>(de))&#123;  <span class="comment">// 读取fd指向的文件</span></span><br><span class="line">      <span class="keyword">if</span>((de.inum == <span class="number">0</span>) || (<span class="built_in">strcmp</span>(de.name, <span class="string">&quot;.&quot;</span>) == <span class="number">0</span>) || (<span class="built_in">strcmp</span>(de.name, <span class="string">&quot;..&quot;</span>) == <span class="number">0</span>))&#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      memmove(p, de.name, DIRSIZ);</span><br><span class="line">      p[DIRSIZ] = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span>(stat(buf, &amp;st) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;find: cannot stat %s\n&quot;</span>, buf);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (st.type == T_FILE) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(de.name, target_file) == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, buf);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (st.type == T_DIR) find(buf, target_file);  <span class="comment">// 如果当前是目录，需要递归比对</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  close(fd);    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Usage: find [dir] [target_file]&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        find(argv[<span class="number">1</span>], argv[<span class="number">2</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="6-xargs-moderate"><a href="#6-xargs-moderate" class="headerlink" title="6 xargs (moderate)"></a>6 xargs (moderate)</h1><p>这个实验要求实现的功能是实现<code>xargs</code>命令的简化版本。主要思路是先根据<code>\n</code>确定一条命令，然后根据空格分辨出命令和它的参数。本题比较麻烦的是指针和字符数组的处理，需要特别小心：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/param.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLEN 1024</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">copy</span><span class="params">(<span class="type">char</span> **p1, <span class="type">char</span> *p2)</span> &#123;</span><br><span class="line">    *p1 = <span class="built_in">malloc</span>(<span class="built_in">strlen</span>(p2) + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(*p1, p2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">readLine</span><span class="params">(<span class="type">char</span> **pars, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="type">char</span> buf[MAXLEN];</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (read(<span class="number">0</span>, buf + j, <span class="number">1</span>)) &#123;  <span class="comment">// 每次读取一个字符，直到遇到\n，即读取一条命令</span></span><br><span class="line">        <span class="keyword">if</span> (buf[j] == <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">            buf[j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ++j;</span><br><span class="line">        <span class="keyword">if</span> (j == MAXLEN) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Parameters are too long!\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;  <span class="comment">// 没有读取到内容，即已经到pars的结尾</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (k &lt; j) &#123;  <span class="comment">// 一条命令可能有多个参数，每个参数保存在pars[i]中</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt; MAXARG) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Too much parameters!\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> ((k &lt; j) &amp;&amp; (buf[k] == <span class="string">&#x27; &#x27;</span>)) &#123;  <span class="comment">// 去掉命令的前导空格</span></span><br><span class="line">            ++k;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> l = k;</span><br><span class="line">        <span class="keyword">while</span> ((k &lt; j) &amp;&amp; (buf[k] != <span class="string">&#x27; &#x27;</span>)) &#123;</span><br><span class="line">            ++k;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        buf[k++] = <span class="number">0</span>;</span><br><span class="line">        copy(&amp;pars[i], buf + l);</span><br><span class="line">        ++i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Please enter more parameters!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *pars[MAXARG];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; argc; ++i) &#123;</span><br><span class="line">        copy(&amp;pars[i<span class="number">-1</span>], argv[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> e;</span><br><span class="line">    <span class="keyword">while</span> ((e = readLine(pars, argc - <span class="number">1</span>)) != <span class="number">-1</span>) &#123;</span><br><span class="line">        pars[e] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (fork() == <span class="number">0</span>) &#123;  <span class="comment">// 子进程执行命令</span></span><br><span class="line">            exec(pars[<span class="number">0</span>], pars);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            wait(<span class="number">0</span>);  <span class="comment">// 父进程等待子进程完成</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>MIT 6.S081</tag>
      </tags>
  </entry>
  <entry>
    <title>MIT 6.S081 Lab2 System Calls</title>
    <url>/2022/35594/</url>
    <content><![CDATA[<p>参考资料：</p>
<ul>
<li>课程官方网页：<a href="https://pdos.csail.mit.edu/6.S081/2021/index.html">https://pdos.csail.mit.edu/6.S081/2021/index.html</a></li>
<li>教材：<a href="https://pdos.csail.mit.edu/6.S081/2021/xv6/book-riscv-rev2.pdf">https://pdos.csail.mit.edu/6.S081/2021/xv6/book-riscv-rev2.pdf</a></li>
<li>参考代码：<a href="https://github.com/PKUFlyingPig/MIT6.S081-2020fall">https://github.com/PKUFlyingPig/MIT6.S081-2020fall</a></li>
</ul>
<span id="more"></span>

<h1 id="1-System-call-tracing-moderate"><a href="#1-System-call-tracing-moderate" class="headerlink" title="1 System call tracing (moderate)"></a>1 System call tracing (moderate)</h1><h2 id="1-1-题意"><a href="#1-1-题意" class="headerlink" title="1.1 题意"></a>1.1 题意</h2><p>这个题目的意思是，修改xv6系统的kernel，使得可以用<code>trace</code>跟踪系统调用输出<code>process id</code>，<code>system call name</code>和<code>return value</code>，并且<code>trace</code>调用需要保证可以跟踪调用进程及其子进程。<code>trace.c</code>已经实现了在user-level实现了trace的功能，我们只需要在kernel-level补充相关实现。</p>
<h2 id="1-2-实现步骤"><a href="#1-2-实现步骤" class="headerlink" title="1.2 实现步骤"></a>1.2 实现步骤</h2><p>根据题目提示，首先是在<code>user/user.h</code>增加trace函数的声明，在<code>user/usys.pl</code>增加trace函数的stub,<code>kernel/syscall.h</code>增加syscall number，这是为了使得xv6系统能通过编译：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// `user/user.h`</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">trace</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// user/usys.pl</span></span><br><span class="line">entry(<span class="string">&quot;trace&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// kernel/syscall.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_trace  22</span></span><br></pre></td></tr></table></figure>
<p>后两步的目的在于，将trace函数声明为syscall函数，使得<code>trace.c</code>的第17行调用trace函数时会自动调用系统函数。</p>
<p>然而，trace函数实际上在kernel-level并没有被实现。为了实现这一目标，根据题目提示，<code>kernel/proc.h</code>的进程结构中需要增加一个变量mask，用于记住调用trace syscall时所需的参数。<code>kernel/sysproc.c</code>中需要实现sys_trace()函数，该函数可以用于获取用户输入的变量mask，将其保存到进程中：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/proc.h</span></span><br><span class="line"><span class="type">int</span> mask;                    <span class="comment">// trace mask</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// kernel/sysproc.c</span></span><br><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_trace</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="type">int</span> mask;</span><br><span class="line">  <span class="keyword">if</span>(argint(<span class="number">0</span>, &amp;mask) &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  myproc()-&gt;mask = mask;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时，由于trace需要能跟踪子进程，因此需要修改<code>kernel/proc.c</code>中的fork()函数，使得trace mask可以复制到child process中：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/proc.c</span></span><br><span class="line">np-&gt;mask = p-&gt;mask;  <span class="comment">// copy mask from parent to child</span></span><br></pre></td></tr></table></figure>

<p>上述步骤实际上是实现trace的准备工作，为了实际实现trace功能，需要修改<code>kernel/syscall.c</code>的syscall()函数，用于打印trace的输出：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/syscall.c</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_trace</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="title function_">uint64</span> <span class="params">(*syscalls[])</span><span class="params">(<span class="type">void</span>)</span> = &#123;</span><br><span class="line">  ...</span><br><span class="line">  [SYS_trace]   sys_trace,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* sysnames[] = &#123;</span><br><span class="line">  <span class="string">&quot;fork&quot;</span>, <span class="string">&quot;exit&quot;</span>, <span class="string">&quot;wait&quot;</span>, <span class="string">&quot;pipe&quot;</span>, <span class="string">&quot;read&quot;</span>, <span class="string">&quot;kill&quot;</span>, <span class="string">&quot;exec&quot;</span>, <span class="string">&quot;fstat&quot;</span>, </span><br><span class="line">  <span class="string">&quot;chdir&quot;</span>, <span class="string">&quot;dup&quot;</span>, <span class="string">&quot;getpid&quot;</span>, <span class="string">&quot;sbrk&quot;</span>, <span class="string">&quot;sleep&quot;</span>, <span class="string">&quot;uptime&quot;</span>, <span class="string">&quot;open&quot;</span>, <span class="string">&quot;write&quot;</span>, </span><br><span class="line">  <span class="string">&quot;mknod&quot;</span>, <span class="string">&quot;unlink&quot;</span>, <span class="string">&quot;link&quot;</span>, <span class="string">&quot;mkdir&quot;</span>,<span class="string">&quot;close&quot;</span>,<span class="string">&quot;trace&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">syscall</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> num;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  num = p-&gt;trapframe-&gt;a7;  <span class="comment">// syscall number</span></span><br><span class="line">  <span class="keyword">if</span>(num &gt; <span class="number">0</span> &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123;</span><br><span class="line">    p-&gt;trapframe-&gt;a0 = syscalls[num]();  <span class="comment">// return value</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (p-&gt;mask &amp; (<span class="number">1</span> &lt;&lt; num))  <span class="comment">// syscall必须在mask中指定才能有输出</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d: syscall %s -&gt; %d\n&quot;</span>, p-&gt;pid, sysnames[num<span class="number">-1</span>], p-&gt;trapframe-&gt;a0);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %s: unknown sys call %d\n&quot;</span>,</span><br><span class="line">            p-&gt;pid, p-&gt;name, num);</span><br><span class="line">    p-&gt;trapframe-&gt;a0 = <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="1-3-总结"><a href="#1-3-总结" class="headerlink" title="1.3 总结"></a>1.3 总结</h1><ul>
<li><blockquote>
<p>在最开始，我们设置了一个perl脚本，Makefile会调用<code>user/usys.pl</code>，生成一个<code>user/usys.S</code>，这个文件就像一个switch语句一样，当你使用一个系统调用的时候，比如read，OS会查询<code>user/usys.S</code>中对应的标签target来执行相应的语句。</p>
</blockquote>
</li>
<li>注意看<code>user/usys.pl</code>中<code>print &quot; li a7, SYS_$&#123;name&#125;\n&quot;;</code>把被调用syscall名称放入寄存器a7，而在<code>kernel/syscall.c</code>中，syscall的编号也是在寄存器a7中获取的。</li>
<li>syscall的通用注册和实现流程：<ul>
<li><code>user/user.h</code>中声明该函数</li>
<li><code>user/usys.pl</code>中增加对应的syscall name</li>
<li><code>kernel/syscall.h</code>中增加syscall number</li>
<li><code>kernel/proc.h</code>的<strong>process</strong>结构中增加该syscall需要的变量</li>
<li><code>kernel/sysproc.c</code>中实现sys_*函数，该函数用于处理调用sys_*后需要做的事情</li>
<li><code>kernel/proc.c</code>中可以处理sys_*涉及到的变量在<strong>process</strong>中的使用</li>
<li><code>kernel/syscall.c</code>中增加指向新的系统函数的指针，并且可以修改<code>syscall</code>函数以配合sys_*的功能</li>
</ul>
</li>
<li>myproc可以用于获取当前正在运行的process</li>
</ul>
<h1 id="2-Sysinfo-moderate"><a href="#2-Sysinfo-moderate" class="headerlink" title="2 Sysinfo (moderate)"></a>2 Sysinfo (moderate)</h1><h2 id="2-1-题意"><a href="#2-1-题意" class="headerlink" title="2.1 题意"></a>2.1 题意</h2><p>本题要求增加系统调用<code>sysinfo</code>用于收集running system的信息，该系统调用函数使用一个指向<code>struct sysinfo</code>的指针作为输入。结构体字段包括freemem字段应该设置为空闲内存的字节数，nproc字段应该设置成状态不是UNUSED的进程数。</p>
<h2 id="2-2-实现步骤"><a href="#2-2-实现步骤" class="headerlink" title="2.2 实现步骤"></a>2.2 实现步骤</h2><p>根据题目提示，首先类似1.2注册sysinfo这个系统调用，并且需要在<code>user/user.h</code>中预声明<code>struct sysinfo</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// `user/user.h`</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sysinfo</span>;</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sysinfo</span><span class="params">(<span class="keyword">struct</span> sysinfo*)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// user/usys.pl</span></span><br><span class="line">entry(<span class="string">&quot;sysinfo&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// kernel/syscall.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_sysinfo  23</span></span><br></pre></td></tr></table></figure>

<p>然后，在<code>kernel/sysproc.c</code>中实现sys_sysinfo函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/sysproc.c</span></span><br><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_sysinfo</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 p;  <span class="comment">// pointer to struct sysinfo address</span></span><br><span class="line">  <span class="keyword">if</span>(argaddr(<span class="number">0</span>, &amp;p) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sysinfo</span> <span class="title">info</span>;</span></span><br><span class="line">  info.freemem = freemem();  <span class="comment">// get free memory</span></span><br><span class="line">  info.nproc = nproc();  <span class="comment">// get used proc</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span>* <span class="title">curproc</span> =</span> myproc();</span><br><span class="line">  <span class="comment">// copyout: curprocess pagetable, dst, src, size</span></span><br><span class="line">  <span class="keyword">if</span> (copyout(curproc-&gt;pagetable, p, (<span class="type">char</span>*)&amp;info, <span class="keyword">sizeof</span>(info)) &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据题目提示，freemem函数在<code>kernel/kalloc.c</code>中实现，nproc函数在<code>kernel/proc.c</code>中实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/kalloc.c</span></span><br><span class="line">uint64 <span class="title function_">freemem</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line">  uint64 sz = <span class="number">0</span>;</span><br><span class="line">  acquire(&amp;kmem.lock);</span><br><span class="line">  r = kmem.freelist;  <span class="comment">// freelist是第一个未被使用的页的地址</span></span><br><span class="line">  <span class="keyword">while</span> (r) &#123;</span><br><span class="line">    sz += <span class="number">1</span>;</span><br><span class="line">    r = r -&gt; next;</span><br><span class="line">  &#125;</span><br><span class="line">  sz = sz * PGSIZE;</span><br><span class="line">  release(&amp;kmem.lock);</span><br><span class="line">  <span class="keyword">return</span> sz;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// kernel/proc.c</span></span><br><span class="line">uint64 <span class="title function_">nproc</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  uint64 cnt = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NPROC; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (proc[i].state != UNUSED) ++cnt;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-3-总结"><a href="#2-3-总结" class="headerlink" title="2.3 总结"></a>2.3 总结</h2><p>无</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>MIT 6.S081</tag>
      </tags>
  </entry>
  <entry>
    <title>如何在电脑上操作手机</title>
    <url>/2022/8240/</url>
    <content><![CDATA[<blockquote>
<p>手机进了水，能开机，想把手机上的资料都备份一下。但是因为屏幕花了看得很吃力、不方便，所以打算在电脑上操作手机。</p>
</blockquote>
<p>参考1：<a href="https://www.zhihu.com/question/46795475/answer/869985800">如何在电脑上控制手机上所有的app软件操作？ - 张脑湿的回答 - 知乎</a></p>
<span id="more"></span>
<p>参考2：<a href="https://jingyan.baidu.com/article/08b6a591a3658955a80922ad.html">小米手机开发者模式怎么打开</a><br>参考3：<a href="https://blog.csdn.net/qq_50082325/article/details/121696514">Scrcpy投屏神器基本使用</a></p>
<h1 id="1-开启小米手机的开发者模式"><a href="#1-开启小米手机的开发者模式" class="headerlink" title="1 开启小米手机的开发者模式"></a>1 开启小米手机的开发者模式</h1><ul>
<li>设置 -&gt; 我的设备 -&gt; 全部参数 -&gt; MIUI 版本</li>
<li>连续点击“MIUI 版本”，直到弹出提示“您现在处于开发者模式”</li>
<li>设置 -&gt; 更多设置 -&gt; 开发者选项，允许“USB调试”和“USB调试（安全设置）”</li>
</ul>
<h1 id="2-下载scrcpy"><a href="#2-下载scrcpy" class="headerlink" title="2 下载scrcpy"></a>2 下载scrcpy</h1><ul>
<li>scrcpy是一款开源免费投屏控制软件，项目地址见scrcpy</li>
</ul>
<h1 id="3-将手机投屏到电脑"><a href="#3-将手机投屏到电脑" class="headerlink" title="3 将手机投屏到电脑"></a>3 将手机投屏到电脑</h1><ul>
<li>电脑开热点，然后手机连接电脑的热点，此时在电脑上可以看到手机的ip，等会需要用到这个ip。</li>
<li>手机通过USB连接到电脑，在USB配置弹窗中选择“文件传输”</li>
<li>在scrcpy目录中打开终端</li>
<li>终端中执行命令adb tcpip [端口号]，例如adb tcpip 5555</li>
<li>断开USB连接</li>
<li>终端中执行命令adb connect [ip]: [端口号]，例如adb connect 192.168.137.10: 5555</li>
<li>终端中执行命令scrcpy运行scrcpy软件</li>
</ul>
]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>tips</tag>
      </tags>
  </entry>
  <entry>
    <title>用树莓派3b搭建个人网盘</title>
    <url>/2022/15837/</url>
    <content><![CDATA[<blockquote>
<p>在淘宝上花10块钱搞了一大堆电子书，打算用树莓派3b搞个个人网盘存起来。虽然网口速度不行，但是一本书也就2MB左右，问题不大。</p>
</blockquote>
<p>参考1：<a href="https://blog.csdn.net/lz_quiet/article/details/103651730">私有云搭建-owncloud</a></p>
<span id="more"></span> 
<p>参考2：<a href="https://central.owncloud.org/t/access-denied-to-mariadb-any-suggestions/2783/3">Access denied to MariaDB. Any suggestions?</a></p>
<p>参考3：<a href="https://blog.chongyeye.com/?id=6">树莓派owncloud私有云挂载NTFS本地存储</a></p>
<h1 id="1-更换软件源"><a href="#1-更换软件源" class="headerlink" title="1 更换软件源"></a>1 更换软件源</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo nano /etc/apt/sources.list</span><br><span class="line"></span><br><span class="line"># 注释掉原来的源</span><br><span class="line"># deb http://raspbian.raspberrypi.org/raspbian/ buster main contrib non-free rpi</span><br><span class="line"># Uncomment line below then &#x27;apt-get update&#x27; to enable &#x27;apt-get source&#x27;</span><br><span class="line"># deb-src http://raspbian.raspberrypi.org/raspbian/ buster main contrib non-free rpi</span><br><span class="line"></span><br><span class="line"># 添加清华源</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ stretch main contrib non-free rpi</span><br><span class="line"></span><br><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure>

<h1 id="2-安装php"><a href="#2-安装php" class="headerlink" title="2 安装php"></a>2 安装php</h1><p>这里安装php不指明具体版本，直接安装默认版本，避免找不到对应版本的错误。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install php</span><br><span class="line">sudo apt-get install php-mysql php-zip php-xml php-intl php-mbstring php-gd php-curl</span><br></pre></td></tr></table></figure>

<h1 id="3-安装apache2"><a href="#3-安装apache2" class="headerlink" title="3 安装apache2"></a>3 安装apache2</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install apache2</span><br><span class="line"></span><br><span class="line"># 启动apache2</span><br><span class="line">systemctl restart apache2</span><br></pre></td></tr></table></figure>

<h1 id="4-安装mariadb"><a href="#4-安装mariadb" class="headerlink" title="4 安装mariadb"></a>4 安装mariadb</h1><p>不知道为什么搜索不到mysql-server的源，按<a href="https://blog.csdn.net/lz_quiet/article/details/103651730">参考1</a>装了mariadb-server。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install mariadb-server</span><br></pre></td></tr></table></figure>

<h1 id="5-数据库管理"><a href="#5-数据库管理" class="headerlink" title="5 数据库管理"></a>5 数据库管理</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo mysql -uroot -p</span><br><span class="line"></span><br><span class="line">CREATE DATABASE IF NOT EXISTS owncloud;</span><br><span class="line">GRANT ALL PRIVILEGES ON owncloud.* TO &#x27;owncloudUser&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;123123&#x27;;</span><br></pre></td></tr></table></figure>
<p>在mariadb执行完以上命令后，需要刷新再退出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FLUSH PRIVILEGES;</span><br><span class="line">exit</span><br><span class="line"></span><br><span class="line"># 退出后重启服务</span><br><span class="line">systemctl restart mariadb</span><br></pre></td></tr></table></figure>

<h1 id="6-安装owncloud"><a href="#6-安装owncloud" class="headerlink" title="6 安装owncloud"></a>6 安装owncloud</h1><p>按照<a href="https://blog.csdn.net/lz_quiet/article/details/103651730">参考1</a>执行。</p>
<h1 id="7-挂载机械硬盘"><a href="#7-挂载机械硬盘" class="headerlink" title="7 挂载机械硬盘"></a>7 挂载机械硬盘</h1><p>主要参考了<a href="https://blog.chongyeye.com/?id=6">树莓派owncloud私有云挂载NTFS本地存储</a>。以下操作针对NTFS硬盘格式。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 安装NTFS-3G</span><br><span class="line">sudo apt-get install ntfs-3g</span><br><span class="line"></span><br><span class="line"># 查看硬盘是否被检测到</span><br><span class="line">fdisk -l</span><br><span class="line"></span><br><span class="line"># 创建目录，挂载硬盘</span><br><span class="line">sudo mkdir -p /media/owncloudData</span><br><span class="line">sudo mount -t ntfs-3g  /dev/sda1 /media/owncloudData</span><br><span class="line"></span><br><span class="line"># 在owncloud中开启本地存储</span><br><span class="line">sudo nano /var/www/html/owncloud/config/config.php</span><br><span class="line"></span><br><span class="line"># 在文档中添加一句</span><br><span class="line">&#x27;files_external_allow_create_new_local&#x27; =&gt; &#x27;true&#x27;,</span><br></pre></td></tr></table></figure>
<p>之后，在owncloud的管理员setting中启用外置存储，完成。</p>
<h1 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h1><ul>
<li>树莓派直接给机械硬盘供电很吃力。</li>
<li>没有公共IP，设备只有和树莓派处于同一个子网时才能访问。</li>
</ul>
]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>树莓派</tag>
      </tags>
  </entry>
  <entry>
    <title>Vim常用命令（基于vimtutor）</title>
    <url>/2022/19295/</url>
    <content><![CDATA[<blockquote>
<p>之前一直觉得vim难用，远远比不上vscode之类的编辑好用。最近在学Java后端开发，敲代码的时候居然感觉vim编辑器好像是方便一些，所以打算再复习一下。以下笔记仅供查阅。</p>
</blockquote>
<h1 id="1-基本操作"><a href="#1-基本操作" class="headerlink" title="1 基本操作"></a>1 基本操作</h1><h2 id="1-1-移动光标"><a href="#1-1-移动光标" class="headerlink" title="1.1 移动光标"></a>1.1 移动光标</h2><ul>
<li>h 左移</li>
<li>l 右移</li>
<li>j 下移</li>
<li>k 上移</li>
</ul>
<h2 id="1-2-删除、插入和添加"><a href="#1-2-删除、插入和添加" class="headerlink" title="1.2 删除、插入和添加"></a>1.2 删除、插入和添加</h2><ul>
<li>x 删除</li>
<li>a 在光标后插入</li>
<li>A 行尾插入</li>
<li>i 在光标前插入</li>
<li>I 在行首插入</li>
</ul>
<h1 id="2-组合命令"><a href="#2-组合命令" class="headerlink" title="2 组合命令"></a>2 组合命令</h1><h2 id="2-1-删除操作和相关命令"><a href="#2-1-删除操作和相关命令" class="headerlink" title="2.1 删除操作和相关命令"></a>2.1 删除操作和相关命令</h2><ul>
<li>de 删除当前字符到单词末尾</li>
<li>dw 删除当前光标到下个单词之前的内容 </li>
<li>d$ 删除本行光标之后的所有字符（包括光标指向的字符）</li>
<li>dd 删除整行（实际上相当于剪切）</li>
</ul>
<h2 id="2-2-关于命令和对象"><a href="#2-2-关于命令和对象" class="headerlink" title="2.2 关于命令和对象"></a>2.2 关于命令和对象</h2><ul>
<li>许多改变文本的命令都是由一个操作和一个对象构成：例如<code>d</code>表示delete，<code>w</code>表示<code>word</code>。</li>
<li>在命令前加数字可以表示该命令重复的次数，例如<code>2dw</code>表示执行两次<code>dw</code>。</li>
</ul>
<h2 id="2-4-撤销类命令"><a href="#2-4-撤销类命令" class="headerlink" title="2.4 撤销类命令"></a>2.4 撤销类命令</h2><ul>
<li>u 撤销最后执行的命令</li>
<li>U 撤销对整行的修改</li>
</ul>
<h1 id="3-剪贴和修改"><a href="#3-剪贴和修改" class="headerlink" title="3 剪贴和修改"></a>3 剪贴和修改</h1><h2 id="3-1-剪贴"><a href="#3-1-剪贴" class="headerlink" title="3.1 剪贴"></a>3.1 剪贴</h2><ul>
<li>dd 剪切整行</li>
<li>p 粘贴</li>
</ul>
<h2 id="3-2-修改"><a href="#3-2-修改" class="headerlink" title="3.2 修改"></a>3.2 修改</h2><ul>
<li>r 替换光标所在位置的字符</li>
<li>cw 修改至单词末尾的文本</li>
<li>ce 同上</li>
<li>c$ 修改至行末的文本</li>
</ul>
<h1 id="4-定位、搜索和替换"><a href="#4-定位、搜索和替换" class="headerlink" title="4 定位、搜索和替换"></a>4 定位、搜索和替换</h1><h2 id="4-1-定位及文件状态"><a href="#4-1-定位及文件状态" class="headerlink" title="4.1 定位及文件状态"></a>4.1 定位及文件状态</h2><ul>
<li>&lt;ctrl&gt;+g&#x2F;G 显示当前编辑的文件名和光标所在位置</li>
<li>G 跳转到文件最后一行</li>
<li>gg 跳转到文件第一行</li>
<li>#n G 跳转到第n行</li>
</ul>
<h2 id="4-2-搜索"><a href="#4-2-搜索" class="headerlink" title="4.2 搜索"></a>4.2 搜索</h2><ul>
<li>&#x2F;[target] 从前往后找</li>
<li>?[target] 从后往前找</li>
<li>n 下一个</li>
<li>N 上一个</li>
<li>% 将光标放在括号处，查找匹配的另一半括号</li>
</ul>
<h2 id="4-3-替换"><a href="#4-3-替换" class="headerlink" title="4.3 替换"></a>4.3 替换</h2><ul>
<li>:s&#x2F;[old]&#x2F;[new] 只替换第一个匹配到的串</li>
<li>:s&#x2F;[old]&#x2F;[new]&#x2F;g 替换全行的匹配串</li>
<li>:#,#s&#x2F;[old]&#x2F;[new]&#x2F;g 替换指定两行之间出现的每个匹配串，其中#,#代表的是替换操作的若干行中首尾两行的行号。</li>
<li>:%s&#x2F;[old]&#x2F;[new]&#x2F;g 替换整个文件中的每个匹配串</li>
<li>:%s&#x2F;[old]&#x2F;[new]&#x2F;gc 找到个文件中的每个匹配串，并且对每个匹配串提示是否进行替换</li>
</ul>
<h1 id="5-执行外部命令和保存"><a href="#5-执行外部命令和保存" class="headerlink" title="5 执行外部命令和保存"></a>5 执行外部命令和保存</h1><h2 id="5-1-执行外部命令"><a href="#5-1-执行外部命令" class="headerlink" title="5.1 执行外部命令"></a>5.1 执行外部命令</h2><ul>
<li>:![command] 可以执行外部命令，如<code>:!ls</code></li>
</ul>
<h2 id="5-2-保存和导入"><a href="#5-2-保存和导入" class="headerlink" title="5.2 保存和导入"></a>5.2 保存和导入</h2><ul>
<li>:w [filename] 保存文件</li>
<li>v进入visual模式，移动光标可以高亮部分文本，<code>:w [filename]</code>选择性保存文件</li>
<li>:r [filename] 导入指定文件</li>
</ul>
<h1 id="6-更多的编辑命令"><a href="#6-更多的编辑命令" class="headerlink" title="6 更多的编辑命令"></a>6 更多的编辑命令</h1><h2 id="6-1-插入"><a href="#6-1-插入" class="headerlink" title="6.1 插入"></a>6.1 插入</h2><ul>
<li>o 在光标的下方打开新的一行，并进入插入模式</li>
<li>R 可连续替换多个字符</li>
</ul>
<h2 id="6-2-复制"><a href="#6-2-复制" class="headerlink" title="6.2 复制"></a>6.2 复制</h2><ul>
<li>y 复制文本，使用这条命令要先用v进入visual模式，然后按y选中部分文本，最后按p粘贴文本</li>
</ul>
<h2 id="6-3-设置类命令"><a href="#6-3-设置类命令" class="headerlink" title="6.3 设置类命令"></a>6.3 设置类命令</h2><ul>
<li>:set ic 忽略搜索target的大小写</li>
<li>:set hls is 高亮搜索，输入的同时显示效果</li>
<li>:set noic 禁用忽略大小写</li>
<li>:nohlsearch 移除匹配项的高亮显示</li>
<li>&#x2F;[target]\c 仅在一次查找时忽略大小写</li>
</ul>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Vim</tag>
      </tags>
  </entry>
</search>
