<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hexo + NexT 搭建个人博客</title>
    <url>/2022/63969/</url>
    <content><![CDATA[<h1 id="1-主要安装步骤"><a href="#1-主要安装步骤" class="headerlink" title="1 主要安装步骤"></a>1 主要安装步骤</h1><h2 id="1-1-创建github仓库"><a href="#1-1-创建github仓库" class="headerlink" title="1.1 创建github仓库"></a>1.1 创建github仓库</h2><p>仓库命名：[username].github.io</p>
<h2 id="1-2-安装博客框架Hexo"><a href="#1-2-安装博客框架Hexo" class="headerlink" title="1.2 安装博客框架Hexo"></a>1.2 安装博客框架Hexo</h2><p><a href="https://hexo.io/zh-cn/docs/">Hexo安装文档</a>。在站点配置文件中，deploy字段修改为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: git@github.com:[username]/[username].github.io.git</span><br><span class="line">  branch: main</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>url字段修改为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://[username].github.io</span><br></pre></td></tr></table></figure>

<p>根据需要修改博客信息：author，title，subtitle等字段。</p>
<h2 id="1-3-下载博客主题NexT"><a href="#1-3-下载博客主题NexT" class="headerlink" title="1.3 下载博客主题NexT"></a>1.3 下载博客主题NexT</h2><p><a href="https://github.com/theme-next/hexo-theme-next">NexT安装</a><br>下载完成后，打开站点配置文件，找到theme字段，并将其值更改为next。在官方文档里有对使用NexT的教程，虽然这个教程似乎很久没更新过，但是基本步骤还是差不多的。</p>
<p>完成以上步骤后，<code>hexo cl &amp;&amp; hexo g &amp;&amp; hexo s</code>三连生成页面并在本地预览，<code>hexo d</code>将页面发布到[username].github.io.</p>
<h1 id="2-功能配置"><a href="#2-功能配置" class="headerlink" title="2 功能配置"></a>2 功能配置</h1><p>以下为可选功能，不是必须。</p>
<h2 id="2-1-评论功能"><a href="#2-1-评论功能" class="headerlink" title="2.1 评论功能"></a>2.1 评论功能</h2><p>gitment似乎不能用了，但是好在NexT已经支持gitalk，问题不大。教程详见<a href="https://hexo-next.readthedocs.io/zh_CN/latest/next/advanced/gitalk-%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F/">gitalk评论系统</a>。</p>
<h2 id="2-2-站内搜索功能"><a href="#2-2-站内搜索功能" class="headerlink" title="2.2 站内搜索功能"></a>2.2 站内搜索功能</h2><p>详见<a href="https://theme-next.iissnan.com/third-party-services.html#search-system">第三方服务集成</a>中Local Search部分。</p>
<h2 id="2-3-数学公式"><a href="#2-3-数学公式" class="headerlink" title="2.3 数学公式"></a>2.3 数学公式</h2><p><a href="https://blog.csdn.net/ssjdoudou/article/details/103318019">Hexo-next主题支持数学公式</a></p>
<h2 id="2-4-版权信息"><a href="#2-4-版权信息" class="headerlink" title="2.4 版权信息"></a>2.4 版权信息</h2><p>在<code>主题配置文件</code>中修改：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">creative_commons:</span><br><span class="line">  license: by-nc-sa</span><br><span class="line">  sidebar: false</span><br><span class="line">  post: true</span><br></pre></td></tr></table></figure>

<h2 id="2-5-永久链接"><a href="#2-5-永久链接" class="headerlink" title="2.5 永久链接"></a>2.5 永久链接</h2><p><a href="https://www.jianshu.com/p/c7de2ae59975">Hexo-abbrlink生成唯一永久文章链接</a>。但是按照这个教程修改站点配置文件的permalink字段好像没用，我按下面修改是有用的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">permalink: :year/:abbrlink/</span><br></pre></td></tr></table></figure>

<h2 id="2-6-统计信息"><a href="#2-6-统计信息" class="headerlink" title="2.6 统计信息"></a>2.6 统计信息</h2><p>我用的是不蒜子，优势是不需要注册，提供博客阅读量和访问人数数据。在主题配置文件里找到busuanzi字段，直接修改即可。</p>
<h2 id="2-7-搜索引擎抓取"><a href="#2-7-搜索引擎抓取" class="headerlink" title="2.7 搜索引擎抓取"></a>2.7 搜索引擎抓取</h2><p>可以参考这篇<a href="https://blog.csdn.net/fzhhsa/article/details/89839885">hexo个人博客收录谷歌</a>。</p>
]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>NexT</tag>
      </tags>
  </entry>
  <entry>
    <title>gdb初学笔记</title>
    <url>/2022/56307/</url>
    <content><![CDATA[<blockquote>
<p>读书时学过怎么用gdb，但是因为不常用很快忘光了。由于某些环境下只能用gdb调试，所以现在再次学习总结一下gdb。</p>
</blockquote>
<span id="more"></span>
<h1 id="0-gcc编译命令"><a href="#0-gcc编译命令" class="headerlink" title="0 gcc编译命令"></a>0 gcc编译命令</h1><p>从源代码hello.c到可执行文件hello，需要经过hello.i、hello.s、hello.o，最后才得到hello：</p>
<p><img data-src="/../images/compile/compile.png"></p>
<p>gcc编译命令的格式：<code>gcc [flags] &lt;source files&gt; -o &lt;output file&gt;</code></p>
<ul>
<li>预处理，处理源代码中的预处理命令，包括头文件展开、宏定义替换、条件编译等：<br><code>gcc -E hello.c –o hello.i</code></li>
<li>编译，将预处理得到的文件翻译转换为汇编代码文件：<code>gcc -S hello.i -o hello.s</code></li>
<li>汇编，将汇编代码翻译成机器码得到目标文件：<code>gcc -c hello.s -o hello.o</code></li>
<li>链接，将多个目标文件和所需的库文件链接成可执行文件：<code>gcc hello.o -o hello</code><br>上述编译过程可以简化为：<code>gcc hello.c -o hello</code></li>
</ul>
<h1 id="1-启动gdb"><a href="#1-启动gdb" class="headerlink" title="1 启动gdb"></a>1 启动gdb</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -g hello.c -o hello  # 使用-g编译，生成可执行文件</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动方法1</span></span><br><span class="line">gdb hello</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动方法2</span></span><br><span class="line">gdb</span><br><span class="line">... # 进入调试器</span><br><span class="line">(gdb) file hello</span><br></pre></td></tr></table></figure>

<h1 id="2-使用gdb调试"><a href="#2-使用gdb调试" class="headerlink" title="2 使用gdb调试"></a>2 使用gdb调试</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(gdb) help &lt;command&gt;  # 获取&lt;command&gt;的用法</span><br><span class="line"></span><br><span class="line">(gdb) set args [...]  # 设置main运行参数；后面的参数为空，相当于撤销参数设置</span><br><span class="line"></span><br><span class="line">(gdb) run [...]     # 运行程序，[...]里放置参数（如果为空则用args的参数）。没有断点会运行至出错或者结束</span><br><span class="line">(gdb) start [...]   # 启动程序，[...]里放置参数，在main函数的第一行语句处停止执行</span><br><span class="line"></span><br><span class="line">(gdb) break &lt;location&gt;                 # 打断点，程序运行到断点后暂停运行，e.g.,</span><br><span class="line">(gdb) break 10</span><br><span class="line">(gdb) break hello.c:10</span><br><span class="line">(gdb) break func</span><br><span class="line">(gdb) break hello.c:func</span><br><span class="line"></span><br><span class="line">(gdb) break &lt;location&gt; if &lt;condition&gt;  # 条件断点，只有在条件满足时才在该点break</span><br><span class="line">(gdb) condtion &lt;N&gt; [condition]         # 修改breakpoint N的条件，不指定condition则删除对应的条件</span><br><span class="line"></span><br><span class="line">(gdb) disable breakpoint &lt;N&gt;  # 禁用断点N</span><br><span class="line">(gdb) ignore &lt;N&gt; &lt;COUNT&gt;      # 指定断点N失效的次数</span><br><span class="line">(gdb) enable breakpoint &lt;N&gt;   # 允许断点N</span><br><span class="line">(gdb) delete breakpoint &lt;N&gt;   # 删除断点N</span><br><span class="line">(gdb) delete                  # 删除所有断点</span><br><span class="line"></span><br><span class="line">(gdb) step [N]      # 单步执行，如果遇到函数调用，则进入函数中，N指定执行的代码行数</span><br><span class="line">(gdb) next [N]      # 单步执行，遇到函数执行不进入函数中，N指定执行的代码行数</span><br><span class="line">(gdb) continue [N]  # 继续运行，直到遇到下一个断点。N指定跳过遇到断点的次数</span><br><span class="line">(gdb) finish        # 继续运行直到当前函数执行完成</span><br><span class="line"></span><br><span class="line">(gdb) backtrace [N]  # 输出当前调试环境中所有的栈帧信息，N指定打印最里（正数）或最外（负数）N个栈帧的信息</span><br><span class="line">(gdb) backtrace </span><br><span class="line"></span><br><span class="line">(gdb) frame &lt;N&gt;  # 输出栈帧N的信息</span><br><span class="line"></span><br><span class="line">(gdb) print &lt;EXPRESSION&gt;        # 输出表达式的值</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">e.g.,</span></span><br><span class="line">(gdb) print array[0]@2          # 查看第0，1个元素</span><br><span class="line">(gdb) print file::variable</span><br><span class="line">(gdb) print function::variable</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(gdb) watch &lt;EXPRESSION&gt;   # 监控表达式，一旦变化程序就停止运行</span><br><span class="line">(gdb) rwatch &lt;EXPRESSION&gt;  # 只要读取目标表达式的值，程序就停止运行</span><br><span class="line">(gdb) awatch &lt;EXPRESSION&gt;  # 只要读取目标表达式的值或者改变值的操作，程序就会停止运行</span><br><span class="line">(gdb) watch -l &lt;ADDRESS&gt;   # 监控地址，一旦该地址对应的内存发生变化，程序就停止运行</span><br><span class="line"></span><br><span class="line">(gdb) info breakpoint &lt;N&gt;     # 查看断点N的信息</span><br><span class="line">(gdb) info reg                # 查看寄存器的信息</span><br><span class="line"></span><br><span class="line">(gdb) list &lt;LINENUM&gt;               # 列出指定行数上下十行的代码</span><br><span class="line">(gdb) list &lt;LINENUM1&gt;, &lt;LINENUM2&gt;  # 列出指定行数之间的代码</span><br><span class="line">(gdb) list &lt;FUNCTION&gt;              # 查看特定函数的代码</span><br></pre></td></tr></table></figure>

<h1 id="3-在qemu中使用gdb"><a href="#3-在qemu中使用gdb" class="headerlink" title="3 在qemu中使用gdb"></a>3 在qemu中使用gdb</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># step 1.</span></span><br><span class="line">make qemu-gdb</span><br><span class="line"><span class="comment"># qemu-system-riscv64 -machine virt -bios none -kernel kernel/kernel -m 128M -smp 3 -nographic -drive file=fs.img,if=none,format=raw,id=x0 -device virtio-blk-device,drive=x0,bus=virtio-mmio-bus.0 -S -gdb tcp::26000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># step 2. 根据提示，在另一个shell中运行gdb</span></span><br><span class="line">riscv64-unknown-elf-gdb  <span class="comment"># xv6的ISA是riscv，所以需要指定riscv调试器。如果默认是riscv调试器，直接输 gdb 也可以</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># step 3. 加载可执行文件，e.g.,</span></span><br><span class="line">(gdb) file user/_[execname]</span><br><span class="line">(gdb) file kernel/kernel</span><br><span class="line"></span><br><span class="line"><span class="comment"># step 4. 通过gdb程序的远程调试功能和qemu的远程gdb调试接口来调试程序</span></span><br><span class="line">(gdb) target remote localhost:26000</span><br><span class="line"></span><br><span class="line"><span class="comment"># step 5. 打断点</span></span><br><span class="line">(gdb) b [...]</span><br><span class="line"></span><br><span class="line"><span class="comment"># step 6. 在第一个shell中运行虚拟机</span></span><br><span class="line"><span class="comment"># 第一个shell的虚拟机运行到打了断点的部分时，第二个shell的gdb会输出对应信息。</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>gdb</tag>
      </tags>
  </entry>
  <entry>
    <title>Git初学笔记</title>
    <url>/2022/22760/</url>
    <content><![CDATA[<blockquote>
<p>为了便于日常的查询和使用，将一些git命令总结这篇博客中。</p>
</blockquote>
<p>参考资料：</p>
<ul>
<li>用可视化的方法学习git：<a href="https://learngitbranching.js.org/?locale=zh_CN">https://learngitbranching.js.org/?locale=zh_CN</a></li>
<li>官方文档：<a href="https://git-scm.com/docs/gittutorial">https://git-scm.com/docs/gittutorial</a></li>
</ul>
<span id="more"></span>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">branch可以指代当前分支的最新commit</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">commit^ 表示某个commit的父节点</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">~n表示当前节点的n代父母节点</span></span><br><span class="line"></span><br><span class="line">git help &lt;command&gt;                 # 获取关于某个命令的帮助</span><br><span class="line">git status                         # 输出当前分支的信息</span><br><span class="line">git log                            # 显示git的历史纪录</span><br><span class="line">git diff &lt;file&gt;                    # 输出当前文件与暂存区中文件的区别</span><br><span class="line"></span><br><span class="line">git init                           # 将当前文件夹创建为git repo</span><br><span class="line">git add &lt;file&gt;                     # 将文件添加到暂存区</span><br><span class="line">git commit -m &lt;msg&gt;                # 提交当前分支至remote repo，只有在暂存区中的文件才会被commit</span><br><span class="line">git branch &lt;branch&gt;                # 创建新分支</span><br><span class="line">git branch -f &lt;branch&gt; &lt;commit&gt;    # 将某个分支强制移动到指定的commit节点</span><br><span class="line"></span><br><span class="line">git checkout &lt;branch&gt;              # 切换当前分支</span><br><span class="line">git checkout -b &lt;branch&gt;           # 切换当前分支，若分支不存在则创建</span><br><span class="line"></span><br><span class="line">git reset HEAD^                    # 所有内容回退到HEAD的父节点</span><br><span class="line">git reset HEAD^ &lt;filename&gt;         # 将某个文件回退到HEAD的父节点版本</span><br><span class="line">git reset &lt;commit&gt;                 # 所有内容回退到指定的commit节点</span><br><span class="line"></span><br><span class="line">git revert &lt;commit&gt;                # 撤销指定的commit</span><br><span class="line"></span><br><span class="line">git merge &lt;branch&gt;                 # 将指定分支与当前分支合并，产生一个新的commit节点</span><br><span class="line">git cherry-pick &lt;commit&gt;...        # 将指定commit节点复制到当前分支下</span><br><span class="line">git rebase -i &lt;commit&gt;             # 打开交互页面，显示哪些commit节点会放到指定commit节点下</span><br><span class="line"></span><br><span class="line">git tag &lt;tagname&gt; &lt;commit&gt;         # 在指定commit节点创建tag，可以使用tag指代commit</span><br><span class="line">git describe                       # 返回当前节点的最近tag、距离和节点hash</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">local</span> repo有个“remote repo”，用于描述remote repo的情况（上次同步后的状态，不一定是最新的）</span></span><br><span class="line">git fetch &lt;remote&gt;                 # 更新remote repo的所有分支</span><br><span class="line">git fetch &lt;remote&gt; &lt;branch&gt;        # 更新remote repo的指定分支</span><br><span class="line"></span><br><span class="line">git pull &lt;remote&gt;                  # 获取remote repo中与当前分支对应的分支，并与当前分支合并，等价于：</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">git fetch &lt;remote&gt;</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">git merge origin/&lt;current-branch&gt;</span></span><br><span class="line">git pull &lt;remote&gt; &lt;branch&gt;</span><br><span class="line"></span><br><span class="line">git push &lt;remote&gt; &lt;src-local-branch&gt;:&lt;dst-remote-branch&gt;       # 将本地分支推送到远程</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果不指明src，则是删除对应的remote-branch</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果不指明dst，则是更新到remote repo对应的分支</span></span><br><span class="line"></span><br><span class="line">git fetch &lt;remote&gt; &lt;src-local-branch&gt;:&lt;dst-remote-branch&gt;      # 将远程分支拉取到本地</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果不指明src，则是在<span class="built_in">local</span> repo增加对应的分支</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果不指明dst，则是拉取到<span class="built_in">local</span> repo对应的分支</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>makefile初学笔记</title>
    <url>/2022/60804/</url>
    <content><![CDATA[<p>参考资料：</p>
<ul>
<li><a href="https://makefiletutorial.com/#static-pattern-rules">https://makefiletutorial.com/#static-pattern-rules</a></li>
<li><a href="https://blog.csdn.net/oqqHuTu12345678/article/details/125617988">https://blog.csdn.net/oqqHuTu12345678/article/details/125617988</a><span id="more"></span></li>
</ul>
<h1 id="1-Basic-Rules"><a href="#1-Basic-Rules" class="headerlink" title="1 Basic Rules"></a>1 Basic Rules</h1><p>一个makefile由多条规则组成，每条规则一般像这样：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">targets: prerequisites</span></span><br><span class="line">	command</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line"><span class="comment"># e.g.,</span></span><br><span class="line"><span class="section">blah: blah.c</span></span><br><span class="line">	cc blah.c -o blah</span><br></pre></td></tr></table></figure>

<p>当运行<code>make</code>时，会先找到第一个target，然后判断是否需要重新运行command以重新生成targets。只有当targets不存在，或者prerequisites有更新才会重新运行。Make的逻辑是：先找到第一个target，看这个target的prerequisites是否满足；如果不满足，就会在makefile中查找生成prerequisites的rule，递归执行直到某个rule的prerequisites已经满足，就开始执行command。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">blah: blah.o</span></span><br><span class="line">	cc blah.o -o blah <span class="comment"># Runs third</span></span><br><span class="line"></span><br><span class="line"><span class="section">blah.o: blah.c</span></span><br><span class="line">	cc -c blah.c -o blah.o <span class="comment"># Runs second</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Typically blah.c would already exist, but I want to limit any additional required files</span></span><br><span class="line"><span class="section">blah.c:</span></span><br><span class="line">	echo <span class="string">&quot;int main() &#123; return 0; &#125;&quot;</span> &gt; blah.c <span class="comment"># Runs first</span></span><br></pre></td></tr></table></figure>
<p><code>make</code>命令可以配合可选项实现多种选择，例如，<code>-f</code>指定makefile文件，<code>-I</code>指定include路径，指定<code>targets</code>为<code>cleam</code>清除数据（即<code>make clean</code>）：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">some_file: </span></span><br><span class="line">	touch some_file</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -f some_file</span><br></pre></td></tr></table></figure>

<h1 id="2-Variables"><a href="#2-Variables" class="headerlink" title="2 Variables"></a>2 Variables</h1><ul>
<li>通过<code>:=</code>、<code>=</code>或者<code>?=</code>定义变量：<ul>
<li><code>=</code>，以递归的形式展开变量，即赋值的变量只有在被引用&#x2F;使用时才会展开，即延迟展开（不常用）</li>
<li><code>:=</code>，直接展开式赋值</li>
<li><code>?=</code>，使用<code>?=</code>赋值时，只有变量未被赋值过时才有效</li>
</ul>
</li>
<li><code>+=</code>：append</li>
<li>对于Make来说，所有的变量都是string，单引号或者双引号是没有意义的</li>
<li>通过<code>$(VAR)</code>或<code>$&#123;VAR&#125;</code>使用变量<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">files := file1 file2</span><br><span class="line"><span class="section">some_file: <span class="variable">$(files)</span></span></span><br><span class="line">	echo <span class="string">&quot;Look at this variable: &quot;</span> <span class="variable">$(files)</span></span><br><span class="line">	touch some_file</span><br><span class="line"></span><br><span class="line"><span class="section">file1:</span></span><br><span class="line">	touch file1</span><br><span class="line"><span class="section">file2:</span></span><br><span class="line">	touch file2</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -f file1 file2 some_file</span><br></pre></td></tr></table></figure></li>
<li>可以给指定target设置变量，从而其他的target都无法使用：<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">all: one = cool</span></span><br><span class="line"></span><br><span class="line"><span class="section">all: </span></span><br><span class="line">	echo one is defined: <span class="variable">$(one)</span></span><br><span class="line"></span><br><span class="line"><span class="section">other:</span></span><br><span class="line">	echo one is nothing: <span class="variable">$(one)</span></span><br></pre></td></tr></table></figure></li>
<li>也可以给符号特定pattern的target赋变量：<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">%.c: one = cool</span></span><br><span class="line"></span><br><span class="line"><span class="section">blah.c: </span></span><br><span class="line">	echo one is defined: <span class="variable">$(one)</span></span><br><span class="line"></span><br><span class="line"><span class="section">other:</span></span><br><span class="line">	echo one is nothing: <span class="variable">$(one)</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="3-Targets"><a href="#3-Targets" class="headerlink" title="3 Targets"></a>3 Targets</h1><ul>
<li>通过指定<code>all</code>target，可以使<code>all</code>target的所有prerequisites都被执行，e.g.,<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="section">f1.o:</span></span><br><span class="line">	echo f1.o</span><br><span class="line"><span class="section">f2.o:</span></span><br><span class="line">    echo f2.o</span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以合并rules，e.g.,</span></span><br><span class="line"><span class="section">all: f1.o f2.o</span></span><br><span class="line">f1.o f2.o:</span><br><span class="line">	echo <span class="variable">$@</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="3-Automatic-Variables-and-Wildcards"><a href="#3-Automatic-Variables-and-Wildcards" class="headerlink" title="3 Automatic Variables and Wildcards"></a>3 Automatic Variables and Wildcards</h1><ul>
<li><code>*</code>：匹配任意个字符，可用于搜索文件系统中匹配的文件名。注意它在targets和prerequisites中只能在作为变量时起作用，否则就是一个string</li>
<li><code>%</code>：匹配任意个字符，和<code>*</code>的区别在于，<code>*</code>应用在系统中，<code>%</code>应用在这个makefile文件中<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Print out file information about every .c file</span></span><br><span class="line"><span class="section">print: $(wildcard *.c)</span></span><br><span class="line">	ls -la  <span class="variable">$?</span></span><br><span class="line"></span><br><span class="line">thing_wrong := *.o <span class="comment"># Don&#x27;t do this! &#x27;*&#x27; will not get expanded</span></span><br><span class="line">thing_right := <span class="variable">$(<span class="built_in">wildcard</span> *.o)</span></span><br><span class="line"></span><br><span class="line"><span class="section">all: one two three four</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Fails, because $(thing_wrong) is the string &quot;*.o&quot;</span></span><br><span class="line"><span class="section">one: <span class="variable">$(thing_wrong)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Stays as *.o if there are no files that match this pattern :(</span></span><br><span class="line"><span class="section">two: *.o </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Works as you would expect! In this case, it does nothing.</span></span><br><span class="line"><span class="section">three: <span class="variable">$(thing_right)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Same as rule three</span></span><br><span class="line"><span class="section">four: $(wildcard *.o)</span></span><br></pre></td></tr></table></figure></li>
<li><code>$@</code>：表示target name</li>
<li><code>$?</code>：表示比target要新的prerequisites</li>
<li><code>$^</code>：表示所有不重复的rerequisites，以空格分开</li>
<li><code>$&lt;</code>：表示第一个prerequisites</li>
</ul>
<h1 id="4-Implicit-Rules-and-Static-Pattern-Rules"><a href="#4-Implicit-Rules-and-Static-Pattern-Rules" class="headerlink" title="4 Implicit Rules and Static Pattern Rules"></a>4 Implicit Rules and Static Pattern Rules</h1><ul>
<li>这两种规则都可以减少写makefile文件的工作量，但是对应地，makefile文件的可读性会下降<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ======== Implicit Rules ========</span></span><br><span class="line"><span class="comment"># CC: Program for compiling C programs; default cc</span></span><br><span class="line"><span class="comment"># CXX: Program for compiling C++ programs; default g++</span></span><br><span class="line"><span class="comment"># CFLAGS: Extra flags to give to the C compiler</span></span><br><span class="line"><span class="comment"># CXXFLAGS: Extra flags to give to the C++ compiler</span></span><br><span class="line"><span class="comment"># CPPFLAGS: Extra flags to give to the C preprocessor</span></span><br><span class="line"><span class="comment"># LDFLAGS: Extra flags to give to compilers when they are supposed to invoke the linker</span></span><br><span class="line">CC = gcc <span class="comment"># Flag for implicit rules</span></span><br><span class="line">CFLAGS = -g <span class="comment"># Flag for implicit rules. Turn on debug info</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Implicit rule #1: blah is built via the C linker implicit rule</span></span><br><span class="line"><span class="comment"># Implicit rule #2: blah.o is built via the C compilation implicit rule, because blah.c exists</span></span><br><span class="line"><span class="section">blah: blah.o</span></span><br><span class="line"></span><br><span class="line"><span class="section">blah.c:</span></span><br><span class="line">	echo <span class="string">&quot;int main() &#123; return 0; &#125;&quot;</span> &gt; blah.c</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -f blah*</span><br><span class="line"></span><br><span class="line"><span class="comment"># ======== Static Pattern Rules ========</span></span><br><span class="line"><span class="section">targets...: target-pattern: prereq-patterns ...</span></span><br><span class="line">   commands</span><br><span class="line"></span><br><span class="line">objects = foo.o bar.o all.o</span><br><span class="line"><span class="section">all: <span class="variable">$(objects)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment"># These files compile via implicit rules</span></span><br><span class="line"><span class="comment"># Syntax - targets ...: target-pattern: prereq-patterns ...</span></span><br><span class="line"><span class="comment"># In the case of the first target, foo.o, the target-pattern matches foo.o and sets the &quot;stem&quot; to be &quot;foo&quot;.</span></span><br><span class="line"><span class="comment"># It then replaces the &#x27;%&#x27; in prereq-patterns with that stem</span></span><br><span class="line"><span class="variable">$(objects)</span>: %.o: %.c</span><br><span class="line"></span><br><span class="line"><span class="section">all.c:</span></span><br><span class="line">	echo <span class="string">&quot;int main() &#123; return 0; &#125;&quot;</span> &gt; all.c</span><br><span class="line"></span><br><span class="line"><span class="section">%.c:</span></span><br><span class="line">	touch <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -f *.c *.o all</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="5-Commands-and-Exection"><a href="#5-Commands-and-Exection" class="headerlink" title="5 Commands and Exection"></a>5 Commands and Exection</h1><ul>
<li><code>-</code>：command前加<code>-</code>，即使该条命令出错，也不影响后续命令的执行</li>
<li><code>@</code>：在commands开头加上<code>@</code>可以令其不输出内容，e.g.,<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">all: </span></span><br><span class="line">	@echo <span class="string">&quot;This make line will not be printed&quot;</span></span><br><span class="line">	echo <span class="string">&quot;But this will&quot;</span></span><br></pre></td></tr></table></figure></li>
<li><code>$$</code>：command里用<code>$$</code>可以输出<code>$</code>符号，然后在makefile文件里就可以引用shell中的变量，例如：<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">all:</span></span><br><span class="line">	<span class="comment"># Same as running &quot;sh_var=&#x27;I am a shell variable&#x27;; echo $sh_var&quot; in the shell</span></span><br><span class="line">	sh_var=&#x27;I am a shell variable&#x27;; echo $$sh_var</span><br></pre></td></tr></table></figure></li>
<li>通过修改<code>SHELL</code>变量，可以修改默认的shell（默认是<code>/bin/sh</code>）<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">SHELL=/bin/bash</span><br><span class="line"><span class="section">cool:</span></span><br><span class="line">	echo <span class="string">&quot;Hello from bash&quot;</span></span><br></pre></td></tr></table></figure></li>
<li><code>-k</code>：<code>make</code>命令添加可选项<code>-k</code>，使得在遇到错误时仍然能继续执行，即如果某个target出错，依赖这个target的rule都不执行，其它rule执行</li>
<li><code>-i</code>：<code>make</code>命令添加可选项<code>-i</code>，忽略一切命令的出错，执行所有生成规则</li>
<li><code>-s</code>：<code>make</code>命令添加可选项<code>-s</code>，不输出任何内容，相当于在每个command前加<code>@</code></li>
<li><code>export</code>：将某个变量设置为shell变量，e.g.,<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">shell_env_var=Shell env var, created inside of Make</span><br><span class="line"><span class="keyword">export</span> shell_env_var</span><br><span class="line"><span class="section">all:</span></span><br><span class="line">	echo <span class="variable">$(shell_env_var)</span></span><br><span class="line">	echo $$shell_env_var</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="6-Conditional-Makefiles"><a href="#6-Conditional-Makefiles" class="headerlink" title="6 Conditional Makefiles"></a>6 Conditional Makefiles</h1><ul>
<li><p><code>ifeq/else</code>：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">foo = ok</span><br><span class="line"></span><br><span class="line"><span class="section">all:</span></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(foo)</span>, ok)</span><br><span class="line">	echo <span class="string">&quot;foo equals ok&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	echo <span class="string">&quot;nope&quot;</span></span><br><span class="line"><span class="keyword">endif</span> </span><br><span class="line"></span><br><span class="line"><span class="comment"># ======== Check if a variable is empty ========</span></span><br><span class="line">nullstring =</span><br><span class="line">foo = <span class="variable">$(nullstring)</span> <span class="comment"># end of line; there is a space here</span></span><br><span class="line"></span><br><span class="line"><span class="section">all:</span></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(<span class="built_in">strip</span> <span class="variable">$(foo)</span>)</span>,)</span><br><span class="line">	echo <span class="string">&quot;foo is empty after being stripped&quot;</span></span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(nullstring)</span>,)</span><br><span class="line">	echo <span class="string">&quot;nullstring doesn&#x27;t even have spaces&quot;</span></span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>ifdef/ifndef</code>：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">bar =</span><br><span class="line">foo = <span class="variable">$(bar)</span></span><br><span class="line"></span><br><span class="line"><span class="section">all:</span></span><br><span class="line"><span class="keyword">ifdef</span> foo</span><br><span class="line">	echo <span class="string">&quot;foo is defined&quot;</span></span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"><span class="keyword">ifndef</span> bar</span><br><span class="line">	echo <span class="string">&quot;but bar is not&quot;</span></span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ======== $(makeflags)可以用于给make命令添加可选项 ========</span></span><br><span class="line">bar =</span><br><span class="line">foo = <span class="variable">$(bar)</span></span><br><span class="line"></span><br><span class="line"><span class="section">all:</span></span><br><span class="line"><span class="comment"># Search for the &quot;-i&quot; flag. MAKEFLAGS is just a list of single characters, one per flag. So look for &quot;i&quot; in this case.</span></span><br><span class="line"><span class="keyword">ifneq</span> (,<span class="variable">$(<span class="built_in">findstring</span> i, <span class="variable">$(MAKEFLAGS)</span>)</span>)</span><br><span class="line">	echo <span class="string">&quot;i was passed to MAKEFLAGS&quot;</span></span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="7-Functions"><a href="#7-Functions" class="headerlink" title="7 Functions"></a>7 Functions</h1><ul>
<li><code>findstring</code>：<code>$(findstring &lt;find&gt;,&lt;in&gt;)</code></li>
<li><code>subst</code>：<code>$(subst &lt;from&gt;,&lt;to&gt;,&lt;text&gt;)</code>，注意逗号之间不要有空格</li>
<li><code>patsubst</code>：<code>$(patsubst &lt;pattern&gt;,&lt;replacement&gt;,&lt;text&gt;)</code>，注意逗号之间不要有空格</li>
<li><code>strip</code>：<code>$(strip &lt;string&gt;)</code></li>
<li><code>fileter</code>：<code>$(filter &lt;pattern&gt;,&lt;text&gt;)</code></li>
<li><code>foreach</code>：<code>$(foreach &lt;var&gt;,&lt;list&gt;,&lt;text&gt;)</code></li>
<li><code>if</code>：<code>$(if &lt;condition&gt;,&lt;then-part&gt;)或(if&lt;condition&gt;,&lt;then-part&gt;,&lt;else-part&gt;)</code></li>
</ul>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>makefile</tag>
      </tags>
  </entry>
  <entry>
    <title>MIT 6.S081 Lab1 Utilities</title>
    <url>/2022/35075/</url>
    <content><![CDATA[<p>参考资料：</p>
<ul>
<li>课程官方网页：<a href="https://pdos.csail.mit.edu/6.S081/2021/index.html">https://pdos.csail.mit.edu/6.S081/2021/index.html</a></li>
<li>xv6 book：<a href="https://pdos.csail.mit.edu/6.S081/2021/xv6/book-riscv-rev2.pdf">https://pdos.csail.mit.edu/6.S081/2021/xv6/book-riscv-rev2.pdf</a></li>
<li>xv6手册中文版：<a href="http://xv6.dgs.zone/">http://xv6.dgs.zone/</a></li>
<li>参考代码：<a href="http://doraemonzzz.com/tags/6-S081/">http://doraemonzzz.com/tags/6-S081/</a>，以下代码主要参考该工作。<span id="more"></span></li>
</ul>
<h1 id="0-配置实验环境"><a href="#0-配置实验环境" class="headerlink" title="0 配置实验环境"></a>0 配置实验环境</h1><ol>
<li>根据<a href="https://pdos.csail.mit.edu/6.S081/2021/tools.html">Tools Used in 6.S081</a>安装环境。</li>
<li>安装好后，在shell运行<code>make qemu</code>进入qemu环境。</li>
<li>同时按住<code>ctrl+a</code>然后松开这两个键，再按<code>x</code>可以退出qemu环境。</li>
</ol>
<h1 id="1-Boot-xv6-easy"><a href="#1-Boot-xv6-easy" class="headerlink" title="1 Boot xv6 (easy)"></a>1 Boot xv6 (easy)</h1><p>根据实验指示逐步执行即可：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> git://g.csail.mit.edu/xv6-labs-2021</span><br><span class="line">Cloning into <span class="string">&#x27;xv6-labs-2021&#x27;</span>...</span><br><span class="line">...</span><br><span class="line">$ <span class="built_in">cd</span> xv6-labs-2021</span><br><span class="line">$ git checkout util  <span class="comment"># 这里我的默认分支下是空的，需要签出分支后才能看到代码</span></span><br><span class="line">$ make qemu <span class="comment"># 进入qemu环境，并启动xv6系统</span></span><br></pre></td></tr></table></figure>

<h1 id="2-sleep-easy"><a href="#2-sleep-easy" class="headerlink" title="2 sleep (easy)"></a>2 sleep (easy)</h1><p>按照xv6教材和实验指示逐步执行即可。</p>
<h1 id="3-pingpong-easy"><a href="#3-pingpong-easy" class="headerlink" title="3 pingpong (easy)"></a>3 pingpong (easy)</h1><p>这个实验的意思是，child进程通过pipe给parent进程发一个字符，parent进程输出字符。同样的，parent进程也要给child进程发一个字符，child进程输出字符。</p>
<p>要注意的是，父子进程是通过同一个pipe通信的，因此要避免两个进程同时读或者同时写，并且parent必须等child进程结束后才能读，否则可能读到自己写的字符，因此需要先让parent进程写、child进程读，然后反过来：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> p[<span class="number">2</span>];</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">2</span>];</span><br><span class="line">    pipe(p);</span><br><span class="line">    <span class="type">int</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123; <span class="comment">// child</span></span><br><span class="line">        <span class="keyword">if</span> (read(p[<span class="number">0</span>], buf, <span class="number">1</span>) != <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Can&#x27;t read from parent!\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        close(p[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">1</span>, <span class="string">&quot;child receive: %c\n&quot;</span>, buf[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">1</span>, <span class="string">&quot;%d: received ping\n&quot;</span>, getpid());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (write(p[<span class="number">1</span>], <span class="string">&quot;b&quot;</span>, <span class="number">1</span>) != <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Can&#x27;t write to parent!\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        close(p[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;  <span class="comment">// parent</span></span><br><span class="line">        <span class="keyword">if</span> (write(p[<span class="number">1</span>], <span class="string">&quot;a&quot;</span>, <span class="number">1</span>) != <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Can&#x27;t write to child!\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        close(p[<span class="number">1</span>]);  </span><br><span class="line"></span><br><span class="line">        wait(<span class="number">0</span>); <span class="comment">// 如果不等待子进程结束，可能读的是&quot;a&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (read(p[<span class="number">0</span>], buf, <span class="number">1</span>) != <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Can&#x27;t read from child!\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        close(p[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">1</span>, <span class="string">&quot;parent receive: %c\n&quot;</span>, buf[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">1</span>, <span class="string">&quot;%d: received pong\n&quot;</span>, getpid());</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4-primes-moderate-x2F-hard"><a href="#4-primes-moderate-x2F-hard" class="headerlink" title="4 primes (moderate)&#x2F;(hard)"></a>4 primes (moderate)&#x2F;(hard)</h1><p>这个题的意思写一个并发版本的素数筛子，令多个筛子可以同时筛数。仔细看下图，这个图说明：如果某个数字在上一个筛子中没有被筛掉，并且这个数字是当前剩余数字中最小的那个，那么该数字是prime，需要输出，并且作为一个新的筛子。为了并行实现，可以通过fork产生子进程，父进程根据当前筛子向子进程输入数据，子进程则负责新的剩余数据，也就是说，实现父进程写和子进程读同时进行：<br><img data-src="/../images/sieve.gif"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">primes</span><span class="params">(<span class="type">int</span> *fd)</span> &#123;</span><br><span class="line">    <span class="type">int</span> p, d;</span><br><span class="line">    close(fd[<span class="number">1</span>]);  <span class="comment">// 由于fork时也复制了文件描述符，因此不需要的文件描述符应该关闭，以避免不可控的事情</span></span><br><span class="line">    <span class="keyword">if</span> (read(fd[<span class="number">0</span>], (<span class="type">void</span>*)&amp;p, <span class="keyword">sizeof</span>(p)) != <span class="keyword">sizeof</span>(p)) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Read fail!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;prime %d\n&quot;</span>, p);</span><br><span class="line">    <span class="keyword">if</span> (read(fd[<span class="number">0</span>], (<span class="type">void</span>*) &amp;d, <span class="keyword">sizeof</span>(d))) &#123;</span><br><span class="line">        <span class="type">int</span> fd1[<span class="number">2</span>];</span><br><span class="line">        pipe(fd1);</span><br><span class="line">        <span class="keyword">if</span> (fork() == <span class="number">0</span>) &#123;</span><br><span class="line">            primes(fd1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            close(fd1[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (d % p != <span class="number">0</span>) &#123;</span><br><span class="line">                    write(fd1[<span class="number">1</span>], (<span class="type">void</span>*) &amp;d, <span class="keyword">sizeof</span>(d));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">while</span> (read(fd[<span class="number">0</span>], (<span class="type">void</span>*)&amp;d, <span class="keyword">sizeof</span>(d)));</span><br><span class="line">            close(fd[<span class="number">0</span>]);</span><br><span class="line">            close(fd1[<span class="number">1</span>]);</span><br><span class="line">            wait(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> fd[<span class="number">2</span>];  <span class="comment">// fd[0]: read fd, fd[1]: write fd</span></span><br><span class="line">    <span class="type">int</span> start = <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> end = <span class="number">35</span>;</span><br><span class="line">    pipe(fd);</span><br><span class="line">    <span class="keyword">if</span> (fork() == <span class="number">0</span>) &#123;  <span class="comment">// 子进程</span></span><br><span class="line">        primes(fd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;  <span class="comment">// 父进程</span></span><br><span class="line">        close(fd[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt;= end; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (write(fd[<span class="number">1</span>], (<span class="type">void</span>*) &amp;i, <span class="keyword">sizeof</span>(i)) != <span class="number">4</span>) &#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Write fail!\n&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        close(fd[<span class="number">1</span>]);</span><br><span class="line">        wait(<span class="number">0</span>);  <span class="comment">// 防止出现孤儿进程</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="5-find-moderate"><a href="#5-find-moderate" class="headerlink" title="5 find (moderate)"></a>5 find (moderate)</h1><p>这个题要求实现给定目录和目标文件，输出给定目录及其子目录下的所有目标文件。仔细阅读<code>user/ls.c</code>：<code>fmtname</code>函数的功能是将输入<code>path</code>中最后一个<code>&#39;\&#39;</code>之后的内容截取出来，<code>ls</code>函数先将<code>fd</code>定向到<code>path</code>，用于后续读取<code>path</code>对应的文件或目录，<code>fstat</code>函数是读入fd指向文件的更具体的info，然后判断指向文件是什么类型，并进一步处理。对比<code>ls</code>和<code>find</code>的区别，可以发现<code>find</code>多了一个目标文件，并且<code>find</code>的<code>path</code>一定是一个目录。因此，<code>find</code>多了是否为目录的判断，以及文件名比对：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/fs.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span>*</span><br><span class="line"><span class="title function_">fmtname</span><span class="params">(<span class="type">char</span> *path)</span>  <span class="comment">// 获取path中最后一个‘/’之后的内容</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">char</span> buf[DIRSIZ+<span class="number">1</span>];</span><br><span class="line">  <span class="type">char</span> *p;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Find first character after last slash.</span></span><br><span class="line">  <span class="keyword">for</span>(p=path+<span class="built_in">strlen</span>(path); p &gt;= path &amp;&amp; *p != <span class="string">&#x27;/&#x27;</span>; p--)</span><br><span class="line">    ;</span><br><span class="line">  p++;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return blank-padded name.</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">strlen</span>(p) &gt;= DIRSIZ)</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">  memmove(buf, p, <span class="built_in">strlen</span>(p));</span><br><span class="line">  <span class="built_in">memset</span>(buf+<span class="built_in">strlen</span>(p), <span class="string">&#x27; &#x27;</span>, DIRSIZ-<span class="built_in">strlen</span>(p));</span><br><span class="line">  <span class="keyword">return</span> buf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">find</span><span class="params">(<span class="type">char</span> *path, <span class="type">char</span> *target_file)</span> &#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">512</span>], *p;</span><br><span class="line">  <span class="type">int</span> fd;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> <span class="title">de</span>;</span>  <span class="comment">// 目录信息</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span>  <span class="comment">// </span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((fd = open(path, <span class="number">0</span>)) &lt; <span class="number">0</span>)&#123;  <span class="comment">// 将fd定向到path</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;find: cannot open %s\n&quot;</span>, path);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(fstat(fd, &amp;st) &lt; <span class="number">0</span>)&#123;  <span class="comment">// 读入fd指向的文件info</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;find: cannot stat %s\n&quot;</span>, path);</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (read(fd, &amp;de, <span class="keyword">sizeof</span>(de)) != <span class="keyword">sizeof</span>(de)) &#123;  <span class="comment">// 判断能否读入fd指向的文件</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;find, cannot read %s\n&quot;</span>, path);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span>(st.type)&#123;</span><br><span class="line">  <span class="keyword">case</span> T_FILE:</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(de.name, target_file) == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%s/%s\n&quot;</span>, path, target_file);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> T_DIR:</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strlen</span>(path) + <span class="number">1</span> + DIRSIZ + <span class="number">1</span> &gt; <span class="keyword">sizeof</span> buf)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;ls: path too long\n&quot;</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">strcpy</span>(buf, path);</span><br><span class="line">    p = buf+<span class="built_in">strlen</span>(buf);</span><br><span class="line">    *p++ = <span class="string">&#x27;/&#x27;</span>;  <span class="comment">// buf下一层文路径</span></span><br><span class="line">    <span class="keyword">while</span>(read(fd, &amp;de, <span class="keyword">sizeof</span>(de)) == <span class="keyword">sizeof</span>(de))&#123;  <span class="comment">// 读取fd指向的文件</span></span><br><span class="line">      <span class="keyword">if</span>((de.inum == <span class="number">0</span>) || (<span class="built_in">strcmp</span>(de.name, <span class="string">&quot;.&quot;</span>) == <span class="number">0</span>) || (<span class="built_in">strcmp</span>(de.name, <span class="string">&quot;..&quot;</span>) == <span class="number">0</span>))&#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      memmove(p, de.name, DIRSIZ);</span><br><span class="line">      p[DIRSIZ] = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span>(stat(buf, &amp;st) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;find: cannot stat %s\n&quot;</span>, buf);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (st.type == T_FILE) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(de.name, target_file) == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, buf);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (st.type == T_DIR) find(buf, target_file);  <span class="comment">// 如果当前是目录，需要递归比对</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  close(fd);    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Usage: find [dir] [target_file]&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        find(argv[<span class="number">1</span>], argv[<span class="number">2</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="6-xargs-moderate"><a href="#6-xargs-moderate" class="headerlink" title="6 xargs (moderate)"></a>6 xargs (moderate)</h1><p>这个实验要求实现的功能是实现<code>xargs</code>命令的简化版本。主要思路是先根据<code>\n</code>确定一条命令，然后根据空格分辨出命令和它的参数。本题比较麻烦的是指针和字符数组的处理，需要特别小心：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/param.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLEN 1024</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">copy</span><span class="params">(<span class="type">char</span> **p1, <span class="type">char</span> *p2)</span> &#123;</span><br><span class="line">    *p1 = <span class="built_in">malloc</span>(<span class="built_in">strlen</span>(p2) + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(*p1, p2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">readLine</span><span class="params">(<span class="type">char</span> **pars, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="type">char</span> buf[MAXLEN];</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (read(<span class="number">0</span>, buf + j, <span class="number">1</span>)) &#123;  <span class="comment">// 每次读取一个字符，直到遇到\n，即读取一条命令</span></span><br><span class="line">        <span class="keyword">if</span> (buf[j] == <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">            buf[j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ++j;</span><br><span class="line">        <span class="keyword">if</span> (j == MAXLEN) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Parameters are too long!\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;  <span class="comment">// 没有读取到内容，即已经到pars的结尾</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (k &lt; j) &#123;  <span class="comment">// 一条命令可能有多个参数，每个参数保存在pars[i]中</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt; MAXARG) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Too much parameters!\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> ((k &lt; j) &amp;&amp; (buf[k] == <span class="string">&#x27; &#x27;</span>)) &#123;  <span class="comment">// 去掉命令的前导空格</span></span><br><span class="line">            ++k;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> l = k;</span><br><span class="line">        <span class="keyword">while</span> ((k &lt; j) &amp;&amp; (buf[k] != <span class="string">&#x27; &#x27;</span>)) &#123;</span><br><span class="line">            ++k;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        buf[k++] = <span class="number">0</span>;</span><br><span class="line">        copy(&amp;pars[i], buf + l);</span><br><span class="line">        ++i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Please enter more parameters!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *pars[MAXARG];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; argc; ++i) &#123;</span><br><span class="line">        copy(&amp;pars[i<span class="number">-1</span>], argv[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> e;</span><br><span class="line">    <span class="keyword">while</span> ((e = readLine(pars, argc - <span class="number">1</span>)) != <span class="number">-1</span>) &#123;</span><br><span class="line">        pars[e] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (fork() == <span class="number">0</span>) &#123;  <span class="comment">// 子进程执行命令</span></span><br><span class="line">            exec(pars[<span class="number">0</span>], pars);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            wait(<span class="number">0</span>);  <span class="comment">// 父进程等待子进程完成</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>MIT 6.S081</tag>
      </tags>
  </entry>
  <entry>
    <title>MIT 6.S081 Lab2 System Calls</title>
    <url>/2022/35594/</url>
    <content><![CDATA[<p>参考资料：</p>
<ul>
<li>课程官方网页：<a href="https://pdos.csail.mit.edu/6.S081/2021/index.html">https://pdos.csail.mit.edu/6.S081/2021/index.html</a></li>
<li>xv6 book：<a href="https://pdos.csail.mit.edu/6.S081/2021/xv6/book-riscv-rev2.pdf">https://pdos.csail.mit.edu/6.S081/2021/xv6/book-riscv-rev2.pdf</a></li>
<li>xv6手册中文版：<a href="http://xv6.dgs.zone/">http://xv6.dgs.zone/</a></li>
<li>参考代码：<a href="https://github.com/PKUFlyingPig/MIT6.S081-2020fall">https://github.com/PKUFlyingPig/MIT6.S081-2020fall</a></li>
</ul>
<span id="more"></span>

<h1 id="1-System-call-tracing-moderate"><a href="#1-System-call-tracing-moderate" class="headerlink" title="1 System call tracing (moderate)"></a>1 System call tracing (moderate)</h1><h2 id="1-1-题意"><a href="#1-1-题意" class="headerlink" title="1.1 题意"></a>1.1 题意</h2><p>这个题目的意思是，修改xv6系统的kernel，使得可以用<code>trace</code>跟踪系统调用输出<code>process id</code>，<code>system call name</code>和<code>return value</code>，并且<code>trace</code>调用需要保证可以跟踪调用进程及其子进程。<code>trace.c</code>已经实现了在user-level实现了trace的功能，我们只需要在kernel-level补充相关实现。</p>
<h2 id="1-2-实现步骤"><a href="#1-2-实现步骤" class="headerlink" title="1.2 实现步骤"></a>1.2 实现步骤</h2><p>根据题目提示，首先是在<code>user/user.h</code>增加trace函数的声明，在<code>user/usys.pl</code>增加trace函数的stub,<code>kernel/syscall.h</code>增加syscall number，这是为了使得xv6系统能通过编译：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// `user/user.h`</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">trace</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// user/usys.pl</span></span><br><span class="line">entry(<span class="string">&quot;trace&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// kernel/syscall.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_trace  22</span></span><br></pre></td></tr></table></figure>
<p>后两步的目的在于，将trace函数声明为syscall函数，使得<code>trace.c</code>的第17行调用trace函数时会自动调用系统函数。</p>
<p>然而，trace函数实际上在kernel-level并没有被实现。为了实现这一目标，根据题目提示，<code>kernel/proc.h</code>的进程结构中需要增加一个变量mask，用于记住调用trace syscall时所需的参数。<code>kernel/sysproc.c</code>中需要实现sys_trace()函数，该函数可以用于获取用户输入的变量mask，将其保存到进程中：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/proc.h</span></span><br><span class="line"><span class="type">int</span> mask;                    <span class="comment">// trace mask</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// kernel/sysproc.c</span></span><br><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_trace</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="type">int</span> mask;</span><br><span class="line">  <span class="keyword">if</span>(argint(<span class="number">0</span>, &amp;mask) &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  myproc()-&gt;mask = mask;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时，由于trace需要能跟踪子进程，因此需要修改<code>kernel/proc.c</code>中的fork()函数，使得trace mask可以复制到child process中：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/proc.c</span></span><br><span class="line">np-&gt;mask = p-&gt;mask;  <span class="comment">// copy mask from parent to child</span></span><br></pre></td></tr></table></figure>

<p>上述步骤实际上是实现trace的准备工作，为了实际实现trace功能，需要修改<code>kernel/syscall.c</code>的syscall()函数，用于打印trace的输出：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/syscall.c</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_trace</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="title function_">uint64</span> <span class="params">(*syscalls[])</span><span class="params">(<span class="type">void</span>)</span> = &#123;</span><br><span class="line">  ...</span><br><span class="line">  [SYS_trace]   sys_trace,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* sysnames[] = &#123;</span><br><span class="line">  <span class="string">&quot;fork&quot;</span>, <span class="string">&quot;exit&quot;</span>, <span class="string">&quot;wait&quot;</span>, <span class="string">&quot;pipe&quot;</span>, <span class="string">&quot;read&quot;</span>, <span class="string">&quot;kill&quot;</span>, <span class="string">&quot;exec&quot;</span>, <span class="string">&quot;fstat&quot;</span>, </span><br><span class="line">  <span class="string">&quot;chdir&quot;</span>, <span class="string">&quot;dup&quot;</span>, <span class="string">&quot;getpid&quot;</span>, <span class="string">&quot;sbrk&quot;</span>, <span class="string">&quot;sleep&quot;</span>, <span class="string">&quot;uptime&quot;</span>, <span class="string">&quot;open&quot;</span>, <span class="string">&quot;write&quot;</span>, </span><br><span class="line">  <span class="string">&quot;mknod&quot;</span>, <span class="string">&quot;unlink&quot;</span>, <span class="string">&quot;link&quot;</span>, <span class="string">&quot;mkdir&quot;</span>,<span class="string">&quot;close&quot;</span>,<span class="string">&quot;trace&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">syscall</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> num;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  num = p-&gt;trapframe-&gt;a7;  <span class="comment">// syscall number</span></span><br><span class="line">  <span class="keyword">if</span>(num &gt; <span class="number">0</span> &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123;</span><br><span class="line">    p-&gt;trapframe-&gt;a0 = syscalls[num]();  <span class="comment">// return value</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (p-&gt;mask &amp; (<span class="number">1</span> &lt;&lt; num))  <span class="comment">// syscall必须在mask中指定才能有输出</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d: syscall %s -&gt; %d\n&quot;</span>, p-&gt;pid, sysnames[num<span class="number">-1</span>], p-&gt;trapframe-&gt;a0);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %s: unknown sys call %d\n&quot;</span>,</span><br><span class="line">            p-&gt;pid, p-&gt;name, num);</span><br><span class="line">    p-&gt;trapframe-&gt;a0 = <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="1-3-总结"><a href="#1-3-总结" class="headerlink" title="1.3 总结"></a>1.3 总结</h1><ul>
<li><blockquote>
<p>在最开始，我们设置了一个perl脚本，Makefile会调用<code>user/usys.pl</code>，生成一个<code>user/usys.S</code>，这个文件就像一个switch语句一样，当你使用一个系统调用的时候，比如read，OS会查询<code>user/usys.S</code>中对应的标签target来执行相应的语句。</p>
</blockquote>
</li>
<li>注意看<code>user/usys.pl</code>中<code>print &quot; li a7, SYS_$&#123;name&#125;\n&quot;;</code>把被调用syscall名称放入寄存器a7，而在<code>kernel/syscall.c</code>中，syscall的编号也是在寄存器a7中获取的。</li>
<li>syscall的通用注册和实现流程：<ul>
<li><code>user/user.h</code>中声明该函数</li>
<li><code>user/usys.pl</code>中增加对应的syscall name</li>
<li><code>kernel/syscall.h</code>中增加syscall number</li>
<li><code>kernel/proc.h</code>的<strong>process</strong>结构中增加该syscall需要的变量</li>
<li><code>kernel/sysproc.c</code>中实现sys_*函数，该函数用于处理调用sys_*后需要做的事情</li>
<li><code>kernel/proc.c</code>中可以处理sys_*涉及到的变量在<strong>process</strong>中的使用</li>
<li><code>kernel/syscall.c</code>中增加指向新的系统函数的指针，并且可以修改<code>syscall</code>函数以配合sys_*的功能</li>
</ul>
</li>
<li>myproc可以用于获取当前正在运行的process</li>
</ul>
<h1 id="2-Sysinfo-moderate"><a href="#2-Sysinfo-moderate" class="headerlink" title="2 Sysinfo (moderate)"></a>2 Sysinfo (moderate)</h1><h2 id="2-1-题意"><a href="#2-1-题意" class="headerlink" title="2.1 题意"></a>2.1 题意</h2><p>本题要求增加系统调用<code>sysinfo</code>用于收集running system的信息，该系统调用函数使用一个指向<code>struct sysinfo</code>的指针作为输入。结构体字段包括freemem字段应该设置为空闲内存的字节数，nproc字段应该设置成状态不是UNUSED的进程数。</p>
<h2 id="2-2-实现步骤"><a href="#2-2-实现步骤" class="headerlink" title="2.2 实现步骤"></a>2.2 实现步骤</h2><p>根据题目提示，首先类似1.2注册sysinfo这个系统调用，并且需要在<code>user/user.h</code>中预声明<code>struct sysinfo</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// `user/user.h`</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sysinfo</span>;</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sysinfo</span><span class="params">(<span class="keyword">struct</span> sysinfo*)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// user/usys.pl</span></span><br><span class="line">entry(<span class="string">&quot;sysinfo&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// kernel/syscall.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_sysinfo  23</span></span><br></pre></td></tr></table></figure>

<p>然后，在<code>kernel/sysproc.c</code>中实现sys_sysinfo函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/sysproc.c</span></span><br><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_sysinfo</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 p;  <span class="comment">// pointer to struct sysinfo address</span></span><br><span class="line">  <span class="keyword">if</span>(argaddr(<span class="number">0</span>, &amp;p) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sysinfo</span> <span class="title">info</span>;</span></span><br><span class="line">  info.freemem = freemem();  <span class="comment">// get free memory</span></span><br><span class="line">  info.nproc = nproc();  <span class="comment">// get used proc</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span>* <span class="title">curproc</span> =</span> myproc();</span><br><span class="line">  <span class="comment">// copyout: curprocess pagetable, dst, src, size</span></span><br><span class="line">  <span class="keyword">if</span> (copyout(curproc-&gt;pagetable, p, (<span class="type">char</span>*)&amp;info, <span class="keyword">sizeof</span>(info)) &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据题目提示，freemem函数在<code>kernel/kalloc.c</code>中实现，nproc函数在<code>kernel/proc.c</code>中实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/kalloc.c</span></span><br><span class="line">uint64 <span class="title function_">freemem</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line">  uint64 sz = <span class="number">0</span>;</span><br><span class="line">  acquire(&amp;kmem.lock);</span><br><span class="line">  r = kmem.freelist;  <span class="comment">// freelist是第一个未被使用的页的地址</span></span><br><span class="line">  <span class="keyword">while</span> (r) &#123;</span><br><span class="line">    sz += <span class="number">1</span>;</span><br><span class="line">    r = r -&gt; next;</span><br><span class="line">  &#125;</span><br><span class="line">  sz = sz * PGSIZE;</span><br><span class="line">  release(&amp;kmem.lock);</span><br><span class="line">  <span class="keyword">return</span> sz;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// kernel/proc.c</span></span><br><span class="line">uint64 <span class="title function_">nproc</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  uint64 cnt = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NPROC; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (proc[i].state != UNUSED) ++cnt;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-3-总结"><a href="#2-3-总结" class="headerlink" title="2.3 总结"></a>2.3 总结</h2><p>无</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>MIT 6.S081</tag>
      </tags>
  </entry>
  <entry>
    <title>MIT 6.S081 Lab3 Page Tables</title>
    <url>/2022/29909/</url>
    <content><![CDATA[<p>参考资料：</p>
<ul>
<li>课程官方网页：<a href="https://pdos.csail.mit.edu/6.S081/2021/index.html">https://pdos.csail.mit.edu/6.S081/2021/index.html</a></li>
<li>xv6 book：<a href="https://pdos.csail.mit.edu/6.S081/2021/xv6/book-riscv-rev2.pdf">https://pdos.csail.mit.edu/6.S081/2021/xv6/book-riscv-rev2.pdf</a></li>
<li>xv6手册中文版：<a href="http://xv6.dgs.zone/">http://xv6.dgs.zone/</a></li>
<li>参考代码：<a href="https://blog.csdn.net/qq_33894666/article/details/121625097">https://blog.csdn.net/qq_33894666/article/details/121625097</a><span id="more"></span></li>
</ul>
<h1 id="1-Speed-up-system-calls-easy"><a href="#1-Speed-up-system-calls-easy" class="headerlink" title="1 Speed up system calls (easy)"></a>1 Speed up system calls (easy)</h1><h2 id="1-1-题意"><a href="#1-1-题意" class="headerlink" title="1.1 题意"></a>1.1 题意</h2><p>第一个任务是实现对系统调用<code>getpid</code>的优化。具体地说，当每个进程创建时，都映射一个read-only的页到<code>USYSCALL</code>（定义在<code>kernel/memlayout.h</code>中的<strong>虚拟地址</strong>），这个页的开头是一个<code>struct usyscall</code>，并将当前进程的pid保存在其中。</p>
<h2 id="1-2-实验步骤"><a href="#1-2-实验步骤" class="headerlink" title="1.2 实验步骤"></a>1.2 实验步骤</h2><p>根据提示，需要把一个结构体<code>struct usyscall</code>映射到<code>kernel/memlayout.h</code>中的<code>USYSCALL</code>地址。映射过程在<code>kernel/proc.c</code>中的<code>proc_pagetable</code>函数中执行，映射过程中需要用到<code>mappages</code>函数，且在使用<code>mappages</code>函数时设定给userspace只读权限的permission bits。此外需要在<code>allocproc</code>中分配和初始化页，以及确保在<code>freeproc</code>中初始化内存。在完成以上步骤后，就可以通过直接读取<code>USYSCALL</code>，获取进程id，而无需通过系统调用<code>getpid</code>获取进程id。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernal/proc.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">usyscall</span> *<span class="title">usysc</span>;</span>      <span class="comment">// 在进程结构体中添加保存映射信息的部分</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// kernal/proc.c</span></span><br><span class="line"><span class="type">pagetable_t</span></span><br><span class="line"><span class="title function_">proc_pagetable</span><span class="params">(<span class="keyword">struct</span> proc *p)</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将USYSCALL映射到进程的usysc</span></span><br><span class="line">  <span class="keyword">if</span> (mappages(pagetable, USYSCALL, PGSIZE, (uint64)(p-&gt;usysc), PTE_U | PTE_R) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    uvmfree(pagetable, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// kernal/proc.c</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> proc*</span><br><span class="line"><span class="title function_">allocproc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 给进程的usysc分配空间</span></span><br><span class="line">  <span class="keyword">if</span> ((p-&gt;usysc = (<span class="keyword">struct</span> usyscall *)kalloc()) == <span class="number">0</span>) &#123;</span><br><span class="line">    freeproc(p);</span><br><span class="line">    release(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  p-&gt;usysc-&gt;pid = p-&gt;pid;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// kernal/proc.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">freeproc</span><span class="params">(<span class="keyword">struct</span> proc *p)</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(p-&gt;usysc)</span><br><span class="line">    kfree((<span class="type">void</span>*)p-&gt;usysc);</span><br><span class="line">  p-&gt;usysc = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// kernal/proc.c</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">proc_freepagetable</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 sz)</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  uvmunmap(pagetable, USYSCALL, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="2-Print-a-page-table-easy"><a href="#2-Print-a-page-table-easy" class="headerlink" title="2 Print a page table (easy)"></a>2 Print a page table (easy)</h1><h2 id="2-1-题意"><a href="#2-1-题意" class="headerlink" title="2.1 题意"></a>2.1 题意</h2><p>本题要求实现函数<code>vmprint</code>，输入是<code>pagetable_t</code>，标准输出页表内容：page-table page，pte bits，physical address，不输出无效的pte。</p>
<h2 id="2-2-实验步骤"><a href="#2-2-实验步骤" class="headerlink" title="2.2 实验步骤"></a>2.2 实验步骤</h2><p>根据提示，首先在<code>exec.c</code>中添加<code>vmprint</code>调用语句<code>if(p-&gt;pid==1) vmprint(p-&gt;pagetable)</code>，并且在<code>kernel/defs.h</code>中添加<code>vmprint</code>函数的声明。接着，仔细阅读<code>kernel/vm.c</code>中的<code>freewalk</code>，并参照该函数实现<code>vmprint</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// exec.c</span></span><br><span class="line"><span class="keyword">if</span> (p-&gt;pid == <span class="number">1</span>) vmprint(p-&gt;pagetable);</span><br><span class="line"></span><br><span class="line"><span class="comment">// kernel/defs.h</span></span><br><span class="line"><span class="type">void</span>            <span class="title function_">vmprint</span><span class="params">(<span class="type">pagetable_t</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// kernel/vm.c</span></span><br><span class="line"><span class="type">void</span> __vmprint(<span class="type">pagetable_t</span> pagetable, <span class="type">int</span> level) &#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">512</span>; i++)&#123;</span><br><span class="line">    <span class="type">pte_t</span> pte = pagetable[i];</span><br><span class="line">    <span class="keyword">if</span>((pte &amp; PTE_V) &amp;&amp; (pte &amp; (PTE_R|PTE_W|PTE_X)) == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="comment">// this PTE points to a lower-level page table.</span></span><br><span class="line">      uint64 child = PTE2PA(pte);</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= level; ++j) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;..&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (j + <span class="number">1</span> &lt;= level) <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d: pte %p pa %p\n&quot;</span>, i, pte, child);</span><br><span class="line">      __vmprint((<span class="type">pagetable_t</span>)child, level + <span class="number">1</span>);  </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pte &amp; PTE_V)&#123;  <span class="comment">// leaf pte</span></span><br><span class="line">      uint64 child = PTE2PA(pte);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;.. .. ..%d: pte %p pa %p\n&quot;</span>, i, pte, child);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">vmprint</span><span class="params">(<span class="type">pagetable_t</span> p)</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;page table %p\n&quot;</span>, p);</span><br><span class="line">  __vmprint(p, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-Detecting-which-pages-have-been-accessed-hard"><a href="#3-Detecting-which-pages-have-been-accessed-hard" class="headerlink" title="3 Detecting which pages have been accessed (hard)"></a>3 Detecting which pages have been accessed (hard)</h1><h2 id="3-1-题意"><a href="#3-1-题意" class="headerlink" title="3.1 题意"></a>3.1 题意</h2><p>题目要求实现函数<code>pgaccess</code>，该函数用于报告哪个页被访问过。该函数包括三个输入参数：首先是待检查的第一个user page的虚拟地址（virtual address, va）；第二，是要检查的页的数量；第三，保存结果的结构体，该结构体以bitmask的形式保存页表是否被访问过，其中最低位对应第一个页。</p>
<h2 id="3-2-实现步骤"><a href="#3-2-实现步骤" class="headerlink" title="3.2 实现步骤"></a>3.2 实现步骤</h2><p>根据<code>user/pgtbltest.c</code>中的<code>pgaccess_test</code>函数，<code>pgaccess</code>有三个输入参数：<code>buf</code>、32和<code>&amp;abits</code>。<code>buf</code>是新申请的内存，大小为32个页，在当前进程的页表中有指向这些页的pte，我们只要获取最终指向这些页的pte，就可以知道这些页是否被访问过。我们可以根据<code>buf</code>的va为索引在当前进程的页表中找到这些pte，<code>buf</code>本身就是va。32表示页数。<code>abits</code>用于保存这32个页是否被访问过的结果，<code>&amp;abits</code>使得<code>pgaccess</code>函数可以直接修改<code>abits</code>。</p>
<p>RISC-V在硬件上已经实现了将page是否被访问过保存在pte的flags中，本题要做的只是把flags中的内容提取出来。<code>pageaccess</code>已经在userspace层面实现，所以只需要在kernel level实现<code>sys_pgaccess</code>函数即可。根据提示，需要在<code>kernel/riscv.h</code>中定义<code>PTE_A</code>，即判断一个页是否被访问过的bit（类似<code>PTE_U</code>，<code>PTE_R</code>等），根据<a href="https://pdos.csail.mit.edu/6.S081/2021/xv6/book-riscv-rev2.pdf">xv6 book</a>的Fig 3.2可知，<code>PTE_A</code>应该是每个PTE的右起第6个bit：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kernel/riscv.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_A (1L &lt;&lt; 6) <span class="comment">// accessed</span></span></span><br></pre></td></tr></table></figure>

<p>在<code>sys_pgaccess</code>函数中，首先需要获取保存在寄存器中的参数，这和Lab2是一样的。然后，就可以根据va（再次强调，<code>buf</code>本身就是va）在当前进程的页表中索引到对应的<code>pte</code>，索引过程可以参考<code>kernel/vm.c</code>中的<code>walk</code>函数。最后，将这些<code>pte</code>的<code>PTE_A</code>截取出来保存到输出结果中，并且重置<code>PTE_A</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">sys_pgaccess</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// lab pgtbl: your code here.</span></span><br><span class="line">  uint64 va;           <span class="comment">// va保存待检查的page数组的虚拟地址</span></span><br><span class="line">  <span class="type">int</span> page_num;        <span class="comment">// 要核验的page数</span></span><br><span class="line">  uint64 abits_addr;   <span class="comment">// abits从低到高记录page是否被访问过，abits_addr保存abits的地址</span></span><br><span class="line">  <span class="keyword">if</span> (argaddr(<span class="number">0</span>, &amp;va) &lt; <span class="number">0</span> || argint(<span class="number">1</span>, &amp;page_num) &lt; <span class="number">0</span> || argaddr(<span class="number">2</span>, &amp;abits_addr) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(va &gt;= MAXVA)</span><br><span class="line">    panic(<span class="string">&quot;walk&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">pagetable_t</span> pagetable = myproc() -&gt; pagetable;</span><br><span class="line">  uint mask = <span class="number">0</span>;  <span class="comment">// 内核数据</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; page_num; ++i, va += PGSIZE) &#123;</span><br><span class="line">    <span class="type">pte_t</span> *pte = <span class="number">0</span>;</span><br><span class="line">    <span class="type">pagetable_t</span> p = pagetable;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> level = <span class="number">2</span>; level &gt;= <span class="number">0</span>; --level) &#123;</span><br><span class="line">      <span class="comment">// PX根据level提取va对应的9bit的L0/L1/L2，即64bits只有最右9bit起作用，可以索引pagetable不越界</span></span><br><span class="line">      pte = &amp;p[PX(level, va)];  <span class="comment">// 根据L0/L1/L2获取页表中对应的pte，并取其地址</span></span><br><span class="line">      <span class="keyword">if</span>(*pte &amp; PTE_V)  <span class="comment">// 如果该PTE有效</span></span><br><span class="line">        p = (<span class="type">pagetable_t</span>)PTE2PA(*pte);  <span class="comment">// 找到次一级页表</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (*pte&amp;PTE_V &amp;&amp; *pte&amp;PTE_A) &#123;</span><br><span class="line">      mask = mask | (<span class="number">1L</span> &lt;&lt; i); </span><br><span class="line">      *pte &amp;= ~PTE_A;  <span class="comment">// 重置pte的PTE_A</span></span><br><span class="line">    &#125;    </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (copyout(pagetable, abits_addr, (<span class="type">char</span>*)&amp;mask, <span class="keyword">sizeof</span>(uint64)) &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-3-总结"><a href="#3-3-总结" class="headerlink" title="3.3 总结"></a>3.3 总结</h2><p>在做这个实验时，我一直没搞明白<code>buf</code>到底指什么：它是pte？还是pagetable。后来读了参考代码才搞清楚，buf实际上就是大小为32个页的内存，当前进程的页表里有指向这些页的pte。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>MIT 6.S081</tag>
      </tags>
  </entry>
  <entry>
    <title>MIT 6.S081 学习总结（updating）</title>
    <url>/2022/45755/</url>
    <content><![CDATA[<p>参考资料：</p>
<ul>
<li>课程官方网页：<a href="https://pdos.csail.mit.edu/6.S081/2021/index.html">https://pdos.csail.mit.edu/6.S081/2021/index.html</a></li>
<li>xv6 book：<a href="https://pdos.csail.mit.edu/6.S081/2021/xv6/book-riscv-rev2.pdf">https://pdos.csail.mit.edu/6.S081/2021/xv6/book-riscv-rev2.pdf</a></li>
<li>xv6手册中文版：<a href="http://xv6.dgs.zone/">http://xv6.dgs.zone/</a></li>
<li>参考代码：<a href="https://blog.csdn.net/qq_33894666/article/details/121625097">https://blog.csdn.net/qq_33894666/article/details/121625097</a></li>
<li>参考书：《UNIX环境高级编程（第3版）》<span id="more"></span></li>
</ul>
<h1 id="1-Operating-system-interfaces"><a href="#1-Operating-system-interfaces" class="headerlink" title="1 Operating system interfaces"></a>1 Operating system interfaces</h1><h2 id="1-1-Processes-and-memory"><a href="#1-1-Processes-and-memory" class="headerlink" title="1.1 Processes and memory"></a>1.1 Processes and memory</h2><ul>
<li><code>int fork()</code>：创建子进程，在父进程中的返回值是子进程的PID，在子进程中的返回值是0。<ul>
<li><code>fork</code>函数创建新的子进程后，在很多情况下，子进程需要调用<code>exec</code>函数以执行另一个程序。</li>
</ul>
</li>
<li><code>void exit(int status)</code>：终止当前进程，其操作包括调用各终止处理程序，然后关闭所有标准I&#x2F;O流等），<code>status</code>指示该进程是如何退出的，通常0指示正常退出的情况，1指示非正常退出的情况。<ul>
<li>无论是否正常退出，终止该进程的父进程都能调用<code>wait</code>或<code>waitpid</code>函数取得其终止状态。</li>
<li><code>_exit(int status)</code>：为进程提供无需运行终止处理程序或信号处理程序而最终只的方法。对标准I&#x2F;O流是否进行冲洗取决于实现。</li>
<li>在<code>main</code>函数内执行<code>return</code>语句，等效于调用<code>exit</code>。</li>
</ul>
</li>
<li><code>int wait(int *status)</code>：返回当前进程的已退出（或已杀死）子进程的PID，并将子进程的退出状态复制到传递给<code>wait</code>的地址。<ul>
<li>如果调用方的子进程都没有退出，那么<code>wait</code>等待一个子进程退出；如果调用者没有子进程，<code>wait</code>立即返回-1。如果父进程不关心子进程的退出状态，它可以传递一个0地址给<code>wait</code>，即父进程中使用<code>wait(0)</code>。</li>
<li>如果父进程在子进程之前停止，则子进程的父进程变为<code>init</code>状态（“这些进程由<code>init</code>进程收养”）。其操作过程大致是，在一个进程终止时，内核逐个检查所有活动进程，以判断它是否是正要终止进程的子进程。</li>
<li>内核为每个终止子进程保存了一定量的信息，这些信息至少包括进程PID、该进程的终止状态以及该进程使用的CPU时间总量，当终止进程的父进程调用<code>wait</code>或者<code>waitpid</code>时，可以得到这些信息。一个已经终止，但是其父进程尚未对其进行善后处理（获取终止子进程的有关信息、释放它仍占用的资源）的进程被称为<strong>僵死进程</strong>。</li>
</ul>
</li>
<li><code>int getpid()</code>：返回当前进程的PID。<ul>
<li>Lab3-Speed up system calls (easy)中实现了对<code>getpid</code>方法的优化，使得进程可以在用户态就获取到自身的PID。简单地说，是给在进程的开始给进程分配了一个read-only的页，用于保存进程的PID，需要时就从这个页读取PID。</li>
</ul>
</li>
<li><code>int sleep(int n)</code>：暂停当前进程，<code>n</code>指示暂停的时长。<ul>
<li>Lab1-sleep (easy)涉及了该函数的用法</li>
</ul>
</li>
<li><code>int exec(char *file, char *argv[])</code>：加载并执行可执行文件，<code>args</code>作为执行参数。<ul>
<li>当进程调用<code>exec</code>函数时，该进程执行的程序完全替换为新程序，而新程序则从其main函数开始执行。</li>
<li>调用<code>exec</code>并不创建新进程，所以调用前后进程的PID并不改变。</li>
<li>在UNIX系统种有7种不同的<code>exec</code>函数可供使用，而xv6系统为了简便，统一为<code>exec</code>函数。</li>
</ul>
</li>
</ul>
<h2 id="1-2-I-x2F-O-and-File-descriptors"><a href="#1-2-I-x2F-O-and-File-descriptors" class="headerlink" title="1.2 I&#x2F;O and File descriptors"></a>1.2 I&#x2F;O and File descriptors</h2><ul>
<li>文件描述符（file descriptors）：文件描述符是一个非负整数，表示进程可以读取或写入的、由内核管理的对象。进程可以通过打开一个<strong>文件</strong>、<strong>目录</strong>、<strong>设备</strong>，或创建一个<strong>管道</strong>，或复制一个已存在的描述符来获得一个文件描述符。<ul>
<li>文件描述符接口将文件、管道和设备之间的差异抽象出来，使它们看起来都像字节流。</li>
<li>进程从文件描述符0读取（标准输入），将输出写入文件描述符1（标准输出），并将错误消息写入文件描述符2（标准错误）。</li>
<li><code>fork</code>复制进程后，父子进程在开始时拥有完全相同的打开文件和<strong>文件偏移量</strong>，并且父子进程之间<strong>共享</strong>文件偏移量。</li>
<li><code>exec</code>替换了调用进程的内存，但保留其文件表。</li>
<li><code>fork</code>和<code>exec</code>分离的用处之一在于，在这两个调用之间有机会对子进程进行I&#x2F;O重定向，而不会干扰父进程的I&#x2F;O设置。</li>
</ul>
</li>
<li><code>int open(char *file, int flags)</code>：打开一个文件，<code>flags</code>指定打开的方式（例如：<code>O_RDONLY</code>, <code>O_WRONLY</code>等）。<ul>
<li>由<code>open</code>函数返回的文件描述符一定是最小的可用描述符。</li>
</ul>
</li>
<li><code>int read(int fd, char *buf, int n)</code>：从文件描述符fd读取最多n字节，将它们复制到buf，并返回读取的字节数。<ul>
<li>从当前<strong>文件偏移量</strong>开始读取数据，然后将该偏移量前进读取的字节数。</li>
<li>当没有更多的字节可读时，read返回0来表示文件的结束。</li>
</ul>
</li>
<li><code>int write(int fd, char *buf, int n)</code>：将buf中的n字节写入文件描述符，并返回写入的字节数。<ul>
<li>从当前<strong>文件偏移量</strong>开始写入数据，然后将该偏移量向前推进写入的字节数。</li>
<li>只有发生错误时才会写入小于n字节的数据。</li>
</ul>
</li>
<li><code>int lseek(int fd, int offset, int whence)</code>：为一个打开的文件显式设置文件偏移量。</li>
<li><code>int close(int fd)</code>：关闭一个打开文件。当一个进程终止时，内核将自动关闭它所有的打开文件。</li>
<li><code>int dup(int fd)</code>：复制一个现有的文件描述符，返回当前可用文件描述符中的最小数值。两个文件描述符<strong>共享文件偏移量</strong>。<ul>
<li><code>int dup2(int fd, int fd2)</code>：可以用<code>fd2</code>参数指定新描述符的值，返回新的文件描述符。如果<code>fd2</code>已经打开，在先将其关闭。如果<code>fd</code>等于<code>fd2</code>，则<code>dup2</code>返回<code>fd2</code>，而不是关闭它。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将hello world输出到fd指定的对象</span></span><br><span class="line">fd = dup(<span class="number">1</span>);</span><br><span class="line">write(<span class="number">1</span>, <span class="string">&quot;hello &quot;</span>, <span class="number">6</span>);</span><br><span class="line">write(fd, <span class="string">&quot;world\n&quot;</span>, <span class="number">6</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="1-3-Pipes"><a href="#1-3-Pipes" class="headerlink" title="1.3 Pipes"></a>1.3 Pipes</h2><ul>
<li><code>int pipe(int fd[2])</code>：调用<code>pipe</code>函数可以创建一个新的管道，数组<code>fd</code>记录读写文件描述符。<ul>
<li>一般而言，<code>fd[0]</code>为读入端的文件描述符，<code>fd[1]</code>为写入端的文件描述符，<code>fd[1]</code>的输出时<code>fd[0]</code>的输入。</li>
<li>如果没有可用的数据，则管道上的读入端将进入等待，直到有新数据写入或所有指向写入端的文件描述符都被关闭。</li>
<li>当所有指向写入端的文件描述符都被关闭时，读入端将返回0，就像到达数据文件的末尾一样。</li>
<li>管道只能在具有公共祖先的两个进程之间使用。通常，进程先调用<code>pipe</code>，接着调用<code>fork</code>，从而创建父子进程之间的IPC通道。</li>
</ul>
</li>
</ul>
<h2 id="1-4-File-system"><a href="#1-4-File-system" class="headerlink" title="1.4 File system"></a>1.4 File system</h2><p>文件本身和文件的名字是不同的：同一个底层文件（叫做inode，索引结点）可以有多个名字（叫做link，链接）。每个链接都由目录中的一个条目组成，该条目包含一个文件名和一个对inode的引用。inode保存关于文件的元数据（metadata），包括其类型（文件&#x2F;目录&#x2F;设备…）、长度、文件内容在磁盘上的位置以及指向文件的链接数。每个inode由唯一的inode编号标识。</p>
<ul>
<li><code>int stat(char *file, struct stat *st)</code>：根据<strong>文件的完全路径</strong>，获取有关信息保存在<code>st</code>中。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> T_DIR     1   <span class="comment">// Directory</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T_FILE    2   <span class="comment">// File</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T_DEVICE  3   <span class="comment">// Device</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> dev;     <span class="comment">// File system&#x27;s disk device</span></span><br><span class="line">  uint ino;    <span class="comment">// Inode number</span></span><br><span class="line">  <span class="type">short</span> type;  <span class="comment">// Type of file</span></span><br><span class="line">  <span class="type">short</span> nlink; <span class="comment">// Number of links to file</span></span><br><span class="line">  uint64 size; <span class="comment">// Size of file in bytes</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><code>int fstat(int fd, struct stat *st)</code>：<code>fstat</code>与<code>stat</code>的不同在于，<code>fstat</code>获的参数是<strong>文件描述符</strong>。<ul>
<li>Lab1-find (moderate)中，<code>fstat</code>函数是读入fd指向文件的更具体的info，然后判断指向文件是什么类型，并进一步处理。</li>
</ul>
</li>
<li><code>int link(char *file1, char *file2)</code>：创建新文件名<code>file2</code>，指向与现有文件名<code>file1</code>相同的inode。<ul>
<li>通过<code>fstat</code>获取<code>ino</code>，可以知道<code>file1</code>和<code>file2</code>引用相同的底层内容，同时<code>nlink</code>计数将被置为2。</li>
</ul>
</li>
<li><code>int unlink(char *file)</code>：删除链接。<ul>
<li>只有当文件的链接数为零且没有文件描述符引用时，文件的inode和包含其内容的磁盘空间才会被释放。</li>
</ul>
</li>
<li><code>int chdir(char *dir)</code>更改当前工作目录</li>
<li><code>int mkdir(char *dir)</code>：创建一个新目录</li>
<li><code>int mknod(char *file, int, int)</code>：创建一个引用设备的特殊文件。<ul>
<li>与设备文件相关联的是主设备号和次设备号(mknod的两个参数)，它们唯一地标识了一个内核设备。</li>
<li>当进程稍后打开设备文件时，内核将使用内核设备实现read和write系统调用，而不是使用文件系统。</li>
</ul>
</li>
</ul>
<h1 id="2-Operating-system-organization"><a href="#2-Operating-system-organization" class="headerlink" title="2 Operating system organization"></a>2 Operating system organization</h1><h2 id="2-1-Abstracting-physical-resources"><a href="#2-1-Abstracting-physical-resources" class="headerlink" title="2.1 Abstracting physical resources"></a>2.1 Abstracting physical resources</h2><ul>
<li>为什么需要operating system<ul>
<li>为了简化开发，需要提供一套能将资源抽象化的方法。</li>
<li>库函数方案的问题在于，当有多个应用程序运行时，这些程序必须可靠且良好运行：需要适时放弃处理资源、并且程序不要出bug（一出bug就可能影响到其他程序的运行）。人们通常希望提供比合作方案更强的隔离。</li>
<li>基于上述原因，人们需要操作系统用于为应用程序分配资源，因此应用程序只需考虑自身，不需要关注底层的硬件或者其他的应用程序。</li>
</ul>
</li>
</ul>
<h2 id="2-2-User-mode-supervisor-mode-and-system-calls"><a href="#2-2-User-mode-supervisor-mode-and-system-calls" class="headerlink" title="2.2 User mode, supervisor mode, and system calls"></a>2.2 User mode, supervisor mode, and system calls</h2><ul>
<li>强隔离要求在操作系统和应用程序之间有硬边界，才能保证应用程序不能修改（甚至读取）操作系统的数据结构和指令，以及应用程序不能访问其他进程的内存。</li>
<li>RISC-V有三种<strong>CPU可以执行指令的模式</strong>：机器模式（machine mode）、管理模式（supervisor mode）和用户模式（user mode），其权限由高到低。<ul>
<li>在机器模式下执行的指令具有完全特权；CPU在机器模式下启动。机器模式主要用于配置计算机。</li>
<li>在管理模式下，CPU被允许执行特权指令，例如启用和禁用中断等。管理模式下的软件称为在<strong>内核空间</strong>中运行。在内核空间（或管理模式）中运行的软件被称为<strong>内核</strong>。</li>
<li>应用程序一般只能运行用户模式的指令，并称其为在<strong>用户空间</strong>中运行。如果应用程序需要使用内核函数（如<code>read</code>系统调用），CPU必须先切换管理模式，再由内核验证系统调用的参数，决定是否执行该指令。</li>
</ul>
</li>
</ul>
<h2 id="2-3-Kernel-organization"><a href="#2-3-Kernel-organization" class="headerlink" title="2.3 Kernel organization"></a>2.3 Kernel organization</h2><ul>
<li>宏内核：整个操作系统都驻留在内核中，这样所有系统调用的实现都以管理模式运行。</li>
<li>微内核：最大限度地减少在管理模式下运行的操作系统代码量，并在用户模式下执行大部分操作系统</li>
</ul>
<h2 id="2-4-Process-overview"><a href="#2-4-Process-overview" class="headerlink" title="2.4 Process overview"></a>2.4 Process overview</h2><ul>
<li>进程是操作系统中资源分配的最小单位，线程是操作系统中调度的最小单位，线程之间共享进程资源。</li>
<li>进程有两个栈区：用户栈区和内核栈区。当进程进入内核（由于系统调用或者中断）时，内核代码在内核栈上执行，此时它的用户栈仍然包含保存的数据，只是不处于活动状态。</li>
<li>进程可以通过<code>ecall</code>提高硬件特权级别、进行系统调用，程序计数器（PC）更改为内核定义的入口点，入口点的代码切换到内核栈。系统调用完成时，切回用户栈，并通过调用<code>sret</code>指令返回用户空间，该指令降低了硬件特权级别，并在系统调用指令刚结束时恢复执行用户指令。</li>
</ul>
<h1 id="3-Page-tables"><a href="#3-Page-tables" class="headerlink" title="3 Page tables"></a>3 Page tables</h1><h2 id="3-1-Paging-hardware"><a href="#3-1-Paging-hardware" class="headerlink" title="3.1 Paging hardware"></a>3.1 Paging hardware</h2><p><img data-src="/../images/xv6book/va.png"></p>
<h2 id="3-2-Kernel-address-space"><a href="#3-2-Kernel-address-space" class="headerlink" title="3.2 Kernel address space"></a>3.2 Kernel address space</h2><p>QEMU模拟了一台计算机，QEMU将设备接口作为<em>内存映射</em>控制寄存器（<em>memory-mapped</em> control registers）暴露给软件，这些寄存器位于物理地址空间0x80000000以下。内核可以通过读取&#x2F;写入这些特殊的物理地址与设备交互；这种读取和写入与设备硬件而不是RAM通信。内核使用<strong>直接映射</strong>获取<strong>内存</strong>和<strong>内存映射设备寄存器</strong>（PHYSTOP以下的地址都是直接映射），即将资源映射到等于物理地址的虚拟地址。例如：</p>
<ul>
<li>内核本身在虚拟地址空间和物理内存中都位于<code>KERNBASE=0x80000000</code>。</li>
<li>当<code>fork</code>为子进程分配用户内存时，分配器返回该内存的物理地址。</li>
</ul>
<p>有几个内核虚拟地址不是直接映射：</p>
<ul>
<li>The trampoline page：该page在虚拟地址空间的顶部。但是对应的物理页面在虚拟地址空间中映射了两次：一次在虚拟地址空间的顶部，一次直接映射。</li>
<li>The kernel stack pages：每个进程都有自己的内核栈，进程之间的内核栈会被映射到偏高一些的位置，从而留下guard page的空间。guard page是保护页，当某个进程发生内核栈溢出时，保护其他进程的内核栈不被影响。注意，guard page不会浪费物理内存，它只是占据了虚拟地址空间的一段靠后的地址，但是并不映射到物理地址空间。<br><img data-src="/../images/xv6book/kernel_space.png"></li>
</ul>
<h2 id="3-3-Process-address-space"><a href="#3-3-Process-address-space" class="headerlink" title="3.3 Process address space"></a>3.3 Process address space</h2><p>一个进程的用户内存从虚拟地址0开始可以增长到<code>MAXVA</code>，原则上允许一个进程内存寻址空间为256G。如果需要更多的用户内存，xv6首先使用<code>kalloc</code>分配物理页面，然后将对应的PTE加到进程页表中，使得进程可以通过PTE使用这个物理页面。<br><img data-src="/../images/xv6book/user_space.png"></p>
<h1 id="4-Traps-and-system-calls"><a href="#4-Traps-and-system-calls" class="headerlink" title="4 Traps and system calls"></a>4 Traps and system calls</h1><h2 id="4-1-RISC-V-trap-machinery"><a href="#4-1-RISC-V-trap-machinery" class="headerlink" title="4.1 RISC-V trap machinery"></a>4.1 RISC-V trap machinery</h2><h2 id="4-2-Traps-from-user-space"><a href="#4-2-Traps-from-user-space" class="headerlink" title="4.2 Traps from user space"></a>4.2 Traps from user space</h2><h2 id="4-3-Traps-from-kernel-space"><a href="#4-3-Traps-from-kernel-space" class="headerlink" title="4.3 Traps from kernel space"></a>4.3 Traps from kernel space</h2><h2 id="4-4-Page-fault-exceptions"><a href="#4-4-Page-fault-exceptions" class="headerlink" title="4.4 Page-fault exceptions"></a>4.4 Page-fault exceptions</h2><h1 id="5-Interrupts-and-device-drivers"><a href="#5-Interrupts-and-device-drivers" class="headerlink" title="5 Interrupts and device drivers"></a>5 Interrupts and device drivers</h1><h1 id="6-Locking"><a href="#6-Locking" class="headerlink" title="6 Locking"></a>6 Locking</h1><h1 id="7-Scheduling"><a href="#7-Scheduling" class="headerlink" title="7 Scheduling"></a>7 Scheduling</h1><h1 id="8-File-system"><a href="#8-File-system" class="headerlink" title="8 File system"></a>8 File system</h1>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>MIT 6.S081</tag>
      </tags>
  </entry>
  <entry>
    <title>如何在电脑上操作手机</title>
    <url>/2022/8240/</url>
    <content><![CDATA[<blockquote>
<p>手机进了水，能开机，想把手机上的资料都备份一下。但是因为屏幕花了看得很吃力、不方便，所以打算在电脑上操作手机。</p>
</blockquote>
<p>参考1：<a href="https://www.zhihu.com/question/46795475/answer/869985800">如何在电脑上控制手机上所有的app软件操作？ - 张脑湿的回答 - 知乎</a></p>
<span id="more"></span>
<p>参考2：<a href="https://jingyan.baidu.com/article/08b6a591a3658955a80922ad.html">小米手机开发者模式怎么打开</a><br>参考3：<a href="https://blog.csdn.net/qq_50082325/article/details/121696514">Scrcpy投屏神器基本使用</a></p>
<h1 id="1-开启小米手机的开发者模式"><a href="#1-开启小米手机的开发者模式" class="headerlink" title="1 开启小米手机的开发者模式"></a>1 开启小米手机的开发者模式</h1><ul>
<li>设置 -&gt; 我的设备 -&gt; 全部参数 -&gt; MIUI 版本</li>
<li>连续点击“MIUI 版本”，直到弹出提示“您现在处于开发者模式”</li>
<li>设置 -&gt; 更多设置 -&gt; 开发者选项，允许“USB调试”和“USB调试（安全设置）”</li>
</ul>
<h1 id="2-下载scrcpy"><a href="#2-下载scrcpy" class="headerlink" title="2 下载scrcpy"></a>2 下载scrcpy</h1><ul>
<li>scrcpy是一款开源免费投屏控制软件，项目地址见scrcpy</li>
</ul>
<h1 id="3-将手机投屏到电脑"><a href="#3-将手机投屏到电脑" class="headerlink" title="3 将手机投屏到电脑"></a>3 将手机投屏到电脑</h1><ul>
<li>电脑开热点，然后手机连接电脑的热点，此时在电脑上可以看到手机的ip，等会需要用到这个ip。</li>
<li>手机通过USB连接到电脑，在USB配置弹窗中选择“文件传输”</li>
<li>在scrcpy目录中打开终端</li>
<li>终端中执行命令adb tcpip [端口号]，例如adb tcpip 5555</li>
<li>断开USB连接</li>
<li>终端中执行命令adb connect [ip]: [端口号]，例如adb connect 192.168.137.10: 5555</li>
<li>终端中执行命令scrcpy运行scrcpy软件</li>
</ul>
]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>tips</tag>
      </tags>
  </entry>
  <entry>
    <title>用树莓派3b搭建个人网盘</title>
    <url>/2022/15837/</url>
    <content><![CDATA[<blockquote>
<p>在淘宝上花10块钱搞了一大堆电子书，打算用树莓派3b搞个个人网盘存起来。虽然网口速度不行，但是一本书也就2MB左右，问题不大。</p>
</blockquote>
<p>参考1：<a href="https://blog.csdn.net/lz_quiet/article/details/103651730">私有云搭建-owncloud</a></p>
<span id="more"></span> 
<p>参考2：<a href="https://central.owncloud.org/t/access-denied-to-mariadb-any-suggestions/2783/3">Access denied to MariaDB. Any suggestions?</a></p>
<p>参考3：<a href="https://blog.chongyeye.com/?id=6">树莓派owncloud私有云挂载NTFS本地存储</a></p>
<h1 id="1-更换软件源"><a href="#1-更换软件源" class="headerlink" title="1 更换软件源"></a>1 更换软件源</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo nano /etc/apt/sources.list</span><br><span class="line"></span><br><span class="line"># 注释掉原来的源</span><br><span class="line"># deb http://raspbian.raspberrypi.org/raspbian/ buster main contrib non-free rpi</span><br><span class="line"># Uncomment line below then &#x27;apt-get update&#x27; to enable &#x27;apt-get source&#x27;</span><br><span class="line"># deb-src http://raspbian.raspberrypi.org/raspbian/ buster main contrib non-free rpi</span><br><span class="line"></span><br><span class="line"># 添加清华源</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ stretch main contrib non-free rpi</span><br><span class="line"></span><br><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure>

<h1 id="2-安装php"><a href="#2-安装php" class="headerlink" title="2 安装php"></a>2 安装php</h1><p>这里安装php不指明具体版本，直接安装默认版本，避免找不到对应版本的错误。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install php</span><br><span class="line">sudo apt-get install php-mysql php-zip php-xml php-intl php-mbstring php-gd php-curl</span><br></pre></td></tr></table></figure>

<h1 id="3-安装apache2"><a href="#3-安装apache2" class="headerlink" title="3 安装apache2"></a>3 安装apache2</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install apache2</span><br><span class="line"></span><br><span class="line"># 启动apache2</span><br><span class="line">systemctl restart apache2</span><br></pre></td></tr></table></figure>

<h1 id="4-安装mariadb"><a href="#4-安装mariadb" class="headerlink" title="4 安装mariadb"></a>4 安装mariadb</h1><p>不知道为什么搜索不到mysql-server的源，按<a href="https://blog.csdn.net/lz_quiet/article/details/103651730">参考1</a>装了mariadb-server。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install mariadb-server</span><br></pre></td></tr></table></figure>

<h1 id="5-数据库管理"><a href="#5-数据库管理" class="headerlink" title="5 数据库管理"></a>5 数据库管理</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo mysql -uroot -p</span><br><span class="line"></span><br><span class="line">CREATE DATABASE IF NOT EXISTS owncloud;</span><br><span class="line">GRANT ALL PRIVILEGES ON owncloud.* TO &#x27;owncloudUser&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;123123&#x27;;</span><br></pre></td></tr></table></figure>
<p>在mariadb执行完以上命令后，需要刷新再退出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FLUSH PRIVILEGES;</span><br><span class="line">exit</span><br><span class="line"></span><br><span class="line"># 退出后重启服务</span><br><span class="line">systemctl restart mariadb</span><br></pre></td></tr></table></figure>

<h1 id="6-安装owncloud"><a href="#6-安装owncloud" class="headerlink" title="6 安装owncloud"></a>6 安装owncloud</h1><p>按照<a href="https://blog.csdn.net/lz_quiet/article/details/103651730">参考1</a>执行。</p>
<h1 id="7-挂载机械硬盘"><a href="#7-挂载机械硬盘" class="headerlink" title="7 挂载机械硬盘"></a>7 挂载机械硬盘</h1><p>主要参考了<a href="https://blog.chongyeye.com/?id=6">树莓派owncloud私有云挂载NTFS本地存储</a>。以下操作针对NTFS硬盘格式。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 安装NTFS-3G</span><br><span class="line">sudo apt-get install ntfs-3g</span><br><span class="line"></span><br><span class="line"># 查看硬盘是否被检测到</span><br><span class="line">fdisk -l</span><br><span class="line"></span><br><span class="line"># 创建目录，挂载硬盘</span><br><span class="line">sudo mkdir -p /media/owncloudData</span><br><span class="line">sudo mount -t ntfs-3g  /dev/sda1 /media/owncloudData</span><br><span class="line"></span><br><span class="line"># 在owncloud中开启本地存储</span><br><span class="line">sudo nano /var/www/html/owncloud/config/config.php</span><br><span class="line"></span><br><span class="line"># 在文档中添加一句</span><br><span class="line">&#x27;files_external_allow_create_new_local&#x27; =&gt; &#x27;true&#x27;,</span><br></pre></td></tr></table></figure>
<p>之后，在owncloud的管理员setting中启用外置存储，完成。</p>
<h1 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h1><ul>
<li>树莓派直接给机械硬盘供电很吃力。</li>
<li>没有公共IP，设备只有和树莓派处于同一个子网时才能访问。</li>
</ul>
]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>树莓派</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL语句速成</title>
    <url>/2022/63903/</url>
    <content><![CDATA[<blockquote>
<p>工作中时不时要用到SQL语句，根据SQL经典50题复习下SQL语句的用法。</p>
</blockquote>
<p>参考资料：</p>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/38354000">图解SQL面试题：经典50题</a></li>
<li><a href="https://blog.csdn.net/m0_56869501/article/details/121011304">inner join 、left join 、right join 和full join的区别</a><span id="more"></span></li>
</ul>
<h1 id="1-创建表和添加数据"><a href="#1-创建表和添加数据" class="headerlink" title="1 创建表和添加数据"></a>1 创建表和添加数据</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> [tableName]([fieldName] [fieldType]...);</span><br><span class="line"><span class="comment">-- e.g.,</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> student(学号 <span class="type">VARCHAR</span>(<span class="number">255</span>), 姓名 <span class="type">VARCHAR</span>(<span class="number">255</span>), 出生日期 DATETIME(<span class="number">6</span>), 性别 <span class="type">VARCHAR</span>(<span class="number">255</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> [tableName] <span class="keyword">VALUES</span>(...);</span><br><span class="line"><span class="comment">-- e.g.,</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Student <span class="keyword">VALUES</span>(<span class="string">&#x27;01&#x27;</span> , <span class="string">&#x27;赵雷&#x27;</span> , <span class="string">&#x27;1990-01-01&#x27;</span> , <span class="string">&#x27;男&#x27;</span>);</span><br></pre></td></tr></table></figure>
<h1 id="2-查询"><a href="#2-查询" class="headerlink" title="2 查询"></a>2 查询</h1><h2 id="2-1-简单查询"><a href="#2-1-简单查询" class="headerlink" title="2.1 简单查询"></a>2.1 简单查询</h2><p>只涉及一张表的简单查询，<code>SELECT</code>指定查询目标；<code>FROM</code>指定查询对象；<code>WHERE</code>指定查询条件：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询姓王的学生的信息</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> student</span><br><span class="line"><span class="keyword">WHERE</span> 姓名 <span class="keyword">LIKE</span> <span class="string">&#x27;王%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询姓王的学生的个数</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(学号)</span><br><span class="line"><span class="keyword">FROM</span> student</span><br><span class="line"><span class="keyword">WHERE</span> 姓名 <span class="keyword">LIKE</span> <span class="string">&#x27;王%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h2 id="2-2-分组查询"><a href="#2-2-分组查询" class="headerlink" title="2.2 分组查询"></a>2.2 分组查询</h2><p><code>GROUP BY</code>指定分组字段，即根据哪个字段分组；<code>HAVING</code>对<code>GROUP BY</code>得到的结果作出限制；<code>ORDER BY</code>对最终结果进行排序，其中<code>DESC</code>为降序，<code>ASC</code>为升序；<code>LIMIT i, n</code>从查询结果中取出指定行，<code>i</code>指定从哪一行开始取数据，<code>n</code>指定取多少条数据，当<code>i=0</code>时可以省略指定<code>i</code>：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询每门课程选修的学生数</span></span><br><span class="line"><span class="keyword">SELECT</span> 课程号, <span class="built_in">COUNT</span>(学号)</span><br><span class="line"><span class="keyword">FROM</span> score</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> 课程号;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询平均成绩大于60分学生的学号和平均成绩</span></span><br><span class="line"><span class="keyword">SELECT</span> 学号, <span class="built_in">AVG</span>(成绩)</span><br><span class="line"><span class="keyword">FROM</span> score</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> 学号</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">AVG</span>(成绩)<span class="operator">&gt;</span><span class="number">60</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询总成绩排名前3的学生的学号</span></span><br><span class="line"><span class="keyword">SELECT</span> 学号</span><br><span class="line"><span class="keyword">FROM</span> score</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> 学号</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="built_in">SUM</span>(成绩) <span class="keyword">DESC</span></span><br><span class="line">LIMIT <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<h2 id="2-3-复杂查询"><a href="#2-3-复杂查询" class="headerlink" title="2.3 复杂查询"></a>2.3 复杂查询</h2><p>涉及到至少两张表的查询，也是平时工作中较常见的情况。</p>
<h3 id="2-3-1-子查询"><a href="#2-3-1-子查询" class="headerlink" title="2.3.1 子查询"></a>2.3.1 子查询</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询所有课程成绩小于60分学生的学号、姓名</span></span><br><span class="line"><span class="keyword">SELECT</span> s.学号, s.姓名</span><br><span class="line"><span class="keyword">FROM</span> student s</span><br><span class="line"><span class="keyword">WHERE</span> s.学号 <span class="keyword">IN</span> (</span><br><span class="line">  <span class="keyword">SELECT</span> 学号</span><br><span class="line">  <span class="keyword">FROM</span> score</span><br><span class="line">  <span class="keyword">GROUP</span> <span class="keyword">BY</span> 学号</span><br><span class="line">  <span class="keyword">HAVING</span> <span class="built_in">MAX</span>(成绩)<span class="operator">&lt;</span><span class="number">60</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h3 id="2-3-2-多表查询"><a href="#2-3-2-多表查询" class="headerlink" title="2.3.2 多表查询"></a>2.3.2 多表查询</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询所有学生的学号、姓名、选课数、总成绩</span></span><br><span class="line"><span class="keyword">SELECT</span> stu.学号, stu.姓名, <span class="built_in">COUNT</span>(sc.课程号) <span class="keyword">AS</span> 选课数, <span class="built_in">SUM</span>(sc.成绩) <span class="keyword">AS</span> 总成绩</span><br><span class="line"><span class="keyword">FROM</span> student <span class="keyword">AS</span> stu <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> score <span class="keyword">AS</span> sc</span><br><span class="line"><span class="keyword">ON</span> stu.学号 <span class="operator">=</span> sc.学号</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> stu.学号</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询平均成绩大于85的所有学生的学号、姓名和平均成绩</span></span><br><span class="line"><span class="keyword">SELECT</span> stu.学号, stu.姓名, <span class="built_in">AVG</span>(sc.成绩) <span class="keyword">AS</span> 平均成绩</span><br><span class="line"><span class="keyword">FROM</span> student <span class="keyword">AS</span> stu <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> score <span class="keyword">AS</span> sc</span><br><span class="line"><span class="keyword">ON</span> stu.学号 <span class="operator">=</span> sc.学号</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> stu.学号</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">AVG</span>(sc.成绩)<span class="operator">&gt;</span><span class="number">85</span>;</span><br></pre></td></tr></table></figure>
<p>多表查询涉及到表联结，包括<code>INNOR JOIN</code> &#x2F; <code>JOIN</code>，<code>LEFT JOIN</code>，<code>RIGHT JOIN</code>，<code>FULL JOIN</code>，<code>CROSS JOIN</code>：</p>
<ul>
<li><code>INNOR JOIN</code> &#x2F; <code>JOIN</code>：返回左右表完全符合匹配条件时的数据</li>
</ul>
<p><img data-src="/../images/sql/inner_join.png" alt="`INNOR JOIN`"></p>
<ul>
<li><code>LEFT JOIN</code>：基于左表去匹配右表，结果左表全部行都显示，右表判断列与左边一致才有数据</li>
</ul>
<p><img data-src="/../images/sql/left_join.png" alt="`LEFT JOIN`"></p>
<ul>
<li><code>RIGHT JOIN</code>：基于右表去匹左表，结果右表全部行都显示，左表判断列与右表一致才有数据</li>
</ul>
<p><img data-src="/../images/sql/right_join.png" alt="`RIGHT JOIN`"></p>
<ul>
<li><code>FULL JOIN</code>：左右表格的行全部都有，左右表格判断一致的在同一行，不一致的单独一行。注意MYSQL数据库不支持<code>FULL JOIN</code>，可以通过同时使用<code>LEFT JOIN</code>和<code>RIGHT JOIN</code>，再使用<code>UNION</code>合并二者结果来实现。</li>
</ul>
<p><img data-src="/../images/sql/full_join.png" alt="`FULL JOIN`"></p>
<ul>
<li><code>CROSS JOIN</code>：返回的是左右表的笛卡尔乘积</li>
</ul>
<h3 id="2-3-3-CASE表达式"><a href="#2-3-3-CASE表达式" class="headerlink" title="2.3.3 CASE表达式"></a>2.3.3 CASE表达式</h3><p>根据数据转换为不同结果：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询各分数段的人数、课程号和课程名称</span></span><br><span class="line"><span class="keyword">SELECT</span> sc.课程号, c.课程名称,</span><br><span class="line">  <span class="built_in">SUM</span>(<span class="keyword">CASE</span></span><br><span class="line">        <span class="keyword">WHEN</span> 成绩 <span class="keyword">BETWEEN</span> <span class="number">80</span> <span class="keyword">AND</span> <span class="number">100</span> <span class="keyword">THEN</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">ELSE</span> <span class="number">0</span> <span class="keyword">END</span></span><br><span class="line">      ) <span class="keyword">AS</span> <span class="string">&#x27;[100-80]&#x27;</span>,</span><br><span class="line">  <span class="built_in">SUM</span>(<span class="keyword">CASE</span></span><br><span class="line">        <span class="keyword">WHEN</span> 成绩<span class="operator">&gt;=</span><span class="number">60</span> <span class="keyword">AND</span> 成绩<span class="operator">&lt;</span><span class="number">80</span> <span class="keyword">THEN</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">ELSE</span> <span class="number">0</span> <span class="keyword">END</span></span><br><span class="line">      ) <span class="keyword">AS</span> <span class="string">&#x27;[80-60]&#x27;</span>,</span><br><span class="line">  <span class="built_in">SUM</span>(<span class="keyword">CASE</span></span><br><span class="line">        <span class="keyword">WHEN</span> 成绩<span class="operator">&lt;</span><span class="number">60</span> <span class="keyword">THEN</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">ELSE</span> <span class="number">0</span> <span class="keyword">END</span></span><br><span class="line">      ) <span class="keyword">AS</span> <span class="string">&#x27;[&lt;60]&#x27;</span></span><br><span class="line"><span class="keyword">FROM</span> score <span class="keyword">AS</span> sc <span class="keyword">JOIN</span> course <span class="keyword">AS</span> c</span><br><span class="line"><span class="keyword">ON</span> sc.课程号 <span class="operator">=</span> c.课程号</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> sc.课程号, c.课程名称;</span><br></pre></td></tr></table></figure>

<h1 id="3-修改数据和数据表"><a href="#3-修改数据和数据表" class="headerlink" title="3 修改数据和数据表"></a>3 修改数据和数据表</h1><p>基本的<code>UPDATE</code>语句由三部分组成：要更新的表，列名和它们的新值；确定要更新哪些行的过滤条件：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> [tableName]</span><br><span class="line"><span class="keyword">SET</span> [field]</span><br><span class="line"><span class="keyword">WHERE</span> [<span class="keyword">condition</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">-- e.g.,</span></span><br><span class="line"><span class="keyword">UPDATE</span> student</span><br><span class="line"><span class="keyword">SET</span> 姓名<span class="operator">=</span><span class="string">&#x27;赵五&#x27;</span></span><br><span class="line"><span class="keyword">WHERE</span> 学号<span class="operator">=</span><span class="string">&#x27;11&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h1 id="4-删除数据和数据表"><a href="#4-删除数据和数据表" class="headerlink" title="4 删除数据和数据表"></a>4 删除数据和数据表</h1><h2 id="4-1-DELETE"><a href="#4-1-DELETE" class="headerlink" title="4.1 DELETE"></a>4.1 DELETE</h2><p>用于删除表中的特定数据：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> [tableName] <span class="keyword">WHERE</span> [codition];</span><br></pre></td></tr></table></figure>

<h2 id="4-2-DROP"><a href="#4-2-DROP" class="headerlink" title="4.2 DROP"></a>4.2 DROP</h2><p>删除整张表，包括表数据和表结构：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> [tableName];</span><br></pre></td></tr></table></figure>

<h2 id="4-3-TRUNCATE"><a href="#4-3-TRUNCATE" class="headerlink" title="4.3 TRUNCATE"></a>4.3 TRUNCATE</h2><p>清空表中数据：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> [tableName];</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> [查询目标]    <span class="comment">-- 指定要输出的结果</span></span><br><span class="line"><span class="keyword">FROM</span> [查询对象]      <span class="comment">-- 指定查哪些表，可以使用表联结：LEFT JOIN/INNER JOIN等</span></span><br><span class="line"><span class="keyword">WHERE</span> [查询条件]     <span class="comment">-- 可以使用子查询：IN/NOT IN</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> [分组字段]</span><br><span class="line"><span class="keyword">HAVING</span> [分组条件]    <span class="comment">-- 去掉不符合条件的分组，可以使用子查询：IN/NOT IN</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> [排序字段]  <span class="comment">-- 对分组结果进行排序</span></span><br><span class="line">LIMIT [i, n];</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Vim初学笔记（基于vimtutor）</title>
    <url>/2022/19295/</url>
    <content><![CDATA[<blockquote>
<p>之前一直觉得vim难用，远远比不上vscode之类的编辑器好用。最近在学Java后端开发，敲代码的时候居然感觉vim编辑器好像是方便一些，所以打算再复习一下。以下笔记仅供查阅。</p>
</blockquote>
<span id="more"></span>
<h1 id="1-基本操作"><a href="#1-基本操作" class="headerlink" title="1 基本操作"></a>1 基本操作</h1><h2 id="1-1-移动光标"><a href="#1-1-移动光标" class="headerlink" title="1.1 移动光标"></a>1.1 移动光标</h2><ul>
<li>h 左移</li>
<li>l 右移</li>
<li>j 下移</li>
<li>k 上移</li>
</ul>
<h2 id="1-2-删除、插入和添加"><a href="#1-2-删除、插入和添加" class="headerlink" title="1.2 删除、插入和添加"></a>1.2 删除、插入和添加</h2><ul>
<li>x 删除</li>
<li>a 在光标后插入</li>
<li>A 行尾插入</li>
<li>i 在光标前插入</li>
<li>I 在行首插入</li>
</ul>
<h1 id="2-组合命令"><a href="#2-组合命令" class="headerlink" title="2 组合命令"></a>2 组合命令</h1><h2 id="2-1-删除操作和相关命令"><a href="#2-1-删除操作和相关命令" class="headerlink" title="2.1 删除操作和相关命令"></a>2.1 删除操作和相关命令</h2><ul>
<li>de 删除当前字符到单词末尾</li>
<li>dw 删除当前光标到下个单词之前的内容 </li>
<li>d$ 删除本行光标之后的所有字符（包括光标指向的字符）</li>
<li>dd 删除整行（实际上相当于剪切）</li>
</ul>
<h2 id="2-2-关于命令和对象"><a href="#2-2-关于命令和对象" class="headerlink" title="2.2 关于命令和对象"></a>2.2 关于命令和对象</h2><ul>
<li>许多改变文本的命令都是由一个操作和一个对象构成：例如<code>d</code>表示delete，<code>w</code>表示<code>word</code>。</li>
<li>在命令前加数字可以表示该命令重复的次数，例如<code>2dw</code>表示执行两次<code>dw</code>。</li>
</ul>
<h2 id="2-4-撤销类命令"><a href="#2-4-撤销类命令" class="headerlink" title="2.4 撤销类命令"></a>2.4 撤销类命令</h2><ul>
<li>u 撤销最后执行的命令</li>
<li>U 撤销对整行的修改</li>
</ul>
<h1 id="3-剪贴和修改"><a href="#3-剪贴和修改" class="headerlink" title="3 剪贴和修改"></a>3 剪贴和修改</h1><h2 id="3-1-剪贴"><a href="#3-1-剪贴" class="headerlink" title="3.1 剪贴"></a>3.1 剪贴</h2><ul>
<li>dd 剪切整行</li>
<li>p 粘贴</li>
</ul>
<h2 id="3-2-修改"><a href="#3-2-修改" class="headerlink" title="3.2 修改"></a>3.2 修改</h2><ul>
<li>r 替换光标所在位置的字符</li>
<li>cw 修改至单词末尾的文本</li>
<li>ce 同上</li>
<li>c$ 修改至行末的文本</li>
</ul>
<h1 id="4-定位、搜索和替换"><a href="#4-定位、搜索和替换" class="headerlink" title="4 定位、搜索和替换"></a>4 定位、搜索和替换</h1><h2 id="4-1-定位及文件状态"><a href="#4-1-定位及文件状态" class="headerlink" title="4.1 定位及文件状态"></a>4.1 定位及文件状态</h2><ul>
<li>&lt;ctrl&gt;+g&#x2F;G 显示当前编辑的文件名和光标所在位置</li>
<li>G 跳转到文件最后一行</li>
<li>gg 跳转到文件第一行</li>
<li>#n G 跳转到第n行</li>
</ul>
<h2 id="4-2-搜索"><a href="#4-2-搜索" class="headerlink" title="4.2 搜索"></a>4.2 搜索</h2><ul>
<li>&#x2F;[target] 从前往后找</li>
<li>?[target] 从后往前找</li>
<li>n 下一个</li>
<li>N 上一个</li>
<li>% 将光标放在括号处，查找匹配的另一半括号</li>
</ul>
<h2 id="4-3-替换"><a href="#4-3-替换" class="headerlink" title="4.3 替换"></a>4.3 替换</h2><ul>
<li>:s&#x2F;[old]&#x2F;[new] 只替换第一个匹配到的串</li>
<li>:s&#x2F;[old]&#x2F;[new]&#x2F;g 替换全行的匹配串</li>
<li>:#,#s&#x2F;[old]&#x2F;[new]&#x2F;g 替换指定两行之间出现的每个匹配串，其中#,#代表的是替换操作的若干行中首尾两行的行号。</li>
<li>:%s&#x2F;[old]&#x2F;[new]&#x2F;g 替换整个文件中的每个匹配串</li>
<li>:%s&#x2F;[old]&#x2F;[new]&#x2F;gc 找到个文件中的每个匹配串，并且对每个匹配串提示是否进行替换</li>
</ul>
<h1 id="5-执行外部命令和保存"><a href="#5-执行外部命令和保存" class="headerlink" title="5 执行外部命令和保存"></a>5 执行外部命令和保存</h1><h2 id="5-1-执行外部命令"><a href="#5-1-执行外部命令" class="headerlink" title="5.1 执行外部命令"></a>5.1 执行外部命令</h2><ul>
<li>:![command] 可以执行外部命令，如<code>:!ls</code></li>
</ul>
<h2 id="5-2-保存和导入"><a href="#5-2-保存和导入" class="headerlink" title="5.2 保存和导入"></a>5.2 保存和导入</h2><ul>
<li>:w [filename] 保存文件</li>
<li>v进入visual模式，移动光标可以高亮部分文本，<code>:w [filename]</code>选择性保存文件</li>
<li>:r [filename] 导入指定文件</li>
</ul>
<h1 id="6-更多的编辑命令"><a href="#6-更多的编辑命令" class="headerlink" title="6 更多的编辑命令"></a>6 更多的编辑命令</h1><h2 id="6-1-插入"><a href="#6-1-插入" class="headerlink" title="6.1 插入"></a>6.1 插入</h2><ul>
<li>o 在光标的下方打开新的一行，并进入插入模式</li>
<li>R 可连续替换多个字符</li>
</ul>
<h2 id="6-2-复制"><a href="#6-2-复制" class="headerlink" title="6.2 复制"></a>6.2 复制</h2><ul>
<li>y 复制文本，使用这条命令要先用v进入visual模式，然后按y选中部分文本，最后按p粘贴文本</li>
</ul>
<h2 id="6-3-设置类命令"><a href="#6-3-设置类命令" class="headerlink" title="6.3 设置类命令"></a>6.3 设置类命令</h2><ul>
<li>:set ic 忽略搜索target的大小写</li>
<li>:set hls is 高亮搜索，输入的同时显示效果</li>
<li>:set noic 禁用忽略大小写</li>
<li>:nohlsearch 移除匹配项的高亮显示</li>
<li>&#x2F;[target]\c 仅在一次查找时忽略大小写</li>
</ul>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Vim</tag>
      </tags>
  </entry>
</search>
